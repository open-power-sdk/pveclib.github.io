<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>POWER Vector Library Manual: src/pveclib/vec_int64_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3653a864936a87c29f489ec2a5b8be1c.html">pveclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_int64_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over 64-bit integer elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__int32__ppc_8h_source.html">pveclib/vec_int32_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__int64__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5d87e069dbfd809587083c42a2b08575"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a5d87e069dbfd809587083c42a2b08575">vec_absdud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a5d87e069dbfd809587083c42a2b08575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Absolute Difference Unsigned Doubleword.  <a href="#a5d87e069dbfd809587083c42a2b08575">More...</a><br /></td></tr>
<tr class="separator:a5d87e069dbfd809587083c42a2b08575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28052c1907d1f733c9dda8a48039e546"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a28052c1907d1f733c9dda8a48039e546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Add Unsigned Doubleword Modulo.  <a href="#a28052c1907d1f733c9dda8a48039e546">More...</a><br /></td></tr>
<tr class="separator:a28052c1907d1f733c9dda8a48039e546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cdec54548bd95e04d4835d96b1bea4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a03cdec54548bd95e04d4835d96b1bea4">vec_clzd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra)</td></tr>
<tr class="memdesc:a03cdec54548bd95e04d4835d96b1bea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count leading zeros for a vector unsigned long int.  <a href="#a03cdec54548bd95e04d4835d96b1bea4">More...</a><br /></td></tr>
<tr class="separator:a03cdec54548bd95e04d4835d96b1bea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f77d3e0509c70e9facdaeda6498351"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a77f77d3e0509c70e9facdaeda6498351">vec_cmpeqsd</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a77f77d3e0509c70e9facdaeda6498351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal Signed Doubleword.  <a href="#a77f77d3e0509c70e9facdaeda6498351">More...</a><br /></td></tr>
<tr class="separator:a77f77d3e0509c70e9facdaeda6498351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560aef2acfdf1db1cf14848ec6cb0c1c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a560aef2acfdf1db1cf14848ec6cb0c1c">vec_cmpequd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a560aef2acfdf1db1cf14848ec6cb0c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Equal Unsigned Doubleword.  <a href="#a560aef2acfdf1db1cf14848ec6cb0c1c">More...</a><br /></td></tr>
<tr class="separator:a560aef2acfdf1db1cf14848ec6cb0c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd20f737baf4e0e7829a80e6679e38f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#aacd20f737baf4e0e7829a80e6679e38f">vec_cmpgesd</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:aacd20f737baf4e0e7829a80e6679e38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than or Equal Signed Doubleword.  <a href="#aacd20f737baf4e0e7829a80e6679e38f">More...</a><br /></td></tr>
<tr class="separator:aacd20f737baf4e0e7829a80e6679e38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c23131dbeac361dec5b8cb95d2737f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a8c23131dbeac361dec5b8cb95d2737f9">vec_cmpgeud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a8c23131dbeac361dec5b8cb95d2737f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than or Equal Unsigned Doubleword.  <a href="#a8c23131dbeac361dec5b8cb95d2737f9">More...</a><br /></td></tr>
<tr class="separator:a8c23131dbeac361dec5b8cb95d2737f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17e8dea0fd54f5d88386f71e042741a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#ab17e8dea0fd54f5d88386f71e042741a">vec_cmpgtsd</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:ab17e8dea0fd54f5d88386f71e042741a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than Signed Doubleword.  <a href="#ab17e8dea0fd54f5d88386f71e042741a">More...</a><br /></td></tr>
<tr class="separator:ab17e8dea0fd54f5d88386f71e042741a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb17e3bb401eff58cf827c9fc5f281bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#aeb17e3bb401eff58cf827c9fc5f281bf">vec_cmpgtud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:aeb17e3bb401eff58cf827c9fc5f281bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Greater Than Unsigned Doubleword.  <a href="#aeb17e3bb401eff58cf827c9fc5f281bf">More...</a><br /></td></tr>
<tr class="separator:aeb17e3bb401eff58cf827c9fc5f281bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a737796be7a1cd7a1942910b8c1b09"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a59a737796be7a1cd7a1942910b8c1b09">vec_cmplesd</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a59a737796be7a1cd7a1942910b8c1b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than Equal Signed Doubleword.  <a href="#a59a737796be7a1cd7a1942910b8c1b09">More...</a><br /></td></tr>
<tr class="separator:a59a737796be7a1cd7a1942910b8c1b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2296a65434efd3e0d974c86b014861b3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a2296a65434efd3e0d974c86b014861b3">vec_cmpleud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a2296a65434efd3e0d974c86b014861b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Less Than Equal Unsigned Doubleword.  <a href="#a2296a65434efd3e0d974c86b014861b3">More...</a><br /></td></tr>
<tr class="separator:a2296a65434efd3e0d974c86b014861b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb88c77cd54bf1863dc75a0c29d575d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a4fb88c77cd54bf1863dc75a0c29d575d">vec_cmpltsd</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a4fb88c77cd54bf1863dc75a0c29d575d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare less Than Signed Doubleword.  <a href="#a4fb88c77cd54bf1863dc75a0c29d575d">More...</a><br /></td></tr>
<tr class="separator:a4fb88c77cd54bf1863dc75a0c29d575d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23cdb84882a03083962b1679b622ea4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#ac23cdb84882a03083962b1679b622ea4">vec_cmpltud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:ac23cdb84882a03083962b1679b622ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare less Than Unsigned Doubleword.  <a href="#ac23cdb84882a03083962b1679b622ea4">More...</a><br /></td></tr>
<tr class="separator:ac23cdb84882a03083962b1679b622ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6c76027da33eef370932fce5c541b0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a3a6c76027da33eef370932fce5c541b0">vec_cmpnesd</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a3a6c76027da33eef370932fce5c541b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Not Equal Signed Doubleword.  <a href="#a3a6c76027da33eef370932fce5c541b0">More...</a><br /></td></tr>
<tr class="separator:a3a6c76027da33eef370932fce5c541b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d83929ca3ee7b493864319cd019303"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a13d83929ca3ee7b493864319cd019303">vec_cmpneud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a13d83929ca3ee7b493864319cd019303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare Not Equal Unsigned Doubleword.  <a href="#a13d83929ca3ee7b493864319cd019303">More...</a><br /></td></tr>
<tr class="separator:a13d83929ca3ee7b493864319cd019303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68408e5c95633f47202d0ddf224389de"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a68408e5c95633f47202d0ddf224389de">vec_cmpsd_all_eq</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a68408e5c95633f47202d0ddf224389de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Equal Signed Doubleword.  <a href="#a68408e5c95633f47202d0ddf224389de">More...</a><br /></td></tr>
<tr class="separator:a68408e5c95633f47202d0ddf224389de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaf4f81689304675d749759a88d86c0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a8aaf4f81689304675d749759a88d86c0">vec_cmpsd_all_ge</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a8aaf4f81689304675d749759a88d86c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than or Equal Signed Doubleword.  <a href="#a8aaf4f81689304675d749759a88d86c0">More...</a><br /></td></tr>
<tr class="separator:a8aaf4f81689304675d749759a88d86c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fffe85d6f314f935fcd1fabf0ebe389"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a1fffe85d6f314f935fcd1fabf0ebe389">vec_cmpsd_all_gt</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a1fffe85d6f314f935fcd1fabf0ebe389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than Signed Doubleword.  <a href="#a1fffe85d6f314f935fcd1fabf0ebe389">More...</a><br /></td></tr>
<tr class="separator:a1fffe85d6f314f935fcd1fabf0ebe389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73113dbb2579e1cc75ce14c7e066f049"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a73113dbb2579e1cc75ce14c7e066f049">vec_cmpsd_all_le</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a73113dbb2579e1cc75ce14c7e066f049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less than equal Signed Doubleword.  <a href="#a73113dbb2579e1cc75ce14c7e066f049">More...</a><br /></td></tr>
<tr class="separator:a73113dbb2579e1cc75ce14c7e066f049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecd14e25b4de7ce7bb657e0e2f492bc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a9ecd14e25b4de7ce7bb657e0e2f492bc">vec_cmpsd_all_lt</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a9ecd14e25b4de7ce7bb657e0e2f492bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less than Signed Doubleword.  <a href="#a9ecd14e25b4de7ce7bb657e0e2f492bc">More...</a><br /></td></tr>
<tr class="separator:a9ecd14e25b4de7ce7bb657e0e2f492bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a29d79ba5ecf2c5fce676964644ca2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a87a29d79ba5ecf2c5fce676964644ca2">vec_cmpsd_all_ne</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a87a29d79ba5ecf2c5fce676964644ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Not Equal Signed Doubleword.  <a href="#a87a29d79ba5ecf2c5fce676964644ca2">More...</a><br /></td></tr>
<tr class="separator:a87a29d79ba5ecf2c5fce676964644ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f82c3268a53f2c23a353458e5bcce5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a30f82c3268a53f2c23a353458e5bcce5">vec_cmpsd_any_eq</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a30f82c3268a53f2c23a353458e5bcce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Equal Signed Doubleword.  <a href="#a30f82c3268a53f2c23a353458e5bcce5">More...</a><br /></td></tr>
<tr class="separator:a30f82c3268a53f2c23a353458e5bcce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146dc334912901502038e5b1c7a91698"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a146dc334912901502038e5b1c7a91698">vec_cmpsd_any_ge</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a146dc334912901502038e5b1c7a91698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Greater Than or Equal Signed Doubleword.  <a href="#a146dc334912901502038e5b1c7a91698">More...</a><br /></td></tr>
<tr class="separator:a146dc334912901502038e5b1c7a91698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea7f8d78bbae66170fcbe2870fb5c0a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#aaea7f8d78bbae66170fcbe2870fb5c0a">vec_cmpsd_any_gt</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:aaea7f8d78bbae66170fcbe2870fb5c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Greater Than Signed Doubleword.  <a href="#aaea7f8d78bbae66170fcbe2870fb5c0a">More...</a><br /></td></tr>
<tr class="separator:aaea7f8d78bbae66170fcbe2870fb5c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3882a5d27471ac7b5375da64512795"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a3e3882a5d27471ac7b5375da64512795">vec_cmpsd_any_le</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a3e3882a5d27471ac7b5375da64512795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Less than equal Signed Doubleword.  <a href="#a3e3882a5d27471ac7b5375da64512795">More...</a><br /></td></tr>
<tr class="separator:a3e3882a5d27471ac7b5375da64512795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8173aebfd8c92e3f95f54f823d5060b0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a8173aebfd8c92e3f95f54f823d5060b0">vec_cmpsd_any_lt</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:a8173aebfd8c92e3f95f54f823d5060b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Less than Signed Doubleword.  <a href="#a8173aebfd8c92e3f95f54f823d5060b0">More...</a><br /></td></tr>
<tr class="separator:a8173aebfd8c92e3f95f54f823d5060b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7f0973c81ab62009df9452cb3708fb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#aaf7f0973c81ab62009df9452cb3708fb">vec_cmpsd_any_ne</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> b)</td></tr>
<tr class="memdesc:aaf7f0973c81ab62009df9452cb3708fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Not Equal Signed Doubleword.  <a href="#aaf7f0973c81ab62009df9452cb3708fb">More...</a><br /></td></tr>
<tr class="separator:aaf7f0973c81ab62009df9452cb3708fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7660b170e71ec58ee95a79cd1c47d5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a8a7660b170e71ec58ee95a79cd1c47d5">vec_cmpud_all_eq</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a8a7660b170e71ec58ee95a79cd1c47d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Equal Unsigned Doubleword.  <a href="#a8a7660b170e71ec58ee95a79cd1c47d5">More...</a><br /></td></tr>
<tr class="separator:a8a7660b170e71ec58ee95a79cd1c47d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6264e6ca42126726b0e490754dde0db7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a6264e6ca42126726b0e490754dde0db7">vec_cmpud_all_ge</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a6264e6ca42126726b0e490754dde0db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than or Equal Unsigned Doubleword.  <a href="#a6264e6ca42126726b0e490754dde0db7">More...</a><br /></td></tr>
<tr class="separator:a6264e6ca42126726b0e490754dde0db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13f19199e5872ecaf88742043f26642"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#af13f19199e5872ecaf88742043f26642">vec_cmpud_all_gt</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:af13f19199e5872ecaf88742043f26642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Greater Than Unsigned Doubleword.  <a href="#af13f19199e5872ecaf88742043f26642">More...</a><br /></td></tr>
<tr class="separator:af13f19199e5872ecaf88742043f26642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871f91423e5154739ae225c82620d6b4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a871f91423e5154739ae225c82620d6b4">vec_cmpud_all_le</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a871f91423e5154739ae225c82620d6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less than equal Unsigned Doubleword.  <a href="#a871f91423e5154739ae225c82620d6b4">More...</a><br /></td></tr>
<tr class="separator:a871f91423e5154739ae225c82620d6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dcb361982b9da13b02373d720d6c7d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a55dcb361982b9da13b02373d720d6c7d">vec_cmpud_all_lt</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a55dcb361982b9da13b02373d720d6c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Less than Unsigned Doubleword.  <a href="#a55dcb361982b9da13b02373d720d6c7d">More...</a><br /></td></tr>
<tr class="separator:a55dcb361982b9da13b02373d720d6c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156844dcaee20356c7a1f7af9981c03f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a156844dcaee20356c7a1f7af9981c03f">vec_cmpud_all_ne</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a156844dcaee20356c7a1f7af9981c03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare all Not Equal Unsigned Doubleword.  <a href="#a156844dcaee20356c7a1f7af9981c03f">More...</a><br /></td></tr>
<tr class="separator:a156844dcaee20356c7a1f7af9981c03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440a601539df9f00dfe3669b06ea5766"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a440a601539df9f00dfe3669b06ea5766">vec_cmpud_any_eq</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a440a601539df9f00dfe3669b06ea5766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Equal Unsigned Doubleword.  <a href="#a440a601539df9f00dfe3669b06ea5766">More...</a><br /></td></tr>
<tr class="separator:a440a601539df9f00dfe3669b06ea5766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5c292fdc26335cf5bb18f83d346cc2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a5a5c292fdc26335cf5bb18f83d346cc2">vec_cmpud_any_ge</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a5a5c292fdc26335cf5bb18f83d346cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Greater Than or Equal Unsigned Doubleword.  <a href="#a5a5c292fdc26335cf5bb18f83d346cc2">More...</a><br /></td></tr>
<tr class="separator:a5a5c292fdc26335cf5bb18f83d346cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f43c88ffe8c0cad11b901fa6fc2598"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a77f43c88ffe8c0cad11b901fa6fc2598">vec_cmpud_any_gt</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a77f43c88ffe8c0cad11b901fa6fc2598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Greater Than Unsigned Doubleword.  <a href="#a77f43c88ffe8c0cad11b901fa6fc2598">More...</a><br /></td></tr>
<tr class="separator:a77f43c88ffe8c0cad11b901fa6fc2598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6d11774a7f88bfab6507148c6e90a4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a3d6d11774a7f88bfab6507148c6e90a4">vec_cmpud_any_le</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a3d6d11774a7f88bfab6507148c6e90a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Less than equal Unsigned Doubleword.  <a href="#a3d6d11774a7f88bfab6507148c6e90a4">More...</a><br /></td></tr>
<tr class="separator:a3d6d11774a7f88bfab6507148c6e90a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370eb06be197554734a6a29a730f500d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a370eb06be197554734a6a29a730f500d">vec_cmpud_any_lt</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a370eb06be197554734a6a29a730f500d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Less than Unsigned Doubleword.  <a href="#a370eb06be197554734a6a29a730f500d">More...</a><br /></td></tr>
<tr class="separator:a370eb06be197554734a6a29a730f500d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03d831ec09612229357e2ea34383eaf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#aa03d831ec09612229357e2ea34383eaf">vec_cmpud_any_ne</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:aa03d831ec09612229357e2ea34383eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Compare any Not Equal Unsigned Doubleword.  <a href="#aa03d831ec09612229357e2ea34383eaf">More...</a><br /></td></tr>
<tr class="separator:aa03d831ec09612229357e2ea34383eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bde04363b6d427c6e64470febe95ae"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a88bde04363b6d427c6e64470febe95ae">vec_maxsd</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vrb)</td></tr>
<tr class="memdesc:a88bde04363b6d427c6e64470febe95ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Maximum Signed Doubleword.  <a href="#a88bde04363b6d427c6e64470febe95ae">More...</a><br /></td></tr>
<tr class="separator:a88bde04363b6d427c6e64470febe95ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3550c9cebe5e01bf08cee3c5f46ff0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#afc3550c9cebe5e01bf08cee3c5f46ff0">vec_maxud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:afc3550c9cebe5e01bf08cee3c5f46ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Maximum Unsigned Doubleword.  <a href="#afc3550c9cebe5e01bf08cee3c5f46ff0">More...</a><br /></td></tr>
<tr class="separator:afc3550c9cebe5e01bf08cee3c5f46ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de4bb38c2aba5f34836ef70bc875010"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a0de4bb38c2aba5f34836ef70bc875010">vec_minsd</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vrb)</td></tr>
<tr class="memdesc:a0de4bb38c2aba5f34836ef70bc875010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Minimum Signed Doubleword.  <a href="#a0de4bb38c2aba5f34836ef70bc875010">More...</a><br /></td></tr>
<tr class="separator:a0de4bb38c2aba5f34836ef70bc875010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24220d787ac863b7911a303da17d1a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#ad24220d787ac863b7911a303da17d1a0">vec_minud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:ad24220d787ac863b7911a303da17d1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Minimum Unsigned Doubleword.  <a href="#ad24220d787ac863b7911a303da17d1a0">More...</a><br /></td></tr>
<tr class="separator:ad24220d787ac863b7911a303da17d1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5bafec6c1c15b0336551e82d1169d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#acd5bafec6c1c15b0336551e82d1169d4">vec_mrgahd</a> (<a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:acd5bafec6c1c15b0336551e82d1169d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Algebraic High Doublewords.  <a href="#acd5bafec6c1c15b0336551e82d1169d4">More...</a><br /></td></tr>
<tr class="separator:acd5bafec6c1c15b0336551e82d1169d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5242d6311cd5ab50377cfeb2cf2ac8bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a5242d6311cd5ab50377cfeb2cf2ac8bf">vec_mrgald</a> (<a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vrb)</td></tr>
<tr class="memdesc:a5242d6311cd5ab50377cfeb2cf2ac8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Algebraic Low Doublewords.  <a href="#a5242d6311cd5ab50377cfeb2cf2ac8bf">More...</a><br /></td></tr>
<tr class="separator:a5242d6311cd5ab50377cfeb2cf2ac8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259fa00ad1a75612c87a0460140eef7a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a259fa00ad1a75612c87a0460140eef7a">vec_mrged</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VA, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VB)</td></tr>
<tr class="memdesc:a259fa00ad1a75612c87a0460140eef7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Even Doubleword. Merge the even doubleword elements from two vectors into the high and low doubleword elements of the result. This is effectively the VSX Permute Doubleword Immediate operation modified for endian.  <a href="#a259fa00ad1a75612c87a0460140eef7a">More...</a><br /></td></tr>
<tr class="separator:a259fa00ad1a75612c87a0460140eef7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cebc174283a4069f1f8bca5ddc5b518"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a4cebc174283a4069f1f8bca5ddc5b518">vec_mrghd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VA, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VB)</td></tr>
<tr class="memdesc:a4cebc174283a4069f1f8bca5ddc5b518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge High Doubleword. Merge the high doubleword elements from two vectors into the high and low doubleword elements of the result. This is effectively the VSX Permute Doubleword Immediate operation modified for endian.  <a href="#a4cebc174283a4069f1f8bca5ddc5b518">More...</a><br /></td></tr>
<tr class="separator:a4cebc174283a4069f1f8bca5ddc5b518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100acbe58743381f32d5c068959668b7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a100acbe58743381f32d5c068959668b7">vec_mrgld</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VA, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VB)</td></tr>
<tr class="memdesc:a100acbe58743381f32d5c068959668b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Low Doubleword. Merge the low doubleword elements from two vectors into the high and low doubleword elements of the result. This is effectively the VSX Permute Doubleword Immediate operation modified for endian.  <a href="#a100acbe58743381f32d5c068959668b7">More...</a><br /></td></tr>
<tr class="separator:a100acbe58743381f32d5c068959668b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e55ac2c234b4062b02cf1b2ef2ba56"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a75e55ac2c234b4062b02cf1b2ef2ba56">vec_mrgod</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VA, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VB)</td></tr>
<tr class="memdesc:a75e55ac2c234b4062b02cf1b2ef2ba56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Odd Doubleword. Merge the odd doubleword elements from two vectors into the high and low doubleword elements of the result. This is effectively the VSX Permute Doubleword Immediate operation modified for endian.  <a href="#a75e55ac2c234b4062b02cf1b2ef2ba56">More...</a><br /></td></tr>
<tr class="separator:a75e55ac2c234b4062b02cf1b2ef2ba56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d183ebd232e5826be109cdaa421aeed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed">vec_msumudm</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b, <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> c)</td></tr>
<tr class="memdesc:a1d183ebd232e5826be109cdaa421aeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Sum Unsigned Doubleword Modulo.  <a href="#a1d183ebd232e5826be109cdaa421aeed">More...</a><br /></td></tr>
<tr class="separator:a1d183ebd232e5826be109cdaa421aeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f95e02f7b0551e3f2bb7e4b4da040d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a26f95e02f7b0551e3f2bb7e4b4da040d">vec_muleud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a26f95e02f7b0551e3f2bb7e4b4da040d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Even Unsigned Doublewords.  <a href="#a26f95e02f7b0551e3f2bb7e4b4da040d">More...</a><br /></td></tr>
<tr class="separator:a26f95e02f7b0551e3f2bb7e4b4da040d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10780cd8a88f18ec564ee6254c179a06"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06">vec_mulhud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a10780cd8a88f18ec564ee6254c179a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Unsigned Doubleword.  <a href="#a10780cd8a88f18ec564ee6254c179a06">More...</a><br /></td></tr>
<tr class="separator:a10780cd8a88f18ec564ee6254c179a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa989582cbfaa7984f78a937225e92f4a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#aa989582cbfaa7984f78a937225e92f4a">vec_muloud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:aa989582cbfaa7984f78a937225e92f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Odd Unsigned Doublewords.  <a href="#aa989582cbfaa7984f78a937225e92f4a">More...</a><br /></td></tr>
<tr class="separator:aa989582cbfaa7984f78a937225e92f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f19a53d6d28ac9b2aab5b8e1c5b2cbb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb">vec_muludm</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a2f19a53d6d28ac9b2aab5b8e1c5b2cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Unsigned Doubleword Modulo.  <a href="#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb">More...</a><br /></td></tr>
<tr class="separator:a2f19a53d6d28ac9b2aab5b8e1c5b2cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53159a600aba803503ae6ddcb539a123"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a53159a600aba803503ae6ddcb539a123">vec_pasted</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VH, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> __VL)</td></tr>
<tr class="memdesc:a53159a600aba803503ae6ddcb539a123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector doubleword paste. Concatenate the high doubleword of the 1st vector with the low double word of the 2nd vector.  <a href="#a53159a600aba803503ae6ddcb539a123">More...</a><br /></td></tr>
<tr class="separator:a53159a600aba803503ae6ddcb539a123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8238ba590103ac80fb146a6a2b1aed1c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a8238ba590103ac80fb146a6a2b1aed1c">vec_permdi</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb, const int ctl)</td></tr>
<tr class="memdesc:a8238ba590103ac80fb146a6a2b1aed1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Permute Doubleword Immediate. Combine a doubleword selected from the 1st (vra) vector with a doubleword selected from the 2nd (vrb) vector.  <a href="#a8238ba590103ac80fb146a6a2b1aed1c">More...</a><br /></td></tr>
<tr class="separator:a8238ba590103ac80fb146a6a2b1aed1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db4e91aa49c03fbb4a8da5a174c7b07"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a0db4e91aa49c03fbb4a8da5a174c7b07">vec_popcntd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra)</td></tr>
<tr class="memdesc:a0db4e91aa49c03fbb4a8da5a174c7b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Population Count doubleword.  <a href="#a0db4e91aa49c03fbb4a8da5a174c7b07">More...</a><br /></td></tr>
<tr class="separator:a0db4e91aa49c03fbb4a8da5a174c7b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4af62c6235b7b47daea6f00cd8ea33a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#ae4af62c6235b7b47daea6f00cd8ea33a">vec_revbd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra)</td></tr>
<tr class="memdesc:ae4af62c6235b7b47daea6f00cd8ea33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte reverse each doubleword for a vector unsigned long int.  <a href="#ae4af62c6235b7b47daea6f00cd8ea33a">More...</a><br /></td></tr>
<tr class="separator:ae4af62c6235b7b47daea6f00cd8ea33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8406367635fbd8f1c50a11f6d650a2a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#ad8406367635fbd8f1c50a11f6d650a2a">vec_vrld</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:ad8406367635fbd8f1c50a11f6d650a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Rotate Left Doubleword.  <a href="#ad8406367635fbd8f1c50a11f6d650a2a">More...</a><br /></td></tr>
<tr class="separator:ad8406367635fbd8f1c50a11f6d650a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb3ddc8b334ae25119a02e749884290"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a0fb3ddc8b334ae25119a02e749884290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Left Doubleword.  <a href="#a0fb3ddc8b334ae25119a02e749884290">More...</a><br /></td></tr>
<tr class="separator:a0fb3ddc8b334ae25119a02e749884290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e352b9d7cc7cdb597a14ddb0933387"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a89e352b9d7cc7cdb597a14ddb0933387">vec_vsrd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a89e352b9d7cc7cdb597a14ddb0933387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Doubleword.  <a href="#a89e352b9d7cc7cdb597a14ddb0933387">More...</a><br /></td></tr>
<tr class="separator:a89e352b9d7cc7cdb597a14ddb0933387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517f21d7f771077a51f26718311ca64e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a517f21d7f771077a51f26718311ca64e">vec_vsrad</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a517f21d7f771077a51f26718311ca64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Algebraic Doubleword.  <a href="#a517f21d7f771077a51f26718311ca64e">More...</a><br /></td></tr>
<tr class="separator:a517f21d7f771077a51f26718311ca64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e4f1f514f5a0e0dc52083f3afd9113"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#ad3e4f1f514f5a0e0dc52083f3afd9113">vec_rldi</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:ad3e4f1f514f5a0e0dc52083f3afd9113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Rotate left Doubleword Immediate.  <a href="#ad3e4f1f514f5a0e0dc52083f3afd9113">More...</a><br /></td></tr>
<tr class="separator:ad3e4f1f514f5a0e0dc52083f3afd9113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aee7d73450e9b7008af0428030f1028"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a6aee7d73450e9b7008af0428030f1028">vec_sldi</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a6aee7d73450e9b7008af0428030f1028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift left Doubleword Immediate.  <a href="#a6aee7d73450e9b7008af0428030f1028">More...</a><br /></td></tr>
<tr class="separator:a6aee7d73450e9b7008af0428030f1028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671e86d52ad53adce6a558476c7ffc0c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c">vec_splatd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, const int ctl)</td></tr>
<tr class="memdesc:a671e86d52ad53adce6a558476c7ffc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of the result. This is effectively the VSX Merge doubleword operation modified for endian.  <a href="#a671e86d52ad53adce6a558476c7ffc0c">More...</a><br /></td></tr>
<tr class="separator:a671e86d52ad53adce6a558476c7ffc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd0665fb16981d85c7f948c0578f928"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a9cd0665fb16981d85c7f948c0578f928">vec_spltd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, const int ctl)</td></tr>
<tr class="separator:a9cd0665fb16981d85c7f948c0578f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be336316770fa12d116c7e82427d2fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a1be336316770fa12d116c7e82427d2fd">vec_srdi</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a1be336316770fa12d116c7e82427d2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Doubleword Immediate.  <a href="#a1be336316770fa12d116c7e82427d2fd">More...</a><br /></td></tr>
<tr class="separator:a1be336316770fa12d116c7e82427d2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6058f691cf57976e30f0294a183d2715"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a6058f691cf57976e30f0294a183d2715">vec_sradi</a> (<a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a6058f691cf57976e30f0294a183d2715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Algebraic Doubleword Immediate.  <a href="#a6058f691cf57976e30f0294a183d2715">More...</a><br /></td></tr>
<tr class="separator:a6058f691cf57976e30f0294a183d2715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7aee3c81538f5537680b610d934500"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a0b7aee3c81538f5537680b610d934500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Subtract Unsigned Doubleword Modulo.  <a href="#a0b7aee3c81538f5537680b610d934500">More...</a><br /></td></tr>
<tr class="separator:a0b7aee3c81538f5537680b610d934500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d2b39711c06106097ef869a20420b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a42d2b39711c06106097ef869a20420b6">vec_swapd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra)</td></tr>
<tr class="memdesc:a42d2b39711c06106097ef869a20420b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector doubleword swap. Exchange the high and low doubleword elements of a vector.  <a href="#a42d2b39711c06106097ef869a20420b6">More...</a><br /></td></tr>
<tr class="separator:a42d2b39711c06106097ef869a20420b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8daafaa42c16823750d7fe61224662"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a9e8daafaa42c16823750d7fe61224662">vec_vmadd2eud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> c, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> d)</td></tr>
<tr class="memdesc:a9e8daafaa42c16823750d7fe61224662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add2 Even Unsigned Doublewords.  <a href="#a9e8daafaa42c16823750d7fe61224662">More...</a><br /></td></tr>
<tr class="separator:a9e8daafaa42c16823750d7fe61224662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6280736f91cb67eca10b55e750bfe1de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a6280736f91cb67eca10b55e750bfe1de">vec_vmaddeud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> c)</td></tr>
<tr class="memdesc:a6280736f91cb67eca10b55e750bfe1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add Even Unsigned Doublewords.  <a href="#a6280736f91cb67eca10b55e750bfe1de">More...</a><br /></td></tr>
<tr class="separator:a6280736f91cb67eca10b55e750bfe1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66cdabc7f2bc00f79579ce90fd483e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#af66cdabc7f2bc00f79579ce90fd483e0">vec_vmadd2oud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> c, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> d)</td></tr>
<tr class="memdesc:af66cdabc7f2bc00f79579ce90fd483e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add2 Odd Unsigned Doublewords.  <a href="#af66cdabc7f2bc00f79579ce90fd483e0">More...</a><br /></td></tr>
<tr class="separator:af66cdabc7f2bc00f79579ce90fd483e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b83d2696455fea53b1ecf434a0daf8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#ae0b83d2696455fea53b1ecf434a0daf8">vec_vmaddoud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> c)</td></tr>
<tr class="memdesc:ae0b83d2696455fea53b1ecf434a0daf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add Odd Unsigned Doublewords.  <a href="#ae0b83d2696455fea53b1ecf434a0daf8">More...</a><br /></td></tr>
<tr class="separator:ae0b83d2696455fea53b1ecf434a0daf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e6361054b52ac4564bcef25b718151"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a84e6361054b52ac4564bcef25b718151">vec_vmuleud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a84e6361054b52ac4564bcef25b718151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Even Unsigned Doublewords.  <a href="#a84e6361054b52ac4564bcef25b718151">More...</a><br /></td></tr>
<tr class="separator:a84e6361054b52ac4564bcef25b718151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208744996e7482604ad274b44999d6ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a208744996e7482604ad274b44999d6ce">vec_vmuloud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</td></tr>
<tr class="memdesc:a208744996e7482604ad274b44999d6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Odd Unsigned Doublewords.  <a href="#a208744996e7482604ad274b44999d6ce">More...</a><br /></td></tr>
<tr class="separator:a208744996e7482604ad274b44999d6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f6f199cdf39641d940f5b8d55dbf6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a43f6f199cdf39641d940f5b8d55dbf6b">vec_vmsumeud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b, <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> c)</td></tr>
<tr class="memdesc:a43f6f199cdf39641d940f5b8d55dbf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Sum Even Unsigned Doublewords.  <a href="#a43f6f199cdf39641d940f5b8d55dbf6b">More...</a><br /></td></tr>
<tr class="separator:a43f6f199cdf39641d940f5b8d55dbf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04385860c7a03a9aa57f4a31017caf81"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a04385860c7a03a9aa57f4a31017caf81">vec_vmsumoud</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b, <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> c)</td></tr>
<tr class="memdesc:a04385860c7a03a9aa57f4a31017caf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Sum Odd Unsigned Doublewords.  <a href="#a04385860c7a03a9aa57f4a31017caf81">More...</a><br /></td></tr>
<tr class="separator:a04385860c7a03a9aa57f4a31017caf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188540de9d76b546ef27e4d3fe21a57b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a188540de9d76b546ef27e4d3fe21a57b">vec_vpkudum</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a188540de9d76b546ef27e4d3fe21a57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Pack Unsigned Doubleword Unsigned Modulo.  <a href="#a188540de9d76b546ef27e4d3fe21a57b">More...</a><br /></td></tr>
<tr class="separator:a188540de9d76b546ef27e4d3fe21a57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55ccf9e8b50b5b1198e4cc226000282"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#af55ccf9e8b50b5b1198e4cc226000282">vec_xxspltd</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, const int ctl)</td></tr>
<tr class="memdesc:af55ccf9e8b50b5b1198e4cc226000282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of the result.  <a href="#af55ccf9e8b50b5b1198e4cc226000282">More...</a><br /></td></tr>
<tr class="separator:af55ccf9e8b50b5b1198e4cc226000282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e20bdd1df7e3e49dca06d5512ada84b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a1e20bdd1df7e3e49dca06d5512ada84b">vec_vmaddeuw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> c)</td></tr>
<tr class="memdesc:a1e20bdd1df7e3e49dca06d5512ada84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add Even Unsigned Words.  <a href="#a1e20bdd1df7e3e49dca06d5512ada84b">More...</a><br /></td></tr>
<tr class="separator:a1e20bdd1df7e3e49dca06d5512ada84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b046a56d566ec2ea351042fd9dd11de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a1b046a56d566ec2ea351042fd9dd11de">vec_vmadd2euw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> c, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> d)</td></tr>
<tr class="memdesc:a1b046a56d566ec2ea351042fd9dd11de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add2 Even Unsigned Words.  <a href="#a1b046a56d566ec2ea351042fd9dd11de">More...</a><br /></td></tr>
<tr class="separator:a1b046a56d566ec2ea351042fd9dd11de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32acead723b7867ff4c9f8be9bb708ca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a32acead723b7867ff4c9f8be9bb708ca">vec_vmaddouw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> c)</td></tr>
<tr class="memdesc:a32acead723b7867ff4c9f8be9bb708ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add Odd Unsigned Words.  <a href="#a32acead723b7867ff4c9f8be9bb708ca">More...</a><br /></td></tr>
<tr class="separator:a32acead723b7867ff4c9f8be9bb708ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ab00ed413c1aa1a8148cd9981235bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a40ab00ed413c1aa1a8148cd9981235bf">vec_vmadd2ouw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> c, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> d)</td></tr>
<tr class="memdesc:a40ab00ed413c1aa1a8148cd9981235bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add2 Odd Unsigned Words.  <a href="#a40ab00ed413c1aa1a8148cd9981235bf">More...</a><br /></td></tr>
<tr class="separator:a40ab00ed413c1aa1a8148cd9981235bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431720fd713485fcb13963cdcb89ac76"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int64__ppc_8h.html#a431720fd713485fcb13963cdcb89ac76">vec_vmsumuwm</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrc)</td></tr>
<tr class="memdesc:a431720fd713485fcb13963cdcb89ac76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Sum Unsigned Word Modulo.  <a href="#a431720fd713485fcb13963cdcb89ac76">More...</a><br /></td></tr>
<tr class="separator:a431720fd713485fcb13963cdcb89ac76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over 64-bit integer elements. </p>
<p>Most of these operations are implemented in a single instruction on newer (POWER8/POWER9) processors. This header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides a in-line assembler implementation for older compilers that do not provide the built-ins.</p>
<p>The original VMX (AKA Altivec) did not define any doubleword element (long long integer or double float) operations. The VSX facility (introduced with POWER7) added vector double float but did not add any integer doubleword (64-bit) operations. However it did add a useful doubleword permute immediate and word wise; merge, shift, and splat immediate operations. Otherwise vector long int (64-bit elements) operations have to be implemented using VMX word and halfword element integer operations for POWER7.</p>
<p>POWER8 (PowerISA 2.07B) adds important doubleword integer (add, subtract, compare, shift, rotate, ...) VMX operations. POWER8 also added multiply word operations that produce the full doubleword product and full quadword add / subtract (with carry extend).</p>
<p>POWER9 (PowerISA 3.0B) adds the <b>Vector Multiply-Sum Unsigned Doubleword Modulo</b> instruction. This is not the expected multiply even/odd/modulo doubleword nor a full multiply modulo quadword. But with a few extra (permutes and splat zero) instructions you can get equivalent function.</p>
<dl class="section note"><dt>Note</dt><dd>The doubleword integer multiply implementations are included in <a class="el" href="vec__int128__ppc_8h.html" title="Header package containing a collection of 128-bit computation functions implemented with PowerISA VMX...">vec_int128_ppc.h</a>. This resolves a circular dependency as 64-bit by 64-bit integer multiplies require 128-bit integer addition (<a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>) to produce the full product. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm</a>, <a class="el" href="vec__int64__ppc_8h.html#a26f95e02f7b0551e3f2bb7e4b4da040d" title="Vector Multiply Even Unsigned Doublewords. ">vec_muleud</a>, <a class="el" href="vec__int64__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06" title="Vector Multiply High Unsigned Doubleword. ">vec_mulhud</a>, <a class="el" href="vec__int64__ppc_8h.html#aa989582cbfaa7984f78a937225e92f4a" title="Vector Multiply Odd Unsigned Doublewords. ">vec_muloud</a>, <a class="el" href="vec__int64__ppc_8h.html#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb" title="Vector Multiply Unsigned Doubleword Modulo. ">vec_muludm</a>, <a class="el" href="vec__int64__ppc_8h.html#a84e6361054b52ac4564bcef25b718151" title="Vector Multiply Even Unsigned Doublewords. ">vec_vmuleud</a>, and <a class="el" href="vec__int64__ppc_8h.html#a208744996e7482604ad274b44999d6ce" title="Vector Multiply Odd Unsigned Doublewords. ">vec_vmuloud</a></dd></dl>
<p>Most of these intrinsic (compiler built-in) operations are defined in &lt;altivec.h&gt; and described in the compiler documentation. However it took several compiler releases for all the new POWER8 64-bit integer vector intrinsics to be added to <b>altivec.h</b>. This support started with the GCC 4.9 but was not complete across function/type and bug free until GCC 6.0.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example, if you compile with <b>-mcpu=power7</b>, vec_vclz and vec_vclzd will not be defined. But vec_clzd is always defined in this header, will generate the minimum code, appropriate for the target, and produce correct results.</dd></dl>
<p>64-bit integer operations are commonly used in the implementation of optimized double float math library functions and this applies to the vector equivalents of math functions. So missing, incomplete or buggy support for vector long integer intrinsics can be a impediment to the implementation of optimized and portable vector double math libraries. This header is a prerequisite for <a class="el" href="vec__f64__ppc_8h.html" title="Header package containing a collection of 128-bit SIMD operations over 64-bit double-precision floati...">vec_f64_ppc.h</a> which together are intended to support the implementation of vector math libraries.</p>
<p>Most of these operations are implemented in a single instruction on newer (POWER8/POWER9) processors. So this header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides a in-line assembler implementation for older compilers that do not provide the built-ins.</p>
<p>This header covers operations that are any of the following:</p>
<ul>
<li>Implemented in hardware instructions for later processors and useful to programmers, on slightly older processors, even if the equivalent function requires more instructions. Examples include the doubleword operations: Add, Compare, Maximum, Minimum and Subtract.</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.n&gt; provided by available compilers in common use. Examples include doubleword forms of: Multiply Even/Odd/Modulo, Count Leading Zeros, Population Count, and Byte Reverse operations.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious. Examples include doubleword forms of: Merge Algebraic High/Low, Paste, and Rotate/Shift Immediate operations.</li>
<li>Commonly used operations that are useful for doubleword, but are missing from the PowerISA and OpenPOWER ABI. Examples include: Absolute Difference Doubleword and Multiply-Sum Unsigned Word Modulo.</li>
</ul>
<h1><a class="anchor" id="i64_missing_ops_0_0"></a>
Some missing doubleword operations</h1>
<p>The original VMX instruction set extension was limited to byte, halfword, and word size element operations. This limited vector arithmetic operations to char, short, int and float elements. This limitation persisted until PowerISA 2.06 (POWER7) added the Vector Scalar Extensions (VSX) facility. VSX combined/extended the FPRs and VRs into 64 by 128-bit Vector/Scalar Registers (VSRs).</p>
<p>VSX added a large number of scalar double-precision and vector single / double-precision floating-point operations. The double-precision scalar (<b>xs</b> prefix) instructions where largely duplicates of the existing Floating-Point Facility operations, extended to access the whole (64) VSX register set. Similarly the VSX vector single precision floating-point (<b>xv</b> prefix, <b>sp</b> suffix) instructions were added to give vectorized float code access to 64 VSX registers.</p>
<p>The addition of VSX vector double-precision (<b>xv</b> prefix) instructions was the most significant addition. This added vector doubleword floating-point operations and provided access to all 64 VSX registers. Alas, there are no doubleword (64-bit long) integer operations in the initial VSX. A few logical and permute class (<b>xx</b> prefix) operations on word/doubleword elements where tacked on. These apply equally to float and integer elements. But nothing for 64-bit integer arithmetic.</p>
<dl class="section note"><dt>Note</dt><dd>The full title in PowerISA 2.06 is <b>Vector-Scalar Floating-Point Operations [Category: VSX]</b>.</dd></dl>
<p>PowerISA 2.07 (POWER8) did add a significant number of doubleword (64-bit) integer operations. Including;</p><ul>
<li>Add and subtract modulo</li>
<li>Signed and unsigned compare, maximum, minimum,</li>
<li>Shift and rotate</li>
<li>Count leading zeros and population count</li>
</ul>
<p>Also a number of new word (32-bit) integer operations;</p><ul>
<li>Multiply even/odd/modulo.</li>
<li>Pack signed/unsigned/saturate and Unpack signed.</li>
<li>Merge even/odd words</li>
</ul>
<p>And some new quadword (128-bit) integer operations;</p><ul>
<li>Add and Subtract modulo/extend/write-carry</li>
<li>Decimal Add and Subtract modulo</li>
</ul>
<p>And some specialized operations;</p><ul>
<li>Crypto, Raid, Polynomial multiply-sum</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The operations above are all Vector Category and can only access the 32 original vector registers (VSRs 32-63).</dd></dl>
<p>The new VSX operations (with access to all 64 VSRs) were not directly applicable to 64-bit integer arithmetic:</p><ul>
<li>Scalar single precision floating-point</li>
<li>Direct move between GPRs and VSRs</li>
<li>Logical operations; equivalence, not and, or compliment</li>
</ul>
<p>PowerISA 3.0 (POWER9) adds a few more doubleword (64-bit) integer operations. Including;</p><ul>
<li>Compare not equal</li>
<li>Count trailing zeros and parity</li>
<li>Extract and Insert</li>
<li>Multiply-sum modulo</li>
<li>Negate</li>
<li>Rotate Left under mask</li>
</ul>
<p>Also a number of new word (32-bit) integer operations;</p><ul>
<li>Absolute Difference word</li>
<li>Extend Sign word to doubleword</li>
</ul>
<p>And some new quadword (128-bit) integer operations;</p><ul>
<li>Multiply-by-10 extend/write-carry</li>
<li>Decimal convert from/to signed (binary) quadword</li>
<li>Decimal convert from/to zoned (ASCII char)</li>
<li>Decimal shift/round/truncate</li>
</ul>
<p>The new VSX operations (with access to all 64 VSRs) were not directly applicable to 64-bit integer arithmetic:</p><ul>
<li>Scalar quad-precision floating-point</li>
<li>Scalar and Vector convert with rounding</li>
<li>Scalar and Vector extract/insert exponent/significand</li>
<li>Scalar and Vector test data class</li>
<li>Permute and Permute right index</li>
</ul>
<p>An impressive list of operations that can be used for;</p><ul>
<li>Vectorizing long integer loops</li>
<li>Implementing useful quadword integer operations which do not have corresponding PowerISA instructions</li>
<li>implementing extended precision multiply and multiplicative inverse operations</li>
</ul>
<p>The challenge is that useful operations available for POWER9 will need equivalent implementations for POWER8 and POWER7. Similarly for operations introduced for POWER8 will need POWER7 implementations. Also there are some obvious missing operations;</p><ul>
<li>Absolute Difference Doubleword (we have byte, halfword, and word)</li>
<li>Average Doubleword (we have byte, halfword, and word)</li>
<li>Extend Sign Doubleword to quadword (we have byte, halfword, and word)</li>
<li>Multiply-sum Word (we have byte, halfword, and doubleword)</li>
<li>Multiply Even/Odd Doublewords (we have byte, halfword, and word)</li>
</ul>
<h2><a class="anchor" id="i64_missing_ops_0_1"></a>
Challenges and opportunities</h2>
<p>The stated goals for pveclib are:</p><ul>
<li>Provide equivalent functions across versions of the compiler.</li>
<li>Provide equivalent functions across versions of the PowerISA.</li>
<li>Provide complete arithmetic operations across supported C types.</li>
</ul>
<p>So the first step is to provide implementations for the key POWER8 doubleword integer operations for older compilers. For example, some of the generic doubleword integer operations were not defined until GCC 6.0. Here we define the specific Compare Equal Unsigned Doubleword implementation: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span></div><div class="line"><a class="code" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a></div><div class="line"><a class="code" href="vec__int64__ppc_8h.html#a560aef2acfdf1db1cf14848ec6cb0c1c">vec_cmpequd</a> (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> result;</div><div class="line"><span class="preprocessor">#ifdef _ARCH_PWR8</span></div><div class="line"><span class="preprocessor">#if __GNUC__ &gt;= 6</span></div><div class="line">  result = vec_cmpeq(a, b);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  __asm__(</div><div class="line">      <span class="stringliteral">&quot;vcmpequd %0,%1,%2;\n&quot;</span></div><div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (result)</div><div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (a),</div><div class="line">      <span class="stringliteral">&quot;v&quot;</span> (b)</div><div class="line">      : );</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <span class="comment">// _ARCH_PWR7 implementation ...</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  <span class="keywordflow">return</span> (result);</div><div class="line">}</div></div><!-- fragment --><p> The implementation checks if the compile target is POWER8 then checks of the compiler is new enough to use the generic vector compare built-in. If the generic built-in is not defined in &lt;altivec.h&gt; then we provide the equivalent inline assembler.</p>
<p>For POWER7 targets we don't have any vector compare doubleword operations and we need to define the equivalent operation using PowerISA 2.06B (and earlier) instructions. For example: </p><div class="fragment"><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <span class="comment">// _ARCH_PWR7 implementation ...</span></div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> permute =</div><div class="line">    { 0x04,0x05,0x06,0x07, 0x00,0x01,0x02,0x03,</div><div class="line">      0x0C,0x0D,0x0E,0x0F, 0x08,0x09,0x0A,0x0B};</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> r, rr;</div><div class="line">  r = (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vec_cmpeq ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) a, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) b);</div><div class="line">  <span class="keywordflow">if</span> (vec_any_ne ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) a, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) b))</div><div class="line">    {</div><div class="line">       rr = vec_perm (r, r, permute);</div><div class="line">       r= vec_and (r, rr);</div><div class="line">    }</div><div class="line">  result = (<a class="code" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a>)r;</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p> Here we use Compare Equal Unsigned Word. If all words are equal, use the result as is. Otherwise, if any word elements are not equal, we do some extra work. For each doubleword, rotate the word compare result by 32-bits (here we use permute as we don't have rotate doubleword either). Then logical and the original word compare and rotated results to get the final doubleword compare results.</p>
<p>Similarly for all the doubleword compare variants. Similarly for doubleword; add, subtract, maximum, minimum, shift, rotate, count leading zeros, population count, and Byte reverse.</p>
<h2><a class="anchor" id="i64_missing_ops_0_2"></a>
More Challenges</h2>
<p>Now we can look at the case where vector doubleword operations of interest don't have an equivalent instruction. Here interesting operations include those that are supported for other element sizes and types.</p>
<p>The simplest example is absolute difference which was introduced in PowerISA 3.0 for byte, halfword and word elements. From the implementation of <a class="el" href="vec__int32__ppc_8h.html#a85ec15f292163e0e40e6faa5f4797367" title="Vector Absolute Difference Unsigned Word. ">vec_absduw()</a> we see how to implement the operation for POWER8 using subtract, maximum, and minimum. For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div><div class="line"><a class="code" href="vec__int64__ppc_8h.html#a5d87e069dbfd809587083c42a2b08575">vec_absdud</a> (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int64__ppc_8h.html#a0b7aee3c81538f5537680b610d934500">vec_subudm</a> (<a class="code" href="vec__int64__ppc_8h.html#afc3550c9cebe5e01bf08cee3c5f46ff0">vec_maxud</a> (vra, vrb), <a class="code" href="vec__int64__ppc_8h.html#ad24220d787ac863b7911a303da17d1a0">vec_minud</a> (vra, vrb));</div><div class="line">}</div></div><!-- fragment --><p> This works because pveclib provides implementations for min, max, and sub operations that work across GCC versions and provide processor specific implementations for POWER8/9 and POWER7.</p>
<p>Now we need to look at the multiply doubleword situation. We need implementations for <a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm()</a>, <a class="el" href="vec__int64__ppc_8h.html#a26f95e02f7b0551e3f2bb7e4b4da040d" title="Vector Multiply Even Unsigned Doublewords. ">vec_muleud()</a>, <a class="el" href="vec__int64__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06" title="Vector Multiply High Unsigned Doubleword. ">vec_mulhud()</a>, <a class="el" href="vec__int64__ppc_8h.html#aa989582cbfaa7984f78a937225e92f4a" title="Vector Multiply Odd Unsigned Doublewords. ">vec_muloud()</a>, and <a class="el" href="vec__int64__ppc_8h.html#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb" title="Vector Multiply Unsigned Doubleword Modulo. ">vec_muludm()</a>. We saw in the implementations of <a class="el" href="vec__int32__ppc_8h.html" title="Header package containing a collection of 128-bit SIMD operations over 32-bit integer elements...">vec_int32_ppc.h</a> that multiply high and low/modulo can implemented using multiply and merge even/odd of that element size. Multiply low can also be implemented using the multiply sum and multiply odd of the next smaller element size. Also multiply-sum can be implemented using multiply even/odd and a couple of adds. And multiply even/odd can be implemented using multiply sum by supplying zeros to appropriate inputs/elements.</p>
<p>The above discussion has many circular dependencies. Eventually we need to get down to an implementation on each processor using actual hardware instructions. So what multiply doubleword operations does the PowerISA actually have from the list above:</p><ul>
<li>POWER9 added multiply-sum unsigned doubleword modulo but no multiply doubleword even/odd/modulo instructions.</li>
<li>POWER8 added multiply even/odd/modulo word but no multiply-sum word instructions</li>
<li>POWER7 and earlier we have the original VMX multiply even/odd halfword, and multiply-sum unsigned halfword modulo, but no multiply modulo halfword.</li>
</ul>
<p>It seems the best implementation strategy uses;</p><ul>
<li>Multiply-sum doubleword for POWER9</li>
<li>Multiply even/odd word for POWER8</li>
<li>Multiply even/odd halfword for POWER7</li>
</ul>
<p>We really care about performance and latency for POWER9/8. We need POWER7 to work correctly so we can test on and support <em>legacy</em> hardware. The rest is grade school math.</p>
<p>First we need to make sure we have implementations across the GCC versions 6, 7, and 8 for the instructions we need. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a></div><div class="line"><a class="code" href="vec__int128__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed">vec_msumudm</a> (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b, <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> c)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> res;</div><div class="line"><span class="preprocessor">#if defined (_ARCH_PWR9) &amp;&amp; ((__GNUC__ &gt;= 6) || (__clang_major__ &gt;= 11))</span></div><div class="line">  __asm__(</div><div class="line">      <span class="stringliteral">&quot;vmsumudm %0,%1,%2,%3;\n&quot;</span></div><div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (res)</div><div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (a), <span class="stringliteral">&quot;v&quot;</span> (b), <span class="stringliteral">&quot;v&quot;</span> (c)</div><div class="line">      : );</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> p_even, p_odd, p_sum;</div><div class="line"></div><div class="line">  p_even = <a class="code" href="vec__int128__ppc_8h.html#a26f95e02f7b0551e3f2bb7e4b4da040d">vec_muleud</a> (a, b);</div><div class="line">  p_odd  = <a class="code" href="vec__int128__ppc_8h.html#aa989582cbfaa7984f78a937225e92f4a">vec_muloud</a> (a, b);</div><div class="line">  p_sum  = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (p_even, p_odd);</div><div class="line">  res    = <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> (p_sum, c);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  <span class="keywordflow">return</span> (res);</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The _ARCH_PWR8 implementation above depends on <a class="el" href="vec__int64__ppc_8h.html#a26f95e02f7b0551e3f2bb7e4b4da040d" title="Vector Multiply Even Unsigned Doublewords. ">vec_muleud()</a> and <a class="el" href="vec__int64__ppc_8h.html#aa989582cbfaa7984f78a937225e92f4a" title="Vector Multiply Odd Unsigned Doublewords. ">vec_muloud()</a> for which there are no hardware instructions. Hold that thought.</dd></dl>
<p>While we are it we can implement multiply-sum unsigned word modulo. </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div><div class="line"><a class="code" href="vec__int64__ppc_8h.html#a431720fd713485fcb13963cdcb89ac76">vec_vmsumuwm</a> (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb, <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrc)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> peven, podd, psum;</div><div class="line"></div><div class="line">  peven = <a class="code" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> (vra, vrb);</div><div class="line">  podd  = <a class="code" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> (vra, vrb);</div><div class="line">  psum  = <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (peven, podd);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546">vec_addudm</a> (psum, vrc);</div><div class="line">}</div></div><!-- fragment --><p> We will need this later.</p>
<p>Now we need to provide implementations of <a class="el" href="vec__int64__ppc_8h.html#a26f95e02f7b0551e3f2bb7e4b4da040d" title="Vector Multiply Even Unsigned Doublewords. ">vec_muleud()</a> and <a class="el" href="vec__int64__ppc_8h.html#aa989582cbfaa7984f78a937225e92f4a" title="Vector Multiply Odd Unsigned Doublewords. ">vec_muloud()</a>. For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a></div><div class="line"><a class="code" href="vec__int128__ppc_8h.html#a26f95e02f7b0551e3f2bb7e4b4da040d">vec_muleud</a> (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</div><div class="line">{</div><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int128__ppc_8h.html#a208744996e7482604ad274b44999d6ce">vec_vmuloud</a> (a, b);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int128__ppc_8h.html#a84e6361054b52ac4564bcef25b718151">vec_vmuleud</a> (a, b);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">}</span></div></div><!-- fragment --><p> The implementation above is just handling the pesky little endian transforms. The real implementations are in <a class="el" href="vec__int64__ppc_8h.html#a84e6361054b52ac4564bcef25b718151" title="Vector Multiply Even Unsigned Doublewords. ">vec_vmuleud()</a> and <a class="el" href="vec__int64__ppc_8h.html#a208744996e7482604ad274b44999d6ce" title="Vector Multiply Odd Unsigned Doublewords. ">vec_vmuloud()</a> which implement the operation as if the PowerISA included such an instruction. These implementation is NOT endian sensitive and the function is stable across BE/LE implementations. For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a></div><div class="line"><a class="code" href="vec__int128__ppc_8h.html#a84e6361054b52ac4564bcef25b718151">vec_vmuleud</a> (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> a, <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> res;</div><div class="line"><span class="preprocessor">#if defined (_ARCH_PWR9) &amp;&amp; ((__GNUC__ &gt;= 6) || (__clang_major__ &gt;= 11))</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> zero = { 0, 0 };</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> b_eud = <a class="code" href="vec__int64__ppc_8h.html#acd5bafec6c1c15b0336551e82d1169d4">vec_mrgahd</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) b, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) zero);</div><div class="line">  __asm__(</div><div class="line">      <span class="stringliteral">&quot;vmsumudm %0,%1,%2,%3;\n&quot;</span></div><div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (res)</div><div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (a), <span class="stringliteral">&quot;v&quot;</span> (b_eud), <span class="stringliteral">&quot;v&quot;</span> (zero)</div><div class="line">      : );</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#ifdef _ARCH_PWR8</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> zero = { 0, 0 };</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> p0, p1, pp10, pp01;</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> m0, m1;</div><div class="line"></div><div class="line">  <span class="comment">// Need the endian invariant merge word high here</span></div><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <span class="comment">// Nullify the little endian transform</span></div><div class="line">  m0 = vec_mergel ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) b, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) b);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  m0 = vec_mergeh ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) b, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) b);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  m1 = (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) <a class="code" href="vec__int64__ppc_8h.html#af55ccf9e8b50b5b1198e4cc226000282">vec_xxspltd</a> ((<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) a, 0);</div><div class="line"></div><div class="line">  <span class="comment">// Need the endian invariant multiply even/odd word here</span></div><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <span class="comment">// Nullify the little endian transform</span></div><div class="line">  p1 = <a class="code" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> (m1, m0);</div><div class="line">  p0 = <a class="code" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> (m1, m0);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  p1 = <a class="code" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> (m1, m0);</div><div class="line">  p0 = <a class="code" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> (m1, m0);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  <span class="comment">// res[1] = p1[1];  res[0] = p0[0];</span></div><div class="line">  res = <a class="code" href="vec__int64__ppc_8h.html#a53159a600aba803503ae6ddcb539a123">vec_pasted</a> (p0, p1);</div><div class="line"></div><div class="line">  <span class="comment">// pp10[1] = p1[0]; pp10[0] = 0;</span></div><div class="line">  <span class="comment">// pp01[1] = p0[1]; pp01[0] = 0;</span></div><div class="line">  <span class="comment">// Need the endian invariant merge algebraic high/low here</span></div><div class="line">  pp10 = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int64__ppc_8h.html#acd5bafec6c1c15b0336551e82d1169d4">vec_mrgahd</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) zero, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) p1);</div><div class="line">  pp01 = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int64__ppc_8h.html#a5242d6311cd5ab50377cfeb2cf2ac8bf">vec_mrgald</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) zero, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) p0);</div><div class="line">  <span class="comment">// pp01 = pp01 + pp10.</span></div><div class="line">  pp01 = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) pp01, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) pp10);</div><div class="line"></div><div class="line">  <span class="comment">// res = res + (pp01 &lt;&lt; 32)</span></div><div class="line">  pp01 = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) vec_sld ((<a class="code" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>) pp01, (<a class="code" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>) pp01, 4);</div><div class="line">  res = (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) <a class="code" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8">vec_adduqm</a> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) pp01, (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) res);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <span class="comment">// _ARCH_PWR7 implementation ...</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  <span class="keywordflow">return</span> ((<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) res);</div><div class="line">}</div></div><!-- fragment --><p> The _ARCH_PWR9 implementation uses the multiply-sum doubleword operation but implements the multiply even behavior by forcing the contents of doubleword element 1 of [VRB] and the contents of [VRC] to 0.</p>
<p>The _ARCH_PWR8 implementation looks ugly but it works. It starts with some merges and splats to get inputs columns lined up for the multiply. Then we use (POWER8 instructions) Multiply Even/Odd Unsigned Word to generate doubleword partial products. Then more merges and a rotate to line up the partial products for summation as the final quadword product.</p>
<p>Individually <a class="el" href="vec__int64__ppc_8h.html#a84e6361054b52ac4564bcef25b718151" title="Vector Multiply Even Unsigned Doublewords. ">vec_vmuleud()</a> and <a class="el" href="vec__int64__ppc_8h.html#a208744996e7482604ad274b44999d6ce" title="Vector Multiply Odd Unsigned Doublewords. ">vec_vmuloud()</a> execute with a latency of 21-23 cycles on POWER8. Normally these operations are used and scheduled together as in the POWER8 implementation of <a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm()</a> or <a class="el" href="vec__int64__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06" title="Vector Multiply High Unsigned Doubleword. ">vec_mulhud()</a>. Good scheduling by the compiler and pipelining keeps the POWER8 latency in the 28-32 cycle range. For example, the <a class="el" href="vec__int64__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06" title="Vector Multiply High Unsigned Doubleword. ">vec_mulhud()</a> implementation: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div><div class="line"><a class="code" href="vec__int128__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06">vec_mulhud</a> (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int64__ppc_8h.html#acd5bafec6c1c15b0336551e82d1169d4">vec_mrgahd</a> (<a class="code" href="vec__int128__ppc_8h.html#a84e6361054b52ac4564bcef25b718151">vec_vmuleud</a> (vra, vrb), <a class="code" href="vec__int128__ppc_8h.html#a208744996e7482604ad274b44999d6ce">vec_vmuloud</a> (vra, vrb));</div><div class="line">}</div></div><!-- fragment --><p> Generates the following code for POWER8: </p><div class="fragment"><div class="line">vspltisw v0,0</div><div class="line">xxmrghw vs33,vs35,vs35</div><div class="line">xxspltd vs45,vs34,0</div><div class="line">xxmrglw vs35,vs35,vs35</div><div class="line">vmulouw v11,v13,v1</div><div class="line">xxspltd vs34,vs34,1</div><div class="line">xxmrghd vs41,vs32,vs43</div><div class="line">vmulouw v12,v2,v3</div><div class="line">vmuleuw v13,v13,v1</div><div class="line">vmuleuw v2,v2,v3</div><div class="line">xxmrghd vs42,vs32,vs44</div><div class="line">xxmrgld vs33,vs32,vs45</div><div class="line">xxmrgld vs32,vs32,vs34</div><div class="line">xxpermdi vs44,vs34,vs44,1</div><div class="line">vadduqm v1,v1,v9</div><div class="line">xxpermdi vs45,vs45,vs43,1</div><div class="line">vadduqm v0,v0,v10</div><div class="line">vsldoi  v1,v1,v1,4</div><div class="line">vsldoi  v0,v0,v0,4</div><div class="line">vadduqm v2,v1,v13</div><div class="line">vadduqm v0,v0,v12</div><div class="line">xxmrghd vs34,vs34,vs32</div></div><!-- fragment --><p>The POWER9 latencies for this operation range from 5-7 (for vmsumudm itself) to 11-16 (for <a class="el" href="vec__int64__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06" title="Vector Multiply High Unsigned Doubleword. ">vec_mulhud()</a>). The additional latency reflects zero constant vector generation and merges required to condition the inputs and output. For these operations the <a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm()</a>, <em>vrc</em> operand is always zero. Selecting the even/odd doubleword for input requires a merge low/high. And selecting the high doubleword for multiply high require a final merge high.</p>
<p><a class="el" href="vec__int64__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06" title="Vector Multiply High Unsigned Doubleword. ">vec_mulhud()</a> generates the following code for POWER9: </p><div class="fragment"><div class="line">xxspltib vs32,0</div><div class="line">xxmrghd vs33,vs35,vs32</div><div class="line">xxmrgld vs35,vs32,vs35</div><div class="line">vmsumudm v1,v2,v1,v0</div><div class="line">vmsumudm v2,v2,v3,v0</div><div class="line">xxmrghd vs34,vs33,vs34</div></div><!-- fragment --><p>Wrapping up the doubleword multiplies we should look at the multiply low (AKA Multiply Unsigned Doubleword Modulo). The POWER9 implementation is similar to vec_mulhud () and the generated code is similar to the example above.</p>
<p>Multiply low doubleword is a special case, as we are discarding the highest partial doubleword product. For POWER8 we can optimize for that case using multiply odd and multiply-sum word operations. Also as we are only generating doubleword partial products we only need add doubleword modulo operations to sum the results. This avoids the more expensive add quadword operation required for the general case. The fact that <a class="el" href="vec__int64__ppc_8h.html#a431720fd713485fcb13963cdcb89ac76" title="Vector Multiply-Sum Unsigned Word Modulo. ">vec_vmsumuwm()</a> is only a software construct is not an issue. It expands into hardware multiple even/odd word and add doubleword instructions that the compiler can schedule and optimize.</p>
<p>Here <a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d" title="Vector multiply odd unsigned words. ">vec_mulouw()</a> generates low order partial product. Then vec_vrld () and <a class="el" href="vec__int64__ppc_8h.html#a431720fd713485fcb13963cdcb89ac76" title="Vector Multiply-Sum Unsigned Word Modulo. ">vec_vmsumuwm()</a> generate doubleword sums of the two middle order partial products. Then <a class="el" href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290" title="Vector Shift Left Doubleword. ">vec_vsld()</a> shifts the middle order partial sum left 32-bits (discarding the unneeded high order 32-bits). Finally sum the low and middle order partial doubleword products to produce the multiply-low doubleword result. For example, this POWER8 only implementation: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></div><div class="line"><a class="code" href="vec__int128__ppc_8h.html#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb">vec_muludm</a> (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> s32 = { 32, 32 }; <span class="comment">// shift / rotate amount.</span></div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> z = { 0, 0 };</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> t2, t3, t4;</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> t1;</div><div class="line"></div><div class="line">  t1 = (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) <a class="code" href="vec__int64__ppc_8h.html#ad8406367635fbd8f1c50a11f6d650a2a">vec_vrld</a> (vrb, s32);</div><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <span class="comment">// Nullify the little endian transform, really want mulouw here.</span></div><div class="line">  t2 = <a class="code" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vra, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vrb);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  t2 = <a class="code" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vra, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vrb);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  t3 = <a class="code" href="vec__int64__ppc_8h.html#a431720fd713485fcb13963cdcb89ac76">vec_vmsumuwm</a> ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vra, t1, z);</div><div class="line">  t4 = <a class="code" href="vec__int64__ppc_8h.html#a0fb3ddc8b334ae25119a02e749884290">vec_vsld</a> (t3, s32);</div><div class="line">  <span class="keywordflow">return</span> (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>) vec_vaddudm (t4, t2);</div><div class="line">}</div></div><!-- fragment --><p> Which generates the following for POWER8: </p><div class="fragment"><div class="line">addis   r9,r2,.rodata.cst16+0x60@ha</div><div class="line">addi    r9,r9,.rodata.cst16+0x60@l</div><div class="line">lxv     vs33,0,r9</div><div class="line">vmulouw v13,v2,v3</div><div class="line">vrld    v0,v3,v1</div><div class="line">vmulouw v3,v2,v0</div><div class="line">vmuleuw v2,v2,v0</div><div class="line">vaddudm v2,v3,v2</div><div class="line">vsld    v2,v2,v1</div><div class="line">vaddudm v2,v13,v2</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The addition of <em>zeros</em> to the final sum of <a class="el" href="vec__int64__ppc_8h.html#a431720fd713485fcb13963cdcb89ac76" title="Vector Multiply-Sum Unsigned Word Modulo. ">vec_vmsumuwm()</a> (<em>vec_addudm (psum, vrc)</em>)has been optimized away by the compiler. This eliminates the xxspltib and one vaddudm instruction from the final code sequence.</dd></dl>
<p>And we can assume that the constant load of <em>{ 32, 32 }</em> will be common-ed with other operations or hoisted out of loops. So the shift constant can be loaded early and vrld is not delayed. This keeps the POWER8 latency in the 19-28 cycle range.</p>
<h1><a class="anchor" id="i64_endian_issues_0_0"></a>
Endian problems with doubleword operations</h1>
<p>From the examples above we see that the construction of higher precision multiplies requires significant massaging of input and output elements. Here merge even/odd, merge high/low, swap, and splat doubleword element operations are commonly used.</p>
<p>PowerISA 2.06 VSX (POWER7) added the general purpose Vector Permute Doubleword Immediate (xxpermdi). The compiler generates some form of xxpermdi for the doubleword (double float, long int, bool long) merge/splat/swap operations. As xxpermdi's element selection is an immediate field, most operations require only a single instruction. All the merge/splat/swap doubleword variant are just a specific select mask value and the inputs to xxpermdi.</p>
<p>Which is very useful indeed for assembling, disassembling, merging, splatting, swapping, and pasting doubleword elements.</p>
<p>Of course it took several compiler releases to implement all the generic merge/splat/swap operations for the supported types. GCC 4.8 as the first to support vec_xxpermdi as a built-in. GCC 4.8 also supported the generic built-ins vec_mergeh, vec_mergel, and vec_splat for the vector signed/unsigned/bool long type. But endian sensitive vec_mergeh, vec_mergel, and vec_splat were not supported until GCC 7. And the generic vec_mergee, vec_mergeo built-ins where not supported until GCC 8.</p>
<p>But as we have explained in <a class="el" href="index.html#mainpage_endian_issues_1_1">General Endian Issues</a> and <a class="el" href="vec__int32__ppc_8h.html#i32_endian_issues_0_0">Endian problems with word operations</a> the little endian transforms applied by the compiler can cause problems for developers of multi-precision libraries. The doubleword forms of the generic merge/splat operations etc. are no exception. This is especially annoying when the endian sensitive transforms are applied between releases of the compiler.</p>
<p>So we need a strategy to provide endian invariant merge/splat/swap operations to be used in multi-precision arithmetic. And another set of endian sensitive operations that are mandated by the OpenPOWER ABI.</p>
<p>First we need a safely endian invariant version of xxpermdi to use in building other variants:</p><ul>
<li><a class="el" href="vec__int64__ppc_8h.html#a8238ba590103ac80fb146a6a2b1aed1c" title="Vector Permute Doubleword Immediate. Combine a doubleword selected from the 1st (vra) vector with a d...">vec_permdi()</a> provides the basic xxpermdi operation but nullifies the little endian transforms.</li>
</ul>
<p>Then build the core set of endian invariant permute doubleword operations using <a class="el" href="vec__int64__ppc_8h.html#a8238ba590103ac80fb146a6a2b1aed1c" title="Vector Permute Doubleword Immediate. Combine a doubleword selected from the 1st (vra) vector with a d...">vec_permdi()</a>:</p><ul>
<li>Merge algebraic high/low doubleword operations <a class="el" href="vec__int64__ppc_8h.html#acd5bafec6c1c15b0336551e82d1169d4" title="Vector Merge Algebraic High Doublewords. ">vec_mrgahd()</a> and <a class="el" href="vec__int64__ppc_8h.html#a5242d6311cd5ab50377cfeb2cf2ac8bf" title="Vector Merge Algebraic Low Doublewords. ">vec_mrgald()</a>.</li>
<li>Merge the left and right most doublewords from a double quadword operation <a class="el" href="vec__int64__ppc_8h.html#a53159a600aba803503ae6ddcb539a123" title="Vector doubleword paste. Concatenate the high doubleword of the 1st vector with the low double word o...">vec_pasted()</a>.</li>
<li>Splat from the high/even or low/odd doubleword operation <a class="el" href="vec__int64__ppc_8h.html#af55ccf9e8b50b5b1198e4cc226000282" title="Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of ...">vec_xxspltd()</a>.</li>
<li>Swap high and low doublewords operation <a class="el" href="vec__int64__ppc_8h.html#a42d2b39711c06106097ef869a20420b6" title="Vector doubleword swap. Exchange the high and low doubleword elements of a vector. ">vec_swapd()</a>.</li>
</ul>
<p>We use the merge algebraic high/low doubleword operations in the implementation of <a class="el" href="vec__int64__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06" title="Vector Multiply High Unsigned Doubleword. ">vec_mulhud()</a>, <a class="el" href="vec__int64__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06" title="Vector Multiply High Unsigned Doubleword. ">vec_mulhud()</a>, <a class="el" href="vec__int64__ppc_8h.html#a84e6361054b52ac4564bcef25b718151" title="Vector Multiply Even Unsigned Doublewords. ">vec_vmuleud()</a>, and <a class="el" href="vec__int64__ppc_8h.html#a208744996e7482604ad274b44999d6ce" title="Vector Multiply Odd Unsigned Doublewords. ">vec_vmuloud()</a>. We use the vec_xxspltd operation in the implementation of <a class="el" href="vec__int64__ppc_8h.html#ad8406367635fbd8f1c50a11f6d650a2a" title="Vector Rotate Left Doubleword. ">vec_vrld()</a>, <a class="el" href="vec__int64__ppc_8h.html#a84e6361054b52ac4564bcef25b718151" title="Vector Multiply Even Unsigned Doublewords. ">vec_vmuleud()</a>, and <a class="el" href="vec__int64__ppc_8h.html#a208744996e7482604ad274b44999d6ce" title="Vector Multiply Odd Unsigned Doublewords. ">vec_vmuloud()</a>. We use the paste doubleword (<a class="el" href="vec__int64__ppc_8h.html#a53159a600aba803503ae6ddcb539a123" title="Vector doubleword paste. Concatenate the high doubleword of the 1st vector with the low double word o...">vec_pasted()</a>) operation in the implementation of <a class="el" href="vec__int64__ppc_8h.html#a517f21d7f771077a51f26718311ca64e" title="Vector Shift Right Algebraic Doubleword. ">vec_vsrad()</a>, <a class="el" href="vec__int64__ppc_8h.html#a84e6361054b52ac4564bcef25b718151" title="Vector Multiply Even Unsigned Doublewords. ">vec_vmuleud()</a>, and <a class="el" href="vec__int64__ppc_8h.html#a208744996e7482604ad274b44999d6ce" title="Vector Multiply Odd Unsigned Doublewords. ">vec_vmuloud()</a>. We use the swap doubleword operation in the implementation of <a class="el" href="vec__int128__ppc_8h.html#a7197cd5c6e946211f2718b5e8464cdc0" title="Vector Compare Equal Unsigned Quadword. ">vec_cmpequq()</a>, <a class="el" href="vec__int128__ppc_8h.html#a186d0b94bbc652e700ab4e1733b9524c" title="Vector Compare Not Equal Unsigned Quadword. ">vec_cmpneuq()</a>, <a class="el" href="vec__int128__ppc_8h.html#aee5c5b2998ef105b4c6f39739748ffa8" title="Vector Multiply Unsigned Double Quadword. ">vec_muludq()</a>, and <a class="el" href="vec__int128__ppc_8h.html#a9aaaf0e4c2705be1e0e8e925b09c52de" title="Vector Multiply Low Unsigned Quadword. ">vec_mulluq()</a>.</p>
<p>Then use the compilers <b>__BYTE_ORDER__ == <b>ORDER_LITTLE_ENDIAN</b></b> conditional to invert the <a class="el" href="vec__int64__ppc_8h.html#a8238ba590103ac80fb146a6a2b1aed1c" title="Vector Permute Doubleword Immediate. Combine a doubleword selected from the 1st (vra) vector with a d...">vec_permdi()</a> select control for endian sensitive merge/splat doubleword operations:</p><ul>
<li>Merge even/odd doubleword operations <a class="el" href="vec__int64__ppc_8h.html#a259fa00ad1a75612c87a0460140eef7a" title="Vector Merge Even Doubleword. Merge the even doubleword elements from two vectors into the high and l...">vec_mrged()</a> and <a class="el" href="vec__int64__ppc_8h.html#a75e55ac2c234b4062b02cf1b2ef2ba56" title="Vector Merge Odd Doubleword. Merge the odd doubleword elements from two vectors into the high and low...">vec_mrgod()</a>.</li>
<li>Merge high/low doubleword operations <a class="el" href="vec__int64__ppc_8h.html#a4cebc174283a4069f1f8bca5ddc5b518" title="Vector Merge High Doubleword. Merge the high doubleword elements from two vectors into the high and l...">vec_mrghd()</a> and <a class="el" href="vec__int64__ppc_8h.html#a100acbe58743381f32d5c068959668b7" title="Vector Merge Low Doubleword. Merge the low doubleword elements from two vectors into the high and low...">vec_mrgld()</a>.</li>
<li>Splat even/odd doubleword operation <a class="el" href="vec__int64__ppc_8h.html#a671e86d52ad53adce6a558476c7ffc0c" title="Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of ...">vec_splatd()</a>.</li>
</ul>
<h1><a class="anchor" id="int64_examples_0_1"></a>
Vector Doubleword Examples</h1>
<p>Suppose we have a requirement to convert an array of 64-bit time-interval values that need to convert to timespec format. For simplicity we will also assume that the array is nicely (Quadword) aligned and an integer multiple of 2 doublewords or 4 words.</p>
<p>The PowerISA provides a 64-bit TimeBase register that clocks at a constant 512MHz. The TimeBase can be read directly as either the full 64-bit value or as 32-bit upper and lower halves. For this example we assume are dealing with longer intervals (greater than ~8.38 seconds) so the full 64-bit TimeBase is required. TimeBase values of adjacent events are subtracted to generate the intervals stored in the array.</p>
<p>The timespec format is a struct of unsigned int fields for seconds and nanoseconds. So the task is to convert the 512MHz 64-bit TimeBase intervals to seconds and remaining clock ticks. Then convert the remaining (subsecond) clock ticks from 512MHz to nanoseconds. The separate seconds and nanoseconds are combined in the timespec structure.</p>
<p>First we need to separate the raw TimeBase into the integer seconds and (subsecond) clock-ticks. Normally scalar codes would use integer divide/modulo by 512000000. Did I mention that the PowerISA vector unit does not have a integer divide operation?</p>
<p>Instead we can use the multiplicative inverse which is a scaled fixed point fraction calculated from the original divisor. This works nicely if the fixed radix point is just before the 64-bit fraction and we have a multiply high (<a class="el" href="vec__int64__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06" title="Vector Multiply High Unsigned Doubleword. ">vec_mulhud()</a>) operation. Multiplying a 64-bit unsigned integer by a 64-bit unsigned fraction generates a 128-bit product with 64-bits above (integer) and below (fraction) the radix point. The high 64-bits of the product is the integer quotient.</p>
<p>It turns out that generating the multiplicative inverse can be tricky. To produce correct results over the full range requires, possible pre-scaling and post-shifting, and sometimes a corrective addition is necessary. Fortunately the mathematics are well understood and are commonly used in optimizing compilers. Even better, Henry Warren's book has a whole chapter on this topic. </p><dl class="section see"><dt>See also</dt><dd>"Hacker's Delight, 2nd Edition," Henry S. Warren, Jr, Addison Wesley, 2013. Chapter 10, Integer Division by Constants.</dd></dl>
<p>In the chapter above; </p><blockquote class="doxtable">
<p>Figure 10-2 Computing the magic number for unsigned division.</p>
</blockquote>
<p>provides a sample C function for generating the magic number (actually a struct containing; the magic multiplicative inverse, "add" indicator, and the shift amount.).</p>
<p>For the divisor 512000000 this is { 4835703278458516699, 0 , 27 }:</p><ul>
<li>the multiplier is 4835703278458516699.</li>
<li>no corrective add of the dividend is required.</li>
<li>the final shift is 27-bits right.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Magic numbers for multiplicative inverse to divide by 512,000,000</span></div><div class="line"><span class="comment">// are 4835703278458516699 and shift right 27 bits.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> mul_invs_clock =</div><div class="line">  { 4835703278458516699UL, 4835703278458516699UL };</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> shift_clock = 27;</div><div class="line"><span class="comment">// Need const for TB clocks/second to extract remainder.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> tb_clock_sec =</div><div class="line">  { 512000000, 512000000};</div><div class="line"><a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> tb_v, tmp, tb_clocks, seconds, nseconds;</div><div class="line"><a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> timespec1, timespec2;</div><div class="line"></div><div class="line"><span class="comment">// extract integer seconds from timebase vector.</span></div><div class="line">tmp = <a class="code" href="vec__int128__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06">vec_mulhud</a> (tb_v, mul_invs_clock);</div><div class="line">seconds = <a class="code" href="vec__int64__ppc_8h.html#a1be336316770fa12d116c7e82427d2fd">vec_srdi</a> (tmp, shift_clock);</div><div class="line"><span class="comment">// Extract the remainder in tb clock ticks.</span></div><div class="line">tmp = <a class="code" href="vec__int128__ppc_8h.html#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb">vec_muludm</a> (seconds, tb_clock_sec);</div><div class="line">tb_clocks = vec_sub (tb_v, tmp);</div></div><!-- fragment --><p>Next we need to convert the subseconds from TimeBase clock-ticks to nanoseconds. The subsecond remainder is now small enough (compared to a doubleword) that we can perform the conversion <em>in place</em>. The nanosecond conversion is ((tb_clocks * 1000000000) / 512000000). And we can reduce this to ((tb_clocks * 1000) / 512). We still have a small multiply but the divide can be converted to shift right of 9-bits. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> shift_512 = 9;</div><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> nano_512 =</div><div class="line">  { 1000, 1000};</div><div class="line"></div><div class="line"><span class="comment">// Convert 512MHz timebase to nanoseconds.</span></div><div class="line"><span class="comment">// nseconds = tb_clocks * 1000000000 / 512000000</span></div><div class="line"><span class="comment">// reduces to (tb_clocks * 1000) &gt;&gt; 9</span></div><div class="line">tmp = <a class="code" href="vec__int128__ppc_8h.html#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb">vec_muludm</a> (tb_clocks, nano_512);</div><div class="line">nseconds = <a class="code" href="vec__int64__ppc_8h.html#a1be336316770fa12d116c7e82427d2fd">vec_srdi</a> (tmp, shift_512);</div></div><!-- fragment --><p>Finally we need to merge the vectors of seconds and nanoseconds into vectors of timespec. So far we have been working with 64-bit integers but the timespec is a struct of 32-bit (word) integers. Here 32-bit seconds and nanosecond provided sufficient range and precision. So the final step <em>packs</em> a pair of 64-bit timespec values into a vector of two 32-bit timespec values, each containing 2 32-bit (second, nanosecond) values. </p><div class="fragment"><div class="line">timespec1 = vec_mergeh (seconds, nseconds);</div><div class="line">timespec2 = vec_mergel (seconds, nseconds);</div><div class="line"><span class="comment">// seconds and nanoseconds fit int 32-bits after conversion.</span></div><div class="line"><span class="comment">// So pack the results and store the timespec.</span></div><div class="line">*timespec++ = <a class="code" href="vec__int64__ppc_8h.html#a188540de9d76b546ef27e4d3fe21a57b">vec_vpkudum</a> (timespec1, timespec2);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>vec_sub(), vec_mergeh(), and vec_mergel() are existing altivec.h generic built-ins. </dd>
<dd>
<a class="el" href="vec__int64__ppc_8h.html#a188540de9d76b546ef27e4d3fe21a57b" title="Vector Pack Unsigned Doubleword Unsigned Modulo. ">vec_vpkudum()</a> is an existing altivec.h built-in that is only defined for <b>_ARCH_PWR8</b> and later. This header insures that vec_vpkudum is defined for older compilers and provides an functional equivalent implementation for POWER7.</dd></dl>
<h2><a class="anchor" id="i64_example_0_1_0"></a>
Vectorized 64-bit TimeBase conversion example</h2>
<p>Here is the complete vectorized 64-bit TimeBase to timespec conversion example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">example_dw_convert_timebase (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> *tb, <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> *timespec, <span class="keywordtype">int</span> n)</div><div class="line">{</div><div class="line">  <span class="comment">// Magic numbers for multiplicative inverse to divide by 512,000,000</span></div><div class="line">  <span class="comment">// are 4835703278458516699 and shift right 27 bits.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> mul_invs_clock =</div><div class="line">    { 4835703278458516699UL, 4835703278458516699UL };</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> shift_clock = 27;</div><div class="line">  <span class="comment">// Need const for TB clocks/second to extract remainder.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> tb_clock_sec =</div><div class="line">    { 512000000, 512000000};</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> shift_512 = 9;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> nano_512 =</div><div class="line">    { 1000, 1000};</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> tb_v, tmp, tb_clocks, seconds, nseconds;</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> timespec1, timespec2;</div><div class="line">  <span class="keywordtype">int</span> i;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)</div><div class="line">    {</div><div class="line">      tb_v = *tb++;</div><div class="line">      <span class="comment">// extract integer seconds from timebase vector.</span></div><div class="line">      tmp = <a class="code" href="vec__int128__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06">vec_mulhud</a> (tb_v, mul_invs_clock);</div><div class="line">      seconds = <a class="code" href="vec__int64__ppc_8h.html#a1be336316770fa12d116c7e82427d2fd">vec_srdi</a> (tmp, shift_clock);</div><div class="line">      <span class="comment">// Extract remainder in tb clock ticks.</span></div><div class="line">      tmp = <a class="code" href="vec__int128__ppc_8h.html#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb">vec_muludm</a> (seconds, tb_clock_sec);</div><div class="line">      tb_clocks = vec_sub (tb_v, tmp);</div><div class="line">      <span class="comment">// Convert 512MHz timebase to nanoseconds.</span></div><div class="line">      <span class="comment">// nseconds = tb_clocks * 1000000000 / 512000000</span></div><div class="line">      <span class="comment">// reduces to (tb_clocks * 1000) &gt;&gt; 9</span></div><div class="line">      tmp = <a class="code" href="vec__int128__ppc_8h.html#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb">vec_muludm</a> (tb_clocks, nano_512);</div><div class="line">      nseconds = <a class="code" href="vec__int64__ppc_8h.html#a1be336316770fa12d116c7e82427d2fd">vec_srdi</a> (tmp, shift_512);</div><div class="line">      <span class="comment">// Use merge high/low to interleave seconds and nseconds</span></div><div class="line">      <span class="comment">// into timespec.</span></div><div class="line">      timespec1 = vec_mergeh (seconds, nseconds);</div><div class="line">      timespec2 = vec_mergel (seconds, nseconds);</div><div class="line">      <span class="comment">// seconds and nanoseconds fit int 32-bits after conversion.</span></div><div class="line">      <span class="comment">// So pack the results and store the timespec.</span></div><div class="line">      *timespec++ = <a class="code" href="vec__int64__ppc_8h.html#a188540de9d76b546ef27e4d3fe21a57b">vec_vpkudum</a> (timespec1, timespec2);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="int64_perf_0_0"></a>
Performance data.</h1>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5d87e069dbfd809587083c42a2b08575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d87e069dbfd809587083c42a2b08575">&#9670;&nbsp;</a></span>vec_absdud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_absdud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Absolute Difference Unsigned Doubleword. </p>
<p>Compute the absolute difference for each doubleword. For each unsigned doubleword, subtract VRB[i] from VRA[i] and return the absolute value of the difference.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>vector of 2 x unsigned doublewords </td></tr>
    <tr><td class="paramname">vrb</td><td>vector of 2 x unsigned doublewords </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the absolute differences. </dd></dl>

</div>
</div>
<a id="a28052c1907d1f733c9dda8a48039e546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28052c1907d1f733c9dda8a48039e546">&#9670;&nbsp;</a></span>vec_addudm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_addudm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Add Unsigned Doubleword Modulo. </p>
<p>Add two vector long int values and return modulo 64-bits result.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector long int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector long int sums of a and b. </dd></dl>

</div>
</div>
<a id="a03cdec54548bd95e04d4835d96b1bea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cdec54548bd95e04d4835d96b1bea4">&#9670;&nbsp;</a></span>vec_clzd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_clzd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count leading zeros for a vector unsigned long int. </p>
<p>Count leading zeros for a vector __int128 and return the count in a vector suitable for use with vector shift (left|right) and vector shift (left|right) by octet instructions.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated a __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector with bits 121:127 containing the count of leading zeros. </dd></dl>

</div>
</div>
<a id="a77f77d3e0509c70e9facdaeda6498351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f77d3e0509c70e9facdaeda6498351">&#9670;&nbsp;</a></span>vec_cmpeqsd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_cmpeqsd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return all '1's, if a[i] == b[i], otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later, use the Vector Compare Equal Unsigned DoubleWord (<b>vcmpequd</b>) instruction. Otherwise use boolean logic using word compares.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare equal result for each element. </dd></dl>

</div>
</div>
<a id="a560aef2acfdf1db1cf14848ec6cb0c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560aef2acfdf1db1cf14848ec6cb0c1c">&#9670;&nbsp;</a></span>vec_cmpequd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_cmpequd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return all '1's, if a[i] == b[i], otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later, use the Vector Compare Equal Unsigned DoubleWord (<b>vcmpequd</b>) instruction. Otherwise use boolean logic using word compares.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare equal result for each element. </dd></dl>

</div>
</div>
<a id="aacd20f737baf4e0e7829a80e6679e38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd20f737baf4e0e7829a80e6679e38f">&#9670;&nbsp;</a></span>vec_cmpgesd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_cmpgesd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than or Equal Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return all '1's, if a[i] &gt;= b[i], otherwise all '0's. Use vec_cmpgtsd with parameters reversed to implement vec_cmpltud, then return the logical inverse.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare greater then or equal result for each element. </dd></dl>

</div>
</div>
<a id="a8c23131dbeac361dec5b8cb95d2737f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c23131dbeac361dec5b8cb95d2737f9">&#9670;&nbsp;</a></span>vec_cmpgeud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_cmpgeud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than or Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return all '1's, if a[i] &gt;= b[i], otherwise all '0's. Use vec_cmpgtud with parameters reversed to implement vec_cmpltud, then return the logical inverse.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare greater then or equal result for each element. </dd></dl>

</div>
</div>
<a id="ab17e8dea0fd54f5d88386f71e042741a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17e8dea0fd54f5d88386f71e042741a">&#9670;&nbsp;</a></span>vec_cmpgtsd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_cmpgtsd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return all '1's, if a[i] &gt; b[i], otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Compare Greater Than Unsigned DoubleWord (<b>vcmpgtsd</b>) instruction. Otherwise use boolean logic using word compares.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare greater result for each element. </dd></dl>

</div>
</div>
<a id="aeb17e3bb401eff58cf827c9fc5f281bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb17e3bb401eff58cf827c9fc5f281bf">&#9670;&nbsp;</a></span>vec_cmpgtud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_cmpgtud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Greater Than Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return all '1's, if a[i] &gt; b[i], otherwise all '0's.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Compare Greater Than Unsigned DoubleWord (<b>vcmpgtud</b>) instruction. Otherwise use boolean logic using word compares.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare greater result for each element. </dd></dl>

</div>
</div>
<a id="a59a737796be7a1cd7a1942910b8c1b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a737796be7a1cd7a1942910b8c1b09">&#9670;&nbsp;</a></span>vec_cmplesd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_cmplesd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than Equal Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return all '1's, if a[i] &gt; b[i], otherwise all '0's. Use vec_cmpgtsd with parameters reversed to implement vec_cmpltsd then return the logical inverse.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare greater result for each element. </dd></dl>

</div>
</div>
<a id="a2296a65434efd3e0d974c86b014861b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2296a65434efd3e0d974c86b014861b3">&#9670;&nbsp;</a></span>vec_cmpleud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_cmpleud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Less Than Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return all '1's, if a[i] &gt; b[i], otherwise all '0's. Use vec_cmpgtud with parameters reversed to implement vec_cmpltud. Use vec_cmpgtud then return the logical inverse.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare greater result for each element. </dd></dl>

</div>
</div>
<a id="a4fb88c77cd54bf1863dc75a0c29d575d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb88c77cd54bf1863dc75a0c29d575d">&#9670;&nbsp;</a></span>vec_cmpltsd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_cmpltsd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare less Than Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return all '1's, if a[i] &lt; b[i], otherwise all '0's. Use vec_cmpgtsd with parameters reversed to implement vec_cmpltsd.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare less result for each element. </dd></dl>

</div>
</div>
<a id="ac23cdb84882a03083962b1679b622ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23cdb84882a03083962b1679b622ea4">&#9670;&nbsp;</a></span>vec_cmpltud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_cmpltud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare less Than Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return all '1's, if a[i] &lt; b[i], otherwise all '0's. Use vec_cmpgtud with parameters reversed to implement vec_cmpltud.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare less result for each element. </dd></dl>

</div>
</div>
<a id="a3a6c76027da33eef370932fce5c541b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6c76027da33eef370932fce5c541b0">&#9670;&nbsp;</a></span>vec_cmpnesd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_cmpnesd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Not Equal Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return all '1's, if a[i] != b[i], otherwise all '0's. Use vec_cmpequd then return the logical inverse.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare not equal result for each element. </dd></dl>

</div>
</div>
<a id="a13d83929ca3ee7b493864319cd019303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d83929ca3ee7b493864319cd019303">&#9670;&nbsp;</a></span>vec_cmpneud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a> vec_cmpneud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare Not Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return all '1's, if a[i] != b[i], otherwise all '0's. Use vec_cmpequd then return the logical inverse.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with each dword boolean reflecting compare not equal result for each element. </dd></dl>

</div>
</div>
<a id="a68408e5c95633f47202d0ddf224389de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68408e5c95633f47202d0ddf224389de">&#9670;&nbsp;</a></span>vec_cmpsd_all_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsd_all_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Equal Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return true if all elements of a and b are equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a8aaf4f81689304675d749759a88d86c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aaf4f81689304675d749759a88d86c0">&#9670;&nbsp;</a></span>vec_cmpsd_all_ge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsd_all_ge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than or Equal Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return true if all elements of a &gt;= b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="a1fffe85d6f314f935fcd1fabf0ebe389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fffe85d6f314f935fcd1fabf0ebe389">&#9670;&nbsp;</a></span>vec_cmpsd_all_gt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsd_all_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return true if all elements of a &gt; b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="a73113dbb2579e1cc75ce14c7e066f049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73113dbb2579e1cc75ce14c7e066f049">&#9670;&nbsp;</a></span>vec_cmpsd_all_le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsd_all_le </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less than equal Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return true if all elements of a &lt;= b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="a9ecd14e25b4de7ce7bb657e0e2f492bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecd14e25b4de7ce7bb657e0e2f492bc">&#9670;&nbsp;</a></span>vec_cmpsd_all_lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsd_all_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less than Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return true if all elements of a &lt; b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="a87a29d79ba5ecf2c5fce676964644ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a29d79ba5ecf2c5fce676964644ca2">&#9670;&nbsp;</a></span>vec_cmpsd_all_ne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsd_all_ne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Not Equal Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return true if all elements of a and b are not equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a30f82c3268a53f2c23a353458e5bcce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f82c3268a53f2c23a353458e5bcce5">&#9670;&nbsp;</a></span>vec_cmpsd_any_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsd_any_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Equal Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return true if any elements of a and b are equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a146dc334912901502038e5b1c7a91698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146dc334912901502038e5b1c7a91698">&#9670;&nbsp;</a></span>vec_cmpsd_any_ge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsd_any_ge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Greater Than or Equal Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return true if any elements of a &gt;= b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="aaea7f8d78bbae66170fcbe2870fb5c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea7f8d78bbae66170fcbe2870fb5c0a">&#9670;&nbsp;</a></span>vec_cmpsd_any_gt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsd_any_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Greater Than Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return true if all elements of a &gt; b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="a3e3882a5d27471ac7b5375da64512795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3882a5d27471ac7b5375da64512795">&#9670;&nbsp;</a></span>vec_cmpsd_any_le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsd_any_le </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Less than equal Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return true if any elements of a &lt;= b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for any 128-bits, true if any Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="a8173aebfd8c92e3f95f54f823d5060b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8173aebfd8c92e3f95f54f823d5060b0">&#9670;&nbsp;</a></span>vec_cmpsd_any_lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsd_any_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Less than Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return true if any elements of a &lt; b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for any 128-bits, true if any Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="aaf7f0973c81ab62009df9452cb3708fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7f0973c81ab62009df9452cb3708fb">&#9670;&nbsp;</a></span>vec_cmpsd_any_ne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpsd_any_ne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Not Equal Signed Doubleword. </p>
<p>Compare each signed long (64-bit) integer and return true if any elements of a and b are not equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit signed long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for any 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a8a7660b170e71ec58ee95a79cd1c47d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7660b170e71ec58ee95a79cd1c47d5">&#9670;&nbsp;</a></span>vec_cmpud_all_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_all_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if all elements of a and b are equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a6264e6ca42126726b0e490754dde0db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6264e6ca42126726b0e490754dde0db7">&#9670;&nbsp;</a></span>vec_cmpud_all_ge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_all_ge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than or Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if all elements of a &gt;= b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="af13f19199e5872ecaf88742043f26642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13f19199e5872ecaf88742043f26642">&#9670;&nbsp;</a></span>vec_cmpud_all_gt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_all_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Greater Than Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if all elements of a &gt; b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="a871f91423e5154739ae225c82620d6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871f91423e5154739ae225c82620d6b4">&#9670;&nbsp;</a></span>vec_cmpud_all_le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_all_le </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less than equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if all elements of a &lt;= b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="a55dcb361982b9da13b02373d720d6c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55dcb361982b9da13b02373d720d6c7d">&#9670;&nbsp;</a></span>vec_cmpud_all_lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_all_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Less than Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if all elements of a &lt; b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="a156844dcaee20356c7a1f7af9981c03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156844dcaee20356c7a1f7af9981c03f">&#9670;&nbsp;</a></span>vec_cmpud_all_ne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_all_ne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare all Not Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if all elements of a and b are not equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a440a601539df9f00dfe3669b06ea5766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440a601539df9f00dfe3669b06ea5766">&#9670;&nbsp;</a></span>vec_cmpud_any_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_any_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if any elements of a and b are equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a5a5c292fdc26335cf5bb18f83d346cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5c292fdc26335cf5bb18f83d346cc2">&#9670;&nbsp;</a></span>vec_cmpud_any_ge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_any_ge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Greater Than or Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if any elements of a &gt;= b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="a77f43c88ffe8c0cad11b901fa6fc2598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f43c88ffe8c0cad11b901fa6fc2598">&#9670;&nbsp;</a></span>vec_cmpud_any_gt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_any_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Greater Than Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if all elements of a &gt; b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for all 128-bits, true if all Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="a3d6d11774a7f88bfab6507148c6e90a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6d11774a7f88bfab6507148c6e90a4">&#9670;&nbsp;</a></span>vec_cmpud_any_le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_any_le </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Less than equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if any elements of a &lt;= b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for any 128-bits, true if any Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="a370eb06be197554734a6a29a730f500d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370eb06be197554734a6a29a730f500d">&#9670;&nbsp;</a></span>vec_cmpud_any_lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_any_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Less than Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if any elements of a &lt; b.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for any 128-bits, true if any Greater Than, false otherwise. </dd></dl>

</div>
</div>
<a id="aa03d831ec09612229357e2ea34383eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03d831ec09612229357e2ea34383eaf">&#9670;&nbsp;</a></span>vec_cmpud_any_ne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_cmpud_any_ne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Compare any Not Equal Unsigned Doubleword. </p>
<p>Compare each unsigned long (64-bit) integer and return true if any elements of a and b are not equal.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 x 64-bit unsigned long integer (dword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean int for any 128-bits, true if equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a88bde04363b6d427c6e64470febe95ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bde04363b6d427c6e64470febe95ae">&#9670;&nbsp;</a></span>vec_maxsd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_maxsd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Maximum Signed Doubleword. </p>
<p>For each doubleword element [0|1] of vra and vrb compare as signed integers and return the larger value in the result.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector long int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector long maximum of a and b. </dd></dl>

</div>
</div>
<a id="afc3550c9cebe5e01bf08cee3c5f46ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3550c9cebe5e01bf08cee3c5f46ff0">&#9670;&nbsp;</a></span>vec_maxud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_maxud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Maximum Unsigned Doubleword. </p>
<p>For each doubleword element [0|1] of vra and vrb compare as unsigned integers and return the larger value in the result.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector long int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long maximum of a and b. </dd></dl>

</div>
</div>
<a id="a0de4bb38c2aba5f34836ef70bc875010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de4bb38c2aba5f34836ef70bc875010">&#9670;&nbsp;</a></span>vec_minsd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_minsd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Minimum Signed Doubleword. </p>
<p>For each doubleword element [0|1] of vra and vrb compare as signed integers and return the smaller value in the result.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector long int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector long minimum of a and b. </dd></dl>

</div>
</div>
<a id="ad24220d787ac863b7911a303da17d1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24220d787ac863b7911a303da17d1a0">&#9670;&nbsp;</a></span>vec_minud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_minud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Minimum Unsigned Doubleword. </p>
<p>For each doubleword element [0|1] of vra and vrb compare as unsigned integers and return the smaller value in the result.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned long int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsignedlong int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long minimum of a and b. </dd></dl>

</div>
</div>
<a id="acd5bafec6c1c15b0336551e82d1169d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5bafec6c1c15b0336551e82d1169d4">&#9670;&nbsp;</a></span>vec_mrgahd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mrgahd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Algebraic High Doublewords. </p>
<p>Merge only the high doublewords from 2 x Algebraic quadwords across vectors vra and vrb. This is effectively the Vector Merge Even Doubleword operation that is not modified for endian.</p>
<p>For example, merge the high 64-bits from 2 x 128-bit products as generated by vec_muleud/vec_muloud. This result is effectively a vector multiply high unsigned doubleword.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the high doublewords of the 2 x algebraic quadwords across vra and vrb. </dd></dl>

</div>
</div>
<a id="a5242d6311cd5ab50377cfeb2cf2ac8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5242d6311cd5ab50377cfeb2cf2ac8bf">&#9670;&nbsp;</a></span>vec_mrgald()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mrgald </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Algebraic Low Doublewords. </p>
<p>Merge only the low doublewords from 2 x Algebraic quadwords across vectors vra and vrb. This effectively the Vector Merge Odd doubleword operation that is not modified for endian.</p>
<p>For example, merge the low 64-bits from 2 x 128-bit products as generated by vec_muleud/vec_muloud. This result is effectively a vector multiply low unsigned doubleword.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned __int128. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the low doublewords of the 2 x algebraic quadwords across vra and vrb. </dd></dl>

</div>
</div>
<a id="a259fa00ad1a75612c87a0460140eef7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259fa00ad1a75612c87a0460140eef7a">&#9670;&nbsp;</a></span>vec_mrged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mrged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Even Doubleword. Merge the even doubleword elements from two vectors into the high and low doubleword elements of the result. This is effectively the VSX Permute Doubleword Immediate operation modified for endian. </p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__VA</td><td>a 128-bit vector as the source of the results even doubleword. </td></tr>
    <tr><td class="paramname">__VB</td><td>a 128-bit vector as the source of the results odd doubleword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the even doublewords of the 2 x quadwords across __VA and __VB. </dd></dl>

</div>
</div>
<a id="a4cebc174283a4069f1f8bca5ddc5b518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cebc174283a4069f1f8bca5ddc5b518">&#9670;&nbsp;</a></span>vec_mrghd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mrghd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge High Doubleword. Merge the high doubleword elements from two vectors into the high and low doubleword elements of the result. This is effectively the VSX Permute Doubleword Immediate operation modified for endian. </p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__VA</td><td>a 128-bit vector as the source of the results even doubleword. </td></tr>
    <tr><td class="paramname">__VB</td><td>a 128-bit vector as the source of the results odd doubleword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the high doublewords of the 2 x quadwords across __VA and __VB. </dd></dl>

</div>
</div>
<a id="a100acbe58743381f32d5c068959668b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100acbe58743381f32d5c068959668b7">&#9670;&nbsp;</a></span>vec_mrgld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mrgld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Low Doubleword. Merge the low doubleword elements from two vectors into the high and low doubleword elements of the result. This is effectively the VSX Permute Doubleword Immediate operation modified for endian. </p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__VA</td><td>a 128-bit vector as the source of the results even doubleword. </td></tr>
    <tr><td class="paramname">__VB</td><td>a 128-bit vector as the source of the results odd doubleword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the low doublewords of the 2 x quadwords across __VA and __VB. </dd></dl>

</div>
</div>
<a id="a75e55ac2c234b4062b02cf1b2ef2ba56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e55ac2c234b4062b02cf1b2ef2ba56">&#9670;&nbsp;</a></span>vec_mrgod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mrgod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Odd Doubleword. Merge the odd doubleword elements from two vectors into the high and low doubleword elements of the result. This is effectively the VSX Permute Doubleword Immediate operation modified for endian. </p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__VA</td><td>a 128-bit vector as the source of the results even doubleword. </td></tr>
    <tr><td class="paramname">__VB</td><td>a 128-bit vector as the source of the results odd doubleword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the odd doublewords of the 2 x quadwords across __VA and __VB. </dd></dl>

</div>
</div>
<a id="a1d183ebd232e5826be109cdaa421aeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d183ebd232e5826be109cdaa421aeed">&#9670;&nbsp;</a></span>vec_msumudm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_msumudm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Sum Unsigned Doubleword Modulo. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed">vec_int128_ppc::h::vec_msumudm()</a> as it requires <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>. </dd></dl>

</div>
</div>
<a id="a26f95e02f7b0551e3f2bb7e4b4da040d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f95e02f7b0551e3f2bb7e4b4da040d">&#9670;&nbsp;</a></span>vec_muleud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_muleud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Even Unsigned Doublewords. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#a26f95e02f7b0551e3f2bb7e4b4da040d">vec_int128_ppc::h::vec_muleud()</a> as it requires vec_vmuleud and <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>. </dd></dl>

</div>
</div>
<a id="a10780cd8a88f18ec564ee6254c179a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10780cd8a88f18ec564ee6254c179a06">&#9670;&nbsp;</a></span>vec_mulhud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mulhud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Unsigned Doubleword. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#a10780cd8a88f18ec564ee6254c179a06">vec_int128_ppc::h::vec_mulhud()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a84e6361054b52ac4564bcef25b718151" title="Vector Multiply Even Unsigned Doublewords. ">vec_vmuleud()</a> and <a class="el" href="vec__int64__ppc_8h.html#a208744996e7482604ad274b44999d6ce" title="Vector Multiply Odd Unsigned Doublewords. ">vec_vmuloud()</a>. </dd></dl>

</div>
</div>
<a id="aa989582cbfaa7984f78a937225e92f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa989582cbfaa7984f78a937225e92f4a">&#9670;&nbsp;</a></span>vec_muloud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_muloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Odd Unsigned Doublewords. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#aa989582cbfaa7984f78a937225e92f4a">vec_int128_ppc::h::vec_muloud()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a208744996e7482604ad274b44999d6ce" title="Vector Multiply Odd Unsigned Doublewords. ">vec_vmuloud()</a> and <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>. </dd></dl>

</div>
</div>
<a id="a2f19a53d6d28ac9b2aab5b8e1c5b2cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb">&#9670;&nbsp;</a></span>vec_muludm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_muludm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Unsigned Doubleword Modulo. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#a2f19a53d6d28ac9b2aab5b8e1c5b2cbb">vec_int128_ppc::h::vec_muludm()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a84e6361054b52ac4564bcef25b718151" title="Vector Multiply Even Unsigned Doublewords. ">vec_vmuleud()</a> and <a class="el" href="vec__int64__ppc_8h.html#a208744996e7482604ad274b44999d6ce" title="Vector Multiply Odd Unsigned Doublewords. ">vec_vmuloud()</a>. </dd></dl>

</div>
</div>
<a id="a53159a600aba803503ae6ddcb539a123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53159a600aba803503ae6ddcb539a123">&#9670;&nbsp;</a></span>vec_pasted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_pasted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>__VL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector doubleword paste. Concatenate the high doubleword of the 1st vector with the low double word of the 2nd vector. </p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__VH</td><td>a 128-bit vector as the source of the high order doubleword. </td></tr>
    <tr><td class="paramname">__VL</td><td>a 128-bit vector as the source of the low order doubleword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined 128-bit vector composed of the high order doubleword of __VH and the low order doubleword of __VL. </dd></dl>

</div>
</div>
<a id="a8238ba590103ac80fb146a6a2b1aed1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8238ba590103ac80fb146a6a2b1aed1c">&#9670;&nbsp;</a></span>vec_permdi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_permdi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ctl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Permute Doubleword Immediate. Combine a doubleword selected from the 1st (vra) vector with a doubleword selected from the 2nd (vrb) vector. </p>
<dl class="section note"><dt>Note</dt><dd>This function implements the operation of a VSX Permute Doubleword Immediate instruction. This implementation is NOT Endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<p>The 2-bit control operand (ctl) selects which doubleword from the 1st and 2nd vector operands are transfered to the result vector. Control table: </p><table class="doxtable">
<tr>
<th align="center">ctl </th><th align="center">vrt[0:63] </th><th align="center">vrt[64:127]  </th></tr>
<tr>
<td align="center">0 </td><td align="center">vra[0:63] </td><td align="center">vrb[0:63] </td></tr>
<tr>
<td align="center">1 </td><td align="center">vra[0:63] </td><td align="center">vrb[64:127] </td></tr>
<tr>
<td align="center">2 </td><td align="center">vra[64:127] </td><td align="center">vrb[0:63] </td></tr>
<tr>
<td align="center">3 </td><td align="center">vra[64:127] </td><td align="center">vrb[64:127] </td></tr>
</table>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector as the source of the high order doubleword of the result. </td></tr>
    <tr><td class="paramname">vrb</td><td>a 128-bit vector as the source of the low order doubleword of the result. </td></tr>
    <tr><td class="paramname">ctl</td><td>const integer where the low order 2 bits control the selection of doublewords from input vector vra and vrb. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined 128-bit vector composed of the high order doubleword of vra and the low order doubleword of vrb. </dd></dl>

</div>
</div>
<a id="a0db4e91aa49c03fbb4a8da5a174c7b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db4e91aa49c03fbb4a8da5a174c7b07">&#9670;&nbsp;</a></span>vec_popcntd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_popcntd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Population Count doubleword. </p>
<p>Count the number of '1' bits (0-64) within each doubleword element of a 128-bit vector.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">2/2 cycles </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Population Count DoubleWord (<b>vpopcntd</b>) instruction. Otherwise use the pveclib vec_popcntw to count each word then sum across with Vector Sum across Half Signed Word Saturate (<b>vsum2sws</b>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 2 x 64-bit integer (dwords) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the population count for each dword element. </dd></dl>

</div>
</div>
<a id="ae4af62c6235b7b47daea6f00cd8ea33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4af62c6235b7b47daea6f00cd8ea33a">&#9670;&nbsp;</a></span>vec_revbd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_revbd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>byte reverse each doubleword for a vector unsigned long int. </p>
<p>For each doubleword of the input vector, reverse the order of bytes / octets within the doubleword.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector unsigned long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector with the bytes of each doubleword reversed. </dd></dl>

</div>
</div>
<a id="ad3e4f1f514f5a0e0dc52083f3afd9113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e4f1f514f5a0e0dc52083f3afd9113">&#9670;&nbsp;</a></span>vec_rldi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_rldi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Rotate left Doubleword Immediate. </p>
<p>Rotate left each doubleword element [0-1], 0-63 bits, as specified by an immediate value. The rotate amount is a const unsigned int in the range 0-63. A rotate count of 0 returns the original value of vra. Shift counts greater then 63 bits handled modulo 64.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-4 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2-5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned long int. </td></tr>
    <tr><td class="paramname">shb</td><td>rotate amount in the range 0-63. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned long int, shifted left shb bits. </dd></dl>

</div>
</div>
<a id="a6aee7d73450e9b7008af0428030f1028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aee7d73450e9b7008af0428030f1028">&#9670;&nbsp;</a></span>vec_sldi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_sldi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift left Doubleword Immediate. </p>
<p>Shift left each doubleword element [0-1], 0-63 bits, as specified by an immediate value. The shift amount is a const unsigned long int in the range 0-63. A shift count of 0 returns the original value of vra. Shift counts greater then 63 bits return zero.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-4 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2-5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned long int. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-63. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned long int, shifted left shb bits. </dd></dl>

</div>
</div>
<a id="a671e86d52ad53adce6a558476c7ffc0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671e86d52ad53adce6a558476c7ffc0c">&#9670;&nbsp;</a></span>vec_splatd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_splatd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ctl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of the result. This is effectively the VSX Merge doubleword operation modified for endian. </p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<p>The 1-bit control operand (ctl) selects which (0:1) doubleword element, from the vector operand, is replicated to both doublewords of the result vector. Control table: </p><table class="doxtable">
<tr>
<th align="center">ctl </th><th align="center">vrt[0] </th><th align="center">vrt[1]  </th></tr>
<tr>
<td align="center">0 </td><td align="center">vra[0] </td><td align="center">vra[0] </td></tr>
<tr>
<td align="center">1 </td><td align="center">vra[1] </td><td align="center">vra[1] </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector. </td></tr>
    <tr><td class="paramname">ctl</td><td>a const integer encoding the source doubleword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original vector with the doubleword elements swapped. </dd></dl>

</div>
</div>
<a id="a9cd0665fb16981d85c7f948c0578f928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd0665fb16981d85c7f948c0578f928">&#9670;&nbsp;</a></span>vec_spltd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_spltd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ctl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of the result.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<p>The 1-bit control operand (ctl) selects which (0:1) doubleword element, from the vector operand, is replicated to both doublewords of the result vector. Control table: </p><table class="doxtable">
<tr>
<th align="center">ctl </th><th align="center">vrt[0:63] </th><th align="center">vrt[64:127]  </th></tr>
<tr>
<td align="center">0 </td><td align="center">vra[0:63] </td><td align="center">vra[0:63] </td></tr>
<tr>
<td align="center">1 </td><td align="center">vra[64:127] </td><td align="center">vra[64:127] </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector. </td></tr>
    <tr><td class="paramname">ctl</td><td>a const integer encoding the source doubleword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original vector with the doubleword elements swapped. </dd></dl>

</div>
</div>
<a id="a6058f691cf57976e30f0294a183d2715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6058f691cf57976e30f0294a183d2715">&#9670;&nbsp;</a></span>vec_sradi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_sradi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Algebraic Doubleword Immediate. </p>
<p>Shift Right Algebraic each doubleword element [0-1], 0-63 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-63. A shift count of 0 returns the original value of vra. Shift counts greater then 63 bits return the sign bit propagated to each bit of each element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-4 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2-5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector signed long int. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-63. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector signed long int, shifted right shb bits. </dd></dl>

</div>
</div>
<a id="a1be336316770fa12d116c7e82427d2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be336316770fa12d116c7e82427d2fd">&#9670;&nbsp;</a></span>vec_srdi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_srdi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Doubleword Immediate. </p>
<p>Shift Right each doubleword element [0-1], 0-63 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-63. A shift count of 0 returns the original value of vra. Shift counts greater then 63 bits return zero.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-4 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2-5 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned long int. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-63. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned long int, shifted right shb bits. </dd></dl>

</div>
</div>
<a id="a0b7aee3c81538f5537680b610d934500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7aee3c81538f5537680b610d934500">&#9670;&nbsp;</a></span>vec_subudm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_subudm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Subtract Unsigned Doubleword Modulo. </p>
<p>For each unsigned long (64-bit) integer element c[i] = a[i] + NOT(b[i]) + 1.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Subtract Unsigned Doubleword Modulo (<b>vsubudm</b>) instruction. Otherwise use vector add word modulo forms and propagate the carry bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector treated as 2 X unsigned long int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector treated as 2 X unsigned long int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long int sum of a[0] + NOT(b[0]) + 1 and a[1] + NOT(b[1]) + 1. </dd></dl>

</div>
</div>
<a id="a42d2b39711c06106097ef869a20420b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d2b39711c06106097ef869a20420b6">&#9670;&nbsp;</a></span>vec_swapd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_swapd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector doubleword swap. Exchange the high and low doubleword elements of a vector. </p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original vector with the doubleword elements swapped. </dd></dl>

</div>
</div>
<a id="a9e8daafaa42c16823750d7fe61224662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8daafaa42c16823750d7fe61224662">&#9670;&nbsp;</a></span>vec_vmadd2eud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_vmadd2eud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add2 Even Unsigned Doublewords. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#a9e8daafaa42c16823750d7fe61224662">vec_int128_ppc::h::vec_vmadd2eud()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm()</a> and <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>. </dd></dl>

</div>
</div>
<a id="a1b046a56d566ec2ea351042fd9dd11de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b046a56d566ec2ea351042fd9dd11de">&#9670;&nbsp;</a></span>vec_vmadd2euw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmadd2euw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add2 Even Unsigned Words. </p>
<p>Multiply the even 32-bit Words of vector unsigned int values (a * b) and return sums of the unsigned 64-bit product and the even 32-bit words of c and d (a<sub>even</sub> * b<sub>even</sub>) + EXTZ(c<sub>even</sub> + EXTZ(d<sub>even</sub>).</p>
<dl class="section note"><dt>Note</dt><dd>The advantage of this form (versus Multiply-Sum) is that the final 64 bit sums can not overflow. </dd>
<dd>
This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">c</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">d</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long int sum (a<sub>even</sub> * b<sub>even</sub>) + EXTZ(c<sub>even</sub>) + EXTZ(d<sub>even</sub>). </dd></dl>

</div>
</div>
<a id="af66cdabc7f2bc00f79579ce90fd483e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66cdabc7f2bc00f79579ce90fd483e0">&#9670;&nbsp;</a></span>vec_vmadd2oud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_vmadd2oud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add2 Odd Unsigned Doublewords. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#af66cdabc7f2bc00f79579ce90fd483e0">vec_int128_ppc::h::vec_vmadd2oud()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm()</a> and <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>. </dd></dl>

</div>
</div>
<a id="a40ab00ed413c1aa1a8148cd9981235bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ab00ed413c1aa1a8148cd9981235bf">&#9670;&nbsp;</a></span>vec_vmadd2ouw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmadd2ouw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add2 Odd Unsigned Words. </p>
<p>Multiply the odd 32-bit Words of vector unsigned int values (a * b) and return sums of the unsigned 64-bit product and the odd 32-bit words of c and d (a<sub>odd</sub> * b<sub>odd</sub>) + EXTZ(c<sub>odd</sub> + EXTZ(d<sub>odd</sub>).</p>
<dl class="section note"><dt>Note</dt><dd>The advantage of this form (versus Multiply-Sum) is that the final 64 bit sums can not overflow. </dd>
<dd>
This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">c</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">d</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long int sum (a<sub>odd</sub> * b<sub>odd</sub>) + EXTZ(c<sub>odd</sub> + EXTZ(d<sub>odd</sub>). </dd></dl>

</div>
</div>
<a id="a6280736f91cb67eca10b55e750bfe1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6280736f91cb67eca10b55e750bfe1de">&#9670;&nbsp;</a></span>vec_vmaddeud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_vmaddeud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add Even Unsigned Doublewords. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#a6280736f91cb67eca10b55e750bfe1de">vec_int128_ppc::h::vec_vmaddeud()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm()</a> and <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>. </dd></dl>

</div>
</div>
<a id="a1e20bdd1df7e3e49dca06d5512ada84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e20bdd1df7e3e49dca06d5512ada84b">&#9670;&nbsp;</a></span>vec_vmaddeuw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmaddeuw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add Even Unsigned Words. </p>
<p>Multiply the even 32-bit Words of vector unsigned int values (a * b) and return sums of the unsigned 64-bit product and the even 32-bit words of c (a<sub>even</sub> * b<sub>even</sub>) + EXTZ(c<sub>even</sub>).</p>
<dl class="section note"><dt>Note</dt><dd>The advantage of this form (versus Multiply-Sum) is that the final 64 bit sums can not overflow. </dd>
<dd>
This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">c</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long int sum (a<sub>even</sub> * b<sub>even</sub>) + EXTZ(c<sub>even</sub>). </dd></dl>

</div>
</div>
<a id="ae0b83d2696455fea53b1ecf434a0daf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b83d2696455fea53b1ecf434a0daf8">&#9670;&nbsp;</a></span>vec_vmaddoud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_vmaddoud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add Odd Unsigned Doublewords. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#ae0b83d2696455fea53b1ecf434a0daf8">vec_int128_ppc::h::vec_vmaddoud()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm()</a> and <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>. </dd></dl>

</div>
</div>
<a id="a32acead723b7867ff4c9f8be9bb708ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32acead723b7867ff4c9f8be9bb708ca">&#9670;&nbsp;</a></span>vec_vmaddouw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmaddouw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add Odd Unsigned Words. </p>
<p>Multiply the odd 32-bit Words of vector unsigned int values (a * b) and return sums of the unsigned 64-bit product and the odd 32-bit words of c (a<sub>odd</sub> * b<sub>odd</sub>) + EXTZ(c<sub>odd</sub>).</p>
<dl class="section note"><dt>Note</dt><dd>The advantage of this form (versus Multiply-Sum) is that the final 64 bit sums can not overflow. </dd>
<dd>
This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">c</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long int sum (a<sub>odd</sub> * b<sub>odd</sub>) + EXTZ(c<sub>odd</sub>). </dd></dl>

</div>
</div>
<a id="a43f6f199cdf39641d940f5b8d55dbf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f6f199cdf39641d940f5b8d55dbf6b">&#9670;&nbsp;</a></span>vec_vmsumeud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_vmsumeud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Sum Even Unsigned Doublewords. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#a43f6f199cdf39641d940f5b8d55dbf6b">vec_int128_ppc::h::vec_vmsumeud()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm()</a> and <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>. </dd></dl>

</div>
</div>
<a id="a04385860c7a03a9aa57f4a31017caf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04385860c7a03a9aa57f4a31017caf81">&#9670;&nbsp;</a></span>vec_vmsumoud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_vmsumoud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Sum Odd Unsigned Doublewords. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#a04385860c7a03a9aa57f4a31017caf81">vec_int128_ppc::h::vec_vmsumoud()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm()</a> and <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>. </dd></dl>

</div>
</div>
<a id="a431720fd713485fcb13963cdcb89ac76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431720fd713485fcb13963cdcb89ac76">&#9670;&nbsp;</a></span>vec_vmsumuwm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmsumuwm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Sum Unsigned Word Modulo. </p>
<p>Multiply the unsigned word elements of vra and vrb, internally generating doubleword products. Then generate three-way sum of adjacent doubleword product pairs, plus the doubleword elements from vrc. The final summation is modulo 64-bits.</p>
<dl class="section note"><dt>Note</dt><dd>This function implements the operation of a Vector Multiply-Sum Unsigned Word Modulo instruction, if the PowerISA included such an instruction. This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">11 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">11 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrc</td><td>128-bit vector unsigned long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of doubleword elements where each is the sum of the even and odd adjacent products of the vra and vrb, plus the corresponding doubleword element of vrc. </dd></dl>

</div>
</div>
<a id="a84e6361054b52ac4564bcef25b718151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e6361054b52ac4564bcef25b718151">&#9670;&nbsp;</a></span>vec_vmuleud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_vmuleud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Even Unsigned Doublewords. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#a84e6361054b52ac4564bcef25b718151">vec_int128_ppc::h::vec_vmuleud()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm()</a> and <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>. </dd></dl>

</div>
</div>
<a id="a208744996e7482604ad274b44999d6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208744996e7482604ad274b44999d6ce">&#9670;&nbsp;</a></span>vec_vmuloud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_vmuloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Odd Unsigned Doublewords. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int128__ppc_8h.html#a208744996e7482604ad274b44999d6ce">vec_int128_ppc::h::vec_vmuloud()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a1d183ebd232e5826be109cdaa421aeed" title="Vector Multiply-Sum Unsigned Doubleword Modulo. ">vec_msumudm()</a> and <a class="el" href="vec__int128__ppc_8h.html#a539de2a4426a84102471306acc571ce8" title="Vector Add Unsigned Quadword Modulo. ">vec_adduqm()</a>. </dd></dl>

</div>
</div>
<a id="a188540de9d76b546ef27e4d3fe21a57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188540de9d76b546ef27e4d3fe21a57b">&#9670;&nbsp;</a></span>vec_vpkudum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_vpkudum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Pack Unsigned Doubleword Unsigned Modulo. </p>
<p>The doubleword source is the concatination of vra and vrb. For each integer word from 0 to 3, of the result vector, do the following: place the contents of bits 32:63 of the corresponding doubleword source element [i] into word element [i] of the result.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Use vec_vpkudum naming but only if the compiler does not define it in &lt;altivec.h&gt;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as 2 x unsigned long integers. </td></tr>
    <tr><td class="paramname">vrb</td><td>a 128-bit vector treated as 2 x unsigned long integers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector treated as 4 x unsigned integers. </dd></dl>

</div>
</div>
<a id="ad8406367635fbd8f1c50a11f6d650a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8406367635fbd8f1c50a11f6d650a2a">&#9670;&nbsp;</a></span>vec_vrld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vrld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Rotate Left Doubleword. </p>
<p>Vector Rotate Left Doubleword 0-63 bits. The shift amount is from bits 58-63 and 122-127 of vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Use vec_vrld naming but only if the compiler does not define it in &lt;altivec.h&gt;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as 2 x unsigned long integers. </td></tr>
    <tr><td class="paramname">vrb</td><td>shift amount in bits 58:63 and 122:127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Left shifted vector unsigned long. </dd></dl>

</div>
</div>
<a id="a0fb3ddc8b334ae25119a02e749884290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb3ddc8b334ae25119a02e749884290">&#9670;&nbsp;</a></span>vec_vsld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vsld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Left Doubleword. </p>
<p>Vector Shift Left Doubleword 0-63 bits. The shift amount is from bits 58-63 and 122-127 of vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Can not use vec_sld naming here as that would conflict with the generic Shift Left Double Vector. Use vec_vsld but only if the compiler does not define it in &lt;altivec.h&gt;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as 2 x unsigned long integers. </td></tr>
    <tr><td class="paramname">vrb</td><td>shift amount in bits 58:63 and 122:127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Left shifted vector unsigned long. </dd></dl>

</div>
</div>
<a id="a517f21d7f771077a51f26718311ca64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517f21d7f771077a51f26718311ca64e">&#9670;&nbsp;</a></span>vec_vsrad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_vsrad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Algebraic Doubleword. </p>
<p>Vector Shift Right Algebraic Doubleword 0-63 bits. The shift amount is from bits 58-63 and 122-127 of vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Use the vec_vsrad for consistency with vec_vsld above. Define vec_vsrad only if the compiler does not define it in &lt;altivec.h&gt;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as 2 x unsigned long integers. </td></tr>
    <tr><td class="paramname">vrb</td><td>shift amount in bits 58:63 and 122:127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Right shifted vector unsigned long. </dd></dl>

</div>
</div>
<a id="a89e352b9d7cc7cdb597a14ddb0933387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e352b9d7cc7cdb597a14ddb0933387">&#9670;&nbsp;</a></span>vec_vsrd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vsrd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Doubleword. </p>
<p>Vector Shift Right Doubleword 0-63 bits. The shift amount is from bits 58-63 and 122-127 of vrb.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Use the vec_vsrd for consistency with vec_vsld above. Define vec_vsrd only if the compiler does not define it in &lt;altivec.h&gt;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as 2 x unsigned long integers. </td></tr>
    <tr><td class="paramname">vrb</td><td>shift amount in bits 58:63 and 122:127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Right shifted vector unsigned long. </dd></dl>

</div>
</div>
<a id="af55ccf9e8b50b5b1198e4cc226000282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55ccf9e8b50b5b1198e4cc226000282">&#9670;&nbsp;</a></span>vec_xxspltd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xxspltd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ctl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector splat doubleword. Duplicate the selected doubleword element across the doubleword elements of the result. </p>
<dl class="section note"><dt>Note</dt><dd>This function implements the operation of a VSX Splat Doubleword Immediate instruction. This implementation is NOT Endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<p>The 1-bit control operand (ctl) selects which (0:1) doubleword element, from the vector operand, is replicated to both doublewords of the result vector. Control table: </p><table class="doxtable">
<tr>
<th align="center">ctl </th><th align="center">vrt[0:63] </th><th align="center">vrt[64:127]  </th></tr>
<tr>
<td align="center">0 </td><td align="center">vra[0:63] </td><td align="center">vra[0:63] </td></tr>
<tr>
<td align="center">1 </td><td align="center">vra[64:127] </td><td align="center">vra[64:127] </td></tr>
</table>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector. </td></tr>
    <tr><td class="paramname">ctl</td><td>a const integer encoding the source doubleword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original vector with the doubleword elements swapped. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 17 2020 17:13:19 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
