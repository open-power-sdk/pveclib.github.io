<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>POWER Vector Library Manual: src/pveclib/vec_char_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3653a864936a87c29f489ec2a5b8be1c.html">pveclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_char_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over 8-bit integer (char) elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__common__ppc_8h_source.html">pveclib/vec_common_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__char__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3eca950eb052ce1b0ad7a8d20ce3f971"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a3eca950eb052ce1b0ad7a8d20ce3f971">vec_absdub</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vrb)</td></tr>
<tr class="memdesc:a3eca950eb052ce1b0ad7a8d20ce3f971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Absolute Difference Unsigned byte.  <a href="#a3eca950eb052ce1b0ad7a8d20ce3f971">More...</a><br /></td></tr>
<tr class="separator:a3eca950eb052ce1b0ad7a8d20ce3f971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29190093e687e416c846b885eb2c10c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a29190093e687e416c846b885eb2c10c6">vec_clzb</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vra)</td></tr>
<tr class="memdesc:a29190093e687e416c846b885eb2c10c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count leading zeros for a vector unsigned char (byte) elements.  <a href="#a29190093e687e416c846b885eb2c10c6">More...</a><br /></td></tr>
<tr class="separator:a29190093e687e416c846b885eb2c10c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04af2798abe4f5e568e8fd527bef3b02"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a04af2798abe4f5e568e8fd527bef3b02">vec_isalnum</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_str)</td></tr>
<tr class="memdesc:a04af2798abe4f5e568e8fd527bef3b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector isalpha.  <a href="#a04af2798abe4f5e568e8fd527bef3b02">More...</a><br /></td></tr>
<tr class="separator:a04af2798abe4f5e568e8fd527bef3b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ea0723c4ae1ce1b4137a25eae1a15e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#ab6ea0723c4ae1ce1b4137a25eae1a15e">vec_isalpha</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_str)</td></tr>
<tr class="memdesc:ab6ea0723c4ae1ce1b4137a25eae1a15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector isalnum.  <a href="#ab6ea0723c4ae1ce1b4137a25eae1a15e">More...</a><br /></td></tr>
<tr class="separator:ab6ea0723c4ae1ce1b4137a25eae1a15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0152053aed21f65166488df7e6b6c2a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a0152053aed21f65166488df7e6b6c2a9">vec_isdigit</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_str)</td></tr>
<tr class="memdesc:a0152053aed21f65166488df7e6b6c2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector isdigit.  <a href="#a0152053aed21f65166488df7e6b6c2a9">More...</a><br /></td></tr>
<tr class="separator:a0152053aed21f65166488df7e6b6c2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ec8f3ed5b75f1e1b21998484d878e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#ab2ec8f3ed5b75f1e1b21998484d878e8">vec_mrgahb</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</td></tr>
<tr class="memdesc:ab2ec8f3ed5b75f1e1b21998484d878e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Algebraic High Byte operation.  <a href="#ab2ec8f3ed5b75f1e1b21998484d878e8">More...</a><br /></td></tr>
<tr class="separator:ab2ec8f3ed5b75f1e1b21998484d878e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07f90ac64ed898a5add48932b8ac010"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#af07f90ac64ed898a5add48932b8ac010">vec_mrgalb</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</td></tr>
<tr class="memdesc:af07f90ac64ed898a5add48932b8ac010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Algebraic Low Byte operation.  <a href="#af07f90ac64ed898a5add48932b8ac010">More...</a><br /></td></tr>
<tr class="separator:af07f90ac64ed898a5add48932b8ac010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a776401631aedafdaf371e268fcfe7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#ab8a776401631aedafdaf371e268fcfe7">vec_mrgeb</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vrb)</td></tr>
<tr class="memdesc:ab8a776401631aedafdaf371e268fcfe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Even Bytes operation.  <a href="#ab8a776401631aedafdaf371e268fcfe7">More...</a><br /></td></tr>
<tr class="separator:ab8a776401631aedafdaf371e268fcfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562bddfc070386aabced80167b4571af"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a562bddfc070386aabced80167b4571af">vec_mrgob</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vrb)</td></tr>
<tr class="memdesc:a562bddfc070386aabced80167b4571af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Odd Halfwords operation.  <a href="#a562bddfc070386aabced80167b4571af">More...</a><br /></td></tr>
<tr class="separator:a562bddfc070386aabced80167b4571af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b81ae683c42ead33d58b422ee8f85cb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a748bbf6563e6ab1ddcb694c86e2aaef4">vi8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a5b81ae683c42ead33d58b422ee8f85cb">vec_mulhsb</a> (<a class="el" href="vec__common__ppc_8h.html#a748bbf6563e6ab1ddcb694c86e2aaef4">vi8_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a748bbf6563e6ab1ddcb694c86e2aaef4">vi8_t</a> vrb)</td></tr>
<tr class="memdesc:a5b81ae683c42ead33d58b422ee8f85cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Signed Bytes.  <a href="#a5b81ae683c42ead33d58b422ee8f85cb">More...</a><br /></td></tr>
<tr class="separator:a5b81ae683c42ead33d58b422ee8f85cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a67dcc2623020b065eb244bc54511c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a81a67dcc2623020b065eb244bc54511c">vec_mulhub</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vrb)</td></tr>
<tr class="memdesc:a81a67dcc2623020b065eb244bc54511c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Unsigned Bytes.  <a href="#a81a67dcc2623020b065eb244bc54511c">More...</a><br /></td></tr>
<tr class="separator:a81a67dcc2623020b065eb244bc54511c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425151e5a82ee9e204ffd81b1ec7a92c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a425151e5a82ee9e204ffd81b1ec7a92c">vec_mulubm</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vrb)</td></tr>
<tr class="memdesc:a425151e5a82ee9e204ffd81b1ec7a92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Unsigned Byte Modulo.  <a href="#a425151e5a82ee9e204ffd81b1ec7a92c">More...</a><br /></td></tr>
<tr class="separator:a425151e5a82ee9e204ffd81b1ec7a92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c33360f34cc31ca2e381bf2e7c9ce6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#ae0c33360f34cc31ca2e381bf2e7c9ce6">vec_popcntb</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vra)</td></tr>
<tr class="memdesc:ae0c33360f34cc31ca2e381bf2e7c9ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Population Count byte.  <a href="#ae0c33360f34cc31ca2e381bf2e7c9ce6">More...</a><br /></td></tr>
<tr class="separator:ae0c33360f34cc31ca2e381bf2e7c9ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095741b255775d4ccf6228a5655599a2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a095741b255775d4ccf6228a5655599a2">vec_slbi</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a095741b255775d4ccf6228a5655599a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift left Byte Immediate.  <a href="#a095741b255775d4ccf6228a5655599a2">More...</a><br /></td></tr>
<tr class="separator:a095741b255775d4ccf6228a5655599a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253a59f286f91817dfac89459ccbeac6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a748bbf6563e6ab1ddcb694c86e2aaef4">vi8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a253a59f286f91817dfac89459ccbeac6">vec_srabi</a> (<a class="el" href="vec__common__ppc_8h.html#a748bbf6563e6ab1ddcb694c86e2aaef4">vi8_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a253a59f286f91817dfac89459ccbeac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Algebraic Byte Immediate.  <a href="#a253a59f286f91817dfac89459ccbeac6">More...</a><br /></td></tr>
<tr class="separator:a253a59f286f91817dfac89459ccbeac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495109a7d46f4a97b56f22bb315ac567"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a495109a7d46f4a97b56f22bb315ac567">vec_srbi</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a495109a7d46f4a97b56f22bb315ac567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Byte Immediate.  <a href="#a495109a7d46f4a97b56f22bb315ac567">More...</a><br /></td></tr>
<tr class="separator:a495109a7d46f4a97b56f22bb315ac567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949a5b375e69a85e76a06e68831cb59a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a949a5b375e69a85e76a06e68831cb59a">vec_shift_leftdo</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vrw, <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vrx, <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vrb)</td></tr>
<tr class="memdesc:a949a5b375e69a85e76a06e68831cb59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift left double quadword by octet. Return a vector unsigned char that is the left most 16 chars after shifting left 0-15 octets (chars) of the 32 char double vector (vrw||vrx). The octet shift amount is from bits 121:124 of vrb.  <a href="#a949a5b375e69a85e76a06e68831cb59a">More...</a><br /></td></tr>
<tr class="separator:a949a5b375e69a85e76a06e68831cb59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d585f1bb4fc5efab4df98594cdb46c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a86d585f1bb4fc5efab4df98594cdb46c">vec_toupper</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_str)</td></tr>
<tr class="memdesc:a86d585f1bb4fc5efab4df98594cdb46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector toupper.  <a href="#a86d585f1bb4fc5efab4df98594cdb46c">More...</a><br /></td></tr>
<tr class="separator:a86d585f1bb4fc5efab4df98594cdb46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73501120e1af14864b7621e318645426"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a73501120e1af14864b7621e318645426">vec_tolower</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_str)</td></tr>
<tr class="memdesc:a73501120e1af14864b7621e318645426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector tolower.  <a href="#a73501120e1af14864b7621e318645426">More...</a><br /></td></tr>
<tr class="separator:a73501120e1af14864b7621e318645426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c23ce0e18ad18d46d27f80c40f465e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a86c23ce0e18ad18d46d27f80c40f465e">vec_vmrgeb</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vrb)</td></tr>
<tr class="memdesc:a86c23ce0e18ad18d46d27f80c40f465e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Even Bytes.  <a href="#a86c23ce0e18ad18d46d27f80c40f465e">More...</a><br /></td></tr>
<tr class="separator:a86c23ce0e18ad18d46d27f80c40f465e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122434ec49f77cf6968e2cb9523e68d2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__char__ppc_8h.html#a122434ec49f77cf6968e2cb9523e68d2">vec_vmrgob</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vrb)</td></tr>
<tr class="memdesc:a122434ec49f77cf6968e2cb9523e68d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Odd Byte.  <a href="#a122434ec49f77cf6968e2cb9523e68d2">More...</a><br /></td></tr>
<tr class="separator:a122434ec49f77cf6968e2cb9523e68d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over 8-bit integer (char) elements. </p>
<p>Most of these operations are implemented in a single VMX or VSX instruction on newer (POWER6/POWER7/POWER8/POWER9) processors. This header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides in-line assembler implementations for older compilers that do not provide the build-ins.</p>
<p>Most vector char (8-bit integer) operations are are already covered by the original VMX (AKA Altivec) instructions. VMX intrinsic (compiler built-ins) operations are defined in &lt;altivec.h&gt; and described in the compiler documentation. PowerISA 2.07B (POWER8) added several useful byte operations (count leading zeros, population count) not included in the original VMX. PowerISA 3.0B (POWER9) adds several more (absolute difference, compare not equal, count trailing zeros, extend sign, extract/insert, and reverse bytes). Most of these intrinsic (compiler built-ins) operations are defined in &lt;altivec.h&gt; and described in the compiler documentation.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power7</b>, vec_vclz and vec_vclzb will not be defined. But vec_clzb is always defined in this header, will generate the minimum code, appropriate for the target, and produce correct results.</dd></dl>
<p>This header covers operations that are either:</p>
<ul>
<li>Implemented in later processors and useful to programmers if the same operations are available on slightly older processors. This is required even if the operation is defined in the OpenPOWER ABI or &lt;altivec.h&gt;, as the compiler disables the associated built-ins if the <b>mcpu</b> target does not enable the instruction.</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.n&gt; provided by available compilers in common use. Examples include Count Leading Zeros and Population Count.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious. Examples include the multiply high, ASCII character tests, and shift immediate operations.</li>
</ul>
<h1><a class="anchor" id="i8_endian_issues_0_0"></a>
Endian problems with byte operations</h1>
<p>It would be useful to provide a vector multiply high byte (return the high order 8-bits of the 16-bit product) operation. This can be used for multiplicative inverse (effectively integer divide) operations. Neither integer multiply high nor divide are available as vector instructions. However the multiply high byte operation can be composed from the existing multiply even/odd byte operations followed by the vector merge even byte operation. Similarly a multiply low (modulo) byte operation can be composed from the existing multiply even/odd byte operations followed by the vector merge odd byte operation.</p>
<p>As a prerequisite we need to provide the merge even/odd byte operations. While PowerISA has added these operations for word and doubleword, instructions are not defined for byte and halfword. Fortunately vector merge operations are just a special case of vector permute. So the <a class="el" href="vec__char__ppc_8h.html#a122434ec49f77cf6968e2cb9523e68d2" title="Vector Merge Odd Byte. ">vec_vmrgob()</a> and <a class="el" href="vec__char__ppc_8h.html#a86c23ce0e18ad18d46d27f80c40f465e" title="Vector Merge Even Bytes. ">vec_vmrgeb()</a> implementation can use vec_perm and appropriate selection vectors to provide these merge operations.</p>
<p>As described for other element sizes this is complicated by <em>little-endian</em> (LE) support as specified in the OpenPOWER ABI and as implemented in the compilers. Little-endian changes the effective vector element numbering and the location of even and odd elements. This means that the vector built-ins provided by altivec.h may not generate the instructions you would expect. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="vec__int16__ppc_8h.html#i16_endian_issues_0_0">Endian problems with halfword operations</a> </dd>
<dd>
<a class="el" href="index.html#mainpage_endian_issues_1_1">General Endian Issues</a></dd></dl>
<p>So this header defines endian independent byte operations <a class="el" href="vec__char__ppc_8h.html#a86c23ce0e18ad18d46d27f80c40f465e" title="Vector Merge Even Bytes. ">vec_vmrgeb()</a> and <a class="el" href="vec__char__ppc_8h.html#a122434ec49f77cf6968e2cb9523e68d2" title="Vector Merge Odd Byte. ">vec_vmrgob()</a>. These operations are used in the implementation of the endian sensitive <a class="el" href="vec__char__ppc_8h.html#ab8a776401631aedafdaf371e268fcfe7" title="Vector Merge Even Bytes operation. ">vec_mrgeb()</a> and <a class="el" href="vec__char__ppc_8h.html#a562bddfc070386aabced80167b4571af" title="Vector Merge Odd Halfwords operation. ">vec_mrgob()</a>. These support the OpenPOWER ABI mandated merge even/odd semantic.</p>
<p>We also provide the merge algebraic high/low operations <a class="el" href="vec__char__ppc_8h.html#ab2ec8f3ed5b75f1e1b21998484d878e8" title="Vector Merge Algebraic High Byte operation. ">vec_mrgahb()</a> and <a class="el" href="vec__char__ppc_8h.html#af07f90ac64ed898a5add48932b8ac010" title="Vector Merge Algebraic Low Byte operation. ">vec_mrgalb()</a> to simplify extended precision arithmetic. These implementations use <a class="el" href="vec__char__ppc_8h.html#a86c23ce0e18ad18d46d27f80c40f465e" title="Vector Merge Even Bytes. ">vec_vmrgeb()</a> and <a class="el" href="vec__char__ppc_8h.html#a122434ec49f77cf6968e2cb9523e68d2" title="Vector Merge Odd Byte. ">vec_vmrgob()</a> as extended precision byte order does not change with endian. These operations are used in turn to implement multiply byte high/low/modulo (<a class="el" href="vec__char__ppc_8h.html#a5b81ae683c42ead33d58b422ee8f85cb" title="Vector Multiply High Signed Bytes. ">vec_mulhsb()</a>, <a class="el" href="vec__char__ppc_8h.html#a81a67dcc2623020b065eb244bc54511c" title="Vector Multiply High Unsigned Bytes. ">vec_mulhub()</a>, <a class="el" href="vec__char__ppc_8h.html#a425151e5a82ee9e204ffd81b1ec7a92c" title="Vector Multiply Unsigned Byte Modulo. ">vec_mulubm()</a>).</p>
<p>These operations provide a basis for using the multiplicative inverse as a alternative to integer divide. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="vec__int16__ppc_8h.html#int16_examples_0_1">Examples, Divide by integer constant</a></dd></dl>
<h1><a class="anchor" id="int8_perf_0_0"></a>
Performance data.</h1>
<p>The performance characteristics of the merge and multiply byte operations are very similar to the halfword implementations. (see <a class="el" href="vec__int16__ppc_8h.html#int16_perf_0_0">Performance data.</a>).</p>
<h2><a class="anchor" id="int8_perf_0_1"></a>
More information.</h2>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3eca950eb052ce1b0ad7a8d20ce3f971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eca950eb052ce1b0ad7a8d20ce3f971">&#9670;&nbsp;</a></span>vec_absdub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_absdub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Absolute Difference Unsigned byte. </p>
<p>Compute the absolute difference for each byte. For each unsigned byte, subtract B[i] from A[i] and return the absolute value of the difference.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>vector of 16 unsigned bytes </td></tr>
    <tr><td class="paramname">vrb</td><td>vector of 16 unsigned bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the absolute difference. </dd></dl>

</div>
</div>
<a id="a29190093e687e416c846b885eb2c10c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29190093e687e416c846b885eb2c10c6">&#9670;&nbsp;</a></span>vec_clzb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_clzb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count leading zeros for a vector unsigned char (byte) elements. </p>
<p>Count the number of leading '0' bits (0-7) within each byte element of a 128-bit vector.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Count Leading Zeros byte instruction <b>vclzb</b>. Otherwise use sequence of pre 2.07 VMX instructions. SIMDized count leading zeros inspired by:</p>
<p>Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 5 Counting Bits, Figure 5-12.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 16 x 8-bit integer (byte) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the Leading Zeros count for each byte element. </dd></dl>

</div>
</div>
<a id="a04af2798abe4f5e568e8fd527bef3b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04af2798abe4f5e568e8fd527bef3b02">&#9670;&nbsp;</a></span>vec_isalnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_isalnum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vec_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector isalpha. </p>
<p>Return a vector boolean char with a true indicator for any character that is either Lower Case Alpha ASCII or Upper Case ASCII. False otherwise.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-20 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">11-21 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec_str</td><td>vector of 16 ASCII characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector bool char of the isalpha operation applied to each character of vec_str. For each byte 0xff indicates true (isalpha), 0x00 indicates false. </dd></dl>

</div>
</div>
<a id="ab6ea0723c4ae1ce1b4137a25eae1a15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ea0723c4ae1ce1b4137a25eae1a15e">&#9670;&nbsp;</a></span>vec_isalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_isalpha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vec_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector isalnum. </p>
<p>Return a vector boolean char with a true indicator for any character that is either Lower Case Alpha ASCII, Upper Case ASCII, or numeric ASCII. False otherwise.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9-18 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">10-19 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec_str</td><td>vector of 16 ASCII characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector bool char of the isalnum operation applied to each character of vec_str. For each byte 0xff indicates true (isalpha), 0x00 indicates false. </dd></dl>

</div>
</div>
<a id="a0152053aed21f65166488df7e6b6c2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0152053aed21f65166488df7e6b6c2a9">&#9670;&nbsp;</a></span>vec_isdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_isdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vec_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector isdigit. </p>
<p>Return a vector boolean char with a true indicator for any character that is ASCII decimal digit. False otherwise.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-13 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec_str</td><td>vector of 16 ASCII characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector bool char of the isdigit operation applied to each character of vec_str. For each byte 0xff indicates true (isdigit), 0x00 indicates false. </dd></dl>

</div>
</div>
<a id="ab2ec8f3ed5b75f1e1b21998484d878e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ec8f3ed5b75f1e1b21998484d878e8">&#9670;&nbsp;</a></span>vec_mrgahb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_mrgahb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Algebraic High Byte operation. </p>
<p>Merge only the high byte from 16 x Algebraic halfwords across vectors vra and vrb. This is effectively the Vector Merge Even Byte operation that is not modified for Endian.</p>
<p>For example merge the high 8-bits from each of 16 x 16-bit products as generated by vec_muleub/vec_muloub. This result is effectively a vector multiply high unsigned byte.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned short. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned short. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the high bytes of the 16 x Algebraic halfwords across vra and vrb. </dd></dl>

</div>
</div>
<a id="af07f90ac64ed898a5add48932b8ac010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07f90ac64ed898a5add48932b8ac010">&#9670;&nbsp;</a></span>vec_mrgalb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_mrgalb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Algebraic Low Byte operation. </p>
<p>Merge only the low bytes from 16 x Algebraic halfwords across vectors vra and vrb. This is effectively the Vector Merge Odd Bytes operation that is not modified for Endian.</p>
<p>For example merge the low 8-bits from each of 16 x 16-bit products as generated by vec_muleub/vec_muloub. This result is effectively a vector multiply low unsigned byte.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the high halfwords of the 8 x Algebraic words across vra and vrb. </dd></dl>

</div>
</div>
<a id="ab8a776401631aedafdaf371e268fcfe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a776401631aedafdaf371e268fcfe7">&#9670;&nbsp;</a></span>vec_mrgeb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_mrgeb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Even Bytes operation. </p>
<p>Merge the even byte elements from the concatenation of 2 x vectors (vra and vrb).</p>
<dl class="section note"><dt>Note</dt><dd>The element numbering changes between Big and Little Endian. So the compiler and this implementation adjusts the generated code to reflect this.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned char. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the even bytes of vra and vrb. </dd></dl>

</div>
</div>
<a id="a562bddfc070386aabced80167b4571af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562bddfc070386aabced80167b4571af">&#9670;&nbsp;</a></span>vec_mrgob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_mrgob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Odd Halfwords operation. </p>
<p>Merge the odd halfword elements from the concatenation of 2 x vectors (vra and vrb).</p>
<dl class="section note"><dt>Note</dt><dd>The element numbering changes between Big and Little Endian. So the compiler and this implementation adjusts the generated code to reflect this.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned char. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the odd bytes of vra and vrb. </dd></dl>

</div>
</div>
<a id="a5b81ae683c42ead33d58b422ee8f85cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b81ae683c42ead33d58b422ee8f85cb">&#9670;&nbsp;</a></span>vec_mulhsb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a748bbf6563e6ab1ddcb694c86e2aaef4">vi8_t</a> vec_mulhsb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a748bbf6563e6ab1ddcb694c86e2aaef4">vi8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a748bbf6563e6ab1ddcb694c86e2aaef4">vi8_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Signed Bytes. </p>
<p>Multiple the corresponding byte elements of two vector signed char values and return the high order 8-bits, for each 16-bit product element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9-13 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">10-14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector signed char. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector signed char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the high order 8-bits of the product of the byte elements from vra and vrb. </dd></dl>

</div>
</div>
<a id="a81a67dcc2623020b065eb244bc54511c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a67dcc2623020b065eb244bc54511c">&#9670;&nbsp;</a></span>vec_mulhub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_mulhub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Unsigned Bytes. </p>
<p>Multiple the corresponding byte elements of two vector unsigned char values and return the high order 8-bits, for each 16-bit product element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9-13 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">10-14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned char. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the high order 8-bits of the product of the byte elements from vra and vrb. </dd></dl>

</div>
</div>
<a id="a425151e5a82ee9e204ffd81b1ec7a92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425151e5a82ee9e204ffd81b1ec7a92c">&#9670;&nbsp;</a></span>vec_mulubm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_mulubm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Unsigned Byte Modulo. </p>
<p>Multiple the corresponding byte elements of two vector unsigned char values and return the low order 8-bits of the 16-bit product for each element.</p>
<dl class="section note"><dt>Note</dt><dd>vec_mulubm can be used for unsigned or signed char integers. It is the vector equivalent of Multiply Low Byte.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9-13 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">10-14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned char. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the low order 8-bits of the unsigned product of the byte elements from vra and vrb. </dd></dl>

</div>
</div>
<a id="ae0c33360f34cc31ca2e381bf2e7c9ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c33360f34cc31ca2e381bf2e7c9ce6">&#9670;&nbsp;</a></span>vec_popcntb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_popcntb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Population Count byte. </p>
<p>Count the number of '1' bits (0-8) within each byte element of a 128-bit vector.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Population Count Byte instruction. Otherwise use simple Vector (VMX) instructions to count bits in bytes in parallel. SIMDized population count inspired by:</p>
<p>Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 5 Counting Bits, Figure 5-2.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 16 x 8-bit integers (byte) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the population count for each byte element. </dd></dl>

</div>
</div>
<a id="a949a5b375e69a85e76a06e68831cb59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949a5b375e69a85e76a06e68831cb59a">&#9670;&nbsp;</a></span>vec_shift_leftdo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_shift_leftdo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vrw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vrx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift left double quadword by octet. Return a vector unsigned char that is the left most 16 chars after shifting left 0-15 octets (chars) of the 32 char double vector (vrw||vrx). The octet shift amount is from bits 121:124 of vrb. </p>
<p>This sequence can be used to align a unaligned 16 char substring based on the result of a vector count leading zero of of the compare boolean.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-8 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">8-9 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vrw</td><td>upper 16-bytes of the 32-byte double vector. </td></tr>
    <tr><td class="paramname">vrx</td><td>lower 16-bytes of the 32-byte double vector. </td></tr>
    <tr><td class="paramname">vrb</td><td>Shift amount in bits 121:124. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upper 16-bytes of left shifted double vector. </dd></dl>

</div>
</div>
<a id="a095741b255775d4ccf6228a5655599a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095741b255775d4ccf6228a5655599a2">&#9670;&nbsp;</a></span>vec_slbi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_slbi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift left Byte Immediate. </p>
<p>Shift left each byte element [0-15], 0-7 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-7. A shift count of 0 returns the original value of vra. Shift counts greater then 7 bits return zero.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-11 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned char. </td></tr>
    <tr><td class="paramname">shb</td><td>Shift amount in the range 0-7. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned char, shifted left shb bits. </dd></dl>

</div>
</div>
<a id="a253a59f286f91817dfac89459ccbeac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253a59f286f91817dfac89459ccbeac6">&#9670;&nbsp;</a></span>vec_srabi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a748bbf6563e6ab1ddcb694c86e2aaef4">vi8_t</a> vec_srabi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a748bbf6563e6ab1ddcb694c86e2aaef4">vi8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Algebraic Byte Immediate. </p>
<p>Shift right each byte element [0-15], 0-7 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-7. A shift count of 0 returns the original value of vra. Shift counts greater then 7 bits return the sign bit propagated to each bit of each element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-11 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector signed char. </td></tr>
    <tr><td class="paramname">shb</td><td>Shift amount in the range 0-7. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector signed char, shifted right shb bits. </dd></dl>

</div>
</div>
<a id="a495109a7d46f4a97b56f22bb315ac567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495109a7d46f4a97b56f22bb315ac567">&#9670;&nbsp;</a></span>vec_srbi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_srbi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Byte Immediate. </p>
<p>Shift right each byte element [0-15], 0-7 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-7. A shift count of 0 returns the original value of vra. Shift counts greater then 7 bits return zero.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-11 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned char. </td></tr>
    <tr><td class="paramname">shb</td><td>Shift amount in the range 0-7. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned char, shifted right shb bits. </dd></dl>

</div>
</div>
<a id="a73501120e1af14864b7621e318645426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73501120e1af14864b7621e318645426">&#9670;&nbsp;</a></span>vec_tolower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_tolower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vec_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector tolower. </p>
<p>Convert any Upper Case Alpha ASCII characters within a vector unsigned char into the equivalent Lower Case character. Return the result as a vector unsigned char.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-17 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9-18 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec_str</td><td>vector of 16 ASCII characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector char converted to lower case. </dd></dl>

</div>
</div>
<a id="a86d585f1bb4fc5efab4df98594cdb46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d585f1bb4fc5efab4df98594cdb46c">&#9670;&nbsp;</a></span>vec_toupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_toupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vec_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector toupper. </p>
<p>Convert any Lower Case Alpha ASCII characters within a vector unsigned char into the equivalent Upper Case character. Return the result as a vector unsigned char.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-17 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9-18 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec_str</td><td>vector of 16 ASCII characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector char converted to upper case. </dd></dl>

</div>
</div>
<a id="a86c23ce0e18ad18d46d27f80c40f465e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c23ce0e18ad18d46d27f80c40f465e">&#9670;&nbsp;</a></span>vec_vmrgeb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_vmrgeb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Even Bytes. </p>
<p>Merge the even byte elements from the concatenation of 2 x vectors (vra and vrb).</p>
<dl class="section note"><dt>Note</dt><dd>This function implements the operation of a Vector Merge Even Bytes instruction, if the PowerISA included such an instruction. This implementation is NOT Endian sensitive and the function is stable across BE/LE implementations. Using Big Endian element numbering:<ul>
<li>res[0] = vra[0];</li>
<li>res[1] = vrb[0];</li>
<li>res[2] = vra[2];</li>
<li>res[3] = vrb[2];</li>
<li>res[4] = vra[4];</li>
<li>res[5] = vrb[4];</li>
<li>res[6] = vra[6];</li>
<li>res[7] = vrb[6];</li>
<li>res[8] = vra[8];</li>
<li>res[9] = vrb[8];</li>
<li>res[10] = vra[10];</li>
<li>res[11] = vrb[10];</li>
<li>res[12] = vra[12];</li>
<li>res[13] = vrb[12];</li>
<li>res[14] = vra[14];</li>
<li>res[15] = vrb[14];</li>
</ul>
</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned char. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the even bytes of vra and vrb. </dd></dl>

</div>
</div>
<a id="a122434ec49f77cf6968e2cb9523e68d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122434ec49f77cf6968e2cb9523e68d2">&#9670;&nbsp;</a></span>vec_vmrgob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_vmrgob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Odd Byte. </p>
<p>Merge the odd byte elements from the concatenation of 2 x vectors (vra and vrb).</p>
<dl class="section note"><dt>Note</dt><dd>This function implements the operation of a Vector Merge Odd Bytes instruction, if the PowerISA included such an instruction. This implementation is NOT Endian sensitive and the function is stable across BE/LE implementations. Using Big Endian element numbering:<ul>
<li>res[0] = vra[1];</li>
<li>res[1] = vrb[1];</li>
<li>res[2] = vra[3];</li>
<li>res[3] = vrb[3];</li>
<li>res[4] = vra[5];</li>
<li>res[5] = vrb[5];</li>
<li>res[6] = vra[7];</li>
<li>res[7] = vrb[7];</li>
<li>res[8] = vra[9];</li>
<li>res[9] = vrb[9];</li>
<li>res[10] = vra[11];</li>
<li>res[11] = vrb[11];</li>
<li>res[12] = vra[13];</li>
<li>res[13] = vrb[13];</li>
<li>res[14] = vra[15];</li>
<li>res[15] = vrb[15];</li>
</ul>
</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned char. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the odd bytes of vra and vrb. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 17 2020 17:13:18 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
