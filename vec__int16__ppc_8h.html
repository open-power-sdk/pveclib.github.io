<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>POWER Vector Library Manual: src/pveclib/vec_int16_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3653a864936a87c29f489ec2a5b8be1c.html">pveclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_int16_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over 16-bit integer elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__char__ppc_8h_source.html">pveclib/vec_char_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__int16__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af876e907b6f1bf6868033be2127d4238"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#af876e907b6f1bf6868033be2127d4238">vec_absduh</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</td></tr>
<tr class="memdesc:af876e907b6f1bf6868033be2127d4238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Absolute Difference Unsigned halfword.  <a href="#af876e907b6f1bf6868033be2127d4238">More...</a><br /></td></tr>
<tr class="separator:af876e907b6f1bf6868033be2127d4238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dbe03259aae45b330f18a7c9a62c81"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#ad4dbe03259aae45b330f18a7c9a62c81">vec_clzh</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra)</td></tr>
<tr class="memdesc:ad4dbe03259aae45b330f18a7c9a62c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count Leading Zeros for a vector unsigned short (halfword) elements.  <a href="#ad4dbe03259aae45b330f18a7c9a62c81">More...</a><br /></td></tr>
<tr class="separator:ad4dbe03259aae45b330f18a7c9a62c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa4e2cd07718acb38ed3530930103e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#a1fa4e2cd07718acb38ed3530930103e0">vec_mrgahh</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:a1fa4e2cd07718acb38ed3530930103e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Algebraic High Halfword operation.  <a href="#a1fa4e2cd07718acb38ed3530930103e0">More...</a><br /></td></tr>
<tr class="separator:a1fa4e2cd07718acb38ed3530930103e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152cc7dff6dd572711432962a211a97e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#a152cc7dff6dd572711432962a211a97e">vec_mrgalh</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:a152cc7dff6dd572711432962a211a97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Algebraic Low Halfword operation.  <a href="#a152cc7dff6dd572711432962a211a97e">More...</a><br /></td></tr>
<tr class="separator:a152cc7dff6dd572711432962a211a97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd1ea4bcf0c44883d806d42feb50db2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#a8fd1ea4bcf0c44883d806d42feb50db2">vec_mrgeh</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</td></tr>
<tr class="memdesc:a8fd1ea4bcf0c44883d806d42feb50db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Even Halfwords operation.  <a href="#a8fd1ea4bcf0c44883d806d42feb50db2">More...</a><br /></td></tr>
<tr class="separator:a8fd1ea4bcf0c44883d806d42feb50db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f08727b429f9159f6f189bd49be5617"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#a2f08727b429f9159f6f189bd49be5617">vec_mrgoh</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</td></tr>
<tr class="memdesc:a2f08727b429f9159f6f189bd49be5617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Odd Halfwords operation.  <a href="#a2f08727b429f9159f6f189bd49be5617">More...</a><br /></td></tr>
<tr class="separator:a2f08727b429f9159f6f189bd49be5617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5392538865fa36128b9a2475541022"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a873846dd078cef3d766814d856760526">vi16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#a2e5392538865fa36128b9a2475541022">vec_mulhsh</a> (<a class="el" href="vec__common__ppc_8h.html#a873846dd078cef3d766814d856760526">vi16_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a873846dd078cef3d766814d856760526">vi16_t</a> vrb)</td></tr>
<tr class="memdesc:a2e5392538865fa36128b9a2475541022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Signed halfword.  <a href="#a2e5392538865fa36128b9a2475541022">More...</a><br /></td></tr>
<tr class="separator:a2e5392538865fa36128b9a2475541022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f778868c7a8a71b9e901042f24f1c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#af8f778868c7a8a71b9e901042f24f1c2">vec_mulhuh</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</td></tr>
<tr class="memdesc:af8f778868c7a8a71b9e901042f24f1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Unsigned halfword.  <a href="#af8f778868c7a8a71b9e901042f24f1c2">More...</a><br /></td></tr>
<tr class="separator:af8f778868c7a8a71b9e901042f24f1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abceaf3207f8b6fbb27a3e88409f8357b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#abceaf3207f8b6fbb27a3e88409f8357b">vec_muluhm</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</td></tr>
<tr class="memdesc:abceaf3207f8b6fbb27a3e88409f8357b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Unsigned halfword Modulo.  <a href="#abceaf3207f8b6fbb27a3e88409f8357b">More...</a><br /></td></tr>
<tr class="separator:abceaf3207f8b6fbb27a3e88409f8357b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffb24b16a416d733b09a53830cd3713"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#a4ffb24b16a416d733b09a53830cd3713">vec_popcnth</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra)</td></tr>
<tr class="memdesc:a4ffb24b16a416d733b09a53830cd3713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Population Count halfword.  <a href="#a4ffb24b16a416d733b09a53830cd3713">More...</a><br /></td></tr>
<tr class="separator:a4ffb24b16a416d733b09a53830cd3713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235df54b24f644e6cc23018bdfa4e37e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#a235df54b24f644e6cc23018bdfa4e37e">vec_revbh</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra)</td></tr>
<tr class="memdesc:a235df54b24f644e6cc23018bdfa4e37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte reverse each halfword of a vector unsigned short.  <a href="#a235df54b24f644e6cc23018bdfa4e37e">More...</a><br /></td></tr>
<tr class="separator:a235df54b24f644e6cc23018bdfa4e37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc5f291cc0e6a99700760df89f5070b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#a4fc5f291cc0e6a99700760df89f5070b">vec_slhi</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a4fc5f291cc0e6a99700760df89f5070b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift left Halfword Immediate.  <a href="#a4fc5f291cc0e6a99700760df89f5070b">More...</a><br /></td></tr>
<tr class="separator:a4fc5f291cc0e6a99700760df89f5070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292973c417034f4b8813765b63ca03c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#a292973c417034f4b8813765b63ca03c2">vec_srhi</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a292973c417034f4b8813765b63ca03c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Halfword Immediate.  <a href="#a292973c417034f4b8813765b63ca03c2">More...</a><br /></td></tr>
<tr class="separator:a292973c417034f4b8813765b63ca03c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b21dd9f53dd97d3c1f58881f38b5af"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a873846dd078cef3d766814d856760526">vi16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#ac9b21dd9f53dd97d3c1f58881f38b5af">vec_srahi</a> (<a class="el" href="vec__common__ppc_8h.html#a873846dd078cef3d766814d856760526">vi16_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:ac9b21dd9f53dd97d3c1f58881f38b5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Algebraic Halfword Immediate.  <a href="#ac9b21dd9f53dd97d3c1f58881f38b5af">More...</a><br /></td></tr>
<tr class="separator:ac9b21dd9f53dd97d3c1f58881f38b5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b8c37da453c373690760370a8ceb39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#ac0b8c37da453c373690760370a8ceb39">vec_vmaddeuh</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> a, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> b, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> c)</td></tr>
<tr class="memdesc:ac0b8c37da453c373690760370a8ceb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add Even Unsigned Halfwords.  <a href="#ac0b8c37da453c373690760370a8ceb39">More...</a><br /></td></tr>
<tr class="separator:ac0b8c37da453c373690760370a8ceb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ddf6a0d591ec6836d1a2b349d16d4d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#aa0ddf6a0d591ec6836d1a2b349d16d4d">vec_vmaddouh</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> a, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> b, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> c)</td></tr>
<tr class="memdesc:aa0ddf6a0d591ec6836d1a2b349d16d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add Odd Unsigned Halfwords.  <a href="#aa0ddf6a0d591ec6836d1a2b349d16d4d">More...</a><br /></td></tr>
<tr class="separator:aa0ddf6a0d591ec6836d1a2b349d16d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf6f4a95093b3e9ae78c8600e8d9d40"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#aabf6f4a95093b3e9ae78c8600e8d9d40">vec_vmrgeh</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</td></tr>
<tr class="memdesc:aabf6f4a95093b3e9ae78c8600e8d9d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Even Halfwords.  <a href="#aabf6f4a95093b3e9ae78c8600e8d9d40">More...</a><br /></td></tr>
<tr class="separator:aabf6f4a95093b3e9ae78c8600e8d9d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525c4f6be5284ec528f3df527b07727a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int16__ppc_8h.html#a525c4f6be5284ec528f3df527b07727a">vec_vmrgoh</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</td></tr>
<tr class="memdesc:a525c4f6be5284ec528f3df527b07727a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Odd Halfwords.  <a href="#a525c4f6be5284ec528f3df527b07727a">More...</a><br /></td></tr>
<tr class="separator:a525c4f6be5284ec528f3df527b07727a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over 16-bit integer elements. </p>
<p>Most of these operations are implemented in a single instruction on newer (POWER6/POWER7POWER8/POWER9) processors. This header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides a in-line assembler implementation for older compilers that do not provide the build-ins.</p>
<p>Most vector short (16-bit integer halfword) operations are implemented with PowerISA VMX instructions either defined by the original VMX (AKA Altivec) or added to later versions of the PowerISA. PowerISA 2.07B (POWER8) added several useful halfword operations (count leading zeros, population count) not included in the original VMX. PowerISA 3.0B (POWER9) adds several more (absolute difference, compare not equal, count trailing zeros, extend sign, extract/insert, and reverse bytes). Most of these intrinsic (compiler built-ins) operations are defined in &lt;altivec.h&gt; and described in the compiler documentation.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power7</b>, vec_vclz and vec_vclzh will not be defined. Another example if you compile with <b>-mcpu=power8</b>, vec_revb will not be defined. But vec_vclzh and vec_revbh is always defined in this header. This header provides the appropriate substitutions, will generate the minimum code, appropriate for the target, and produce correct results.</dd>
<dd>
Most ppc64le compilers will default to -mcpu=power8 if not specified.</dd></dl>
<p>This header covers operations that are either:</p>
<ul>
<li>Implemented in hardware instructions for later processors and useful to programmers, on slightly older processors, even if the equivalent function requires more instructions. Examples include Count Leading Zeros, Population Count and Byte Reverse.</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.h&gt; provided by available compilers in common use. Examples include Count Leading Zeros, Population Count and Byte Reverse.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious. Examples include the multiply-add, multiply-high and shift immediate operations.</li>
</ul>
<h1><a class="anchor" id="i16_recent_additions"></a>
Recent Additions</h1>
<p>Added <a class="el" href="vec__int16__ppc_8h.html#ac0b8c37da453c373690760370a8ceb39" title="Vector Multiply-Add Even Unsigned Halfwords. ">vec_vmaddeuh()</a> and <a class="el" href="vec__int16__ppc_8h.html#aa0ddf6a0d591ec6836d1a2b349d16d4d" title="Vector Multiply-Add Odd Unsigned Halfwords. ">vec_vmaddouh()</a> as an optimization for the vector multiply quadword implementations on POWER7.</p>
<h1><a class="anchor" id="i16_endian_issues_0_0"></a>
Endian problems with halfword operations</h1>
<p>It would be useful to provide a vector multiply high halfword (return the high order 16-bits of the 32-bit product) operation. This can be used for multiplicative inverse (effectively integer divide) operations. Neither integer multiply high nor divide are available as vector instructions. However the multiply high halfword operation can be composed from the existing multiply even/odd halfword operations followed by the vector merge even halfword operation. Similarly a multiply low (modulo) halfword operation can be composed from the existing multiply even/odd halfword operations followed by the vector merge odd halfword operation.</p>
<p>As a prerequisite we need to provide the merge even/odd halfword operations. While PowerISA has added these operations for word and doubleword, instructions are nor defined for byte and halfword. Fortunately vector merge operations are just a special case of vector permute. So the <a class="el" href="vec__int16__ppc_8h.html#a525c4f6be5284ec528f3df527b07727a" title="Vector Merge Odd Halfwords. ">vec_vmrgoh()</a> and <a class="el" href="vec__int16__ppc_8h.html#aabf6f4a95093b3e9ae78c8600e8d9d40" title="Vector Merge Even Halfwords. ">vec_vmrgeh()</a> implementation can use vec_perm and appropriate selection vectors to provide these merge operations.</p>
<p>But this is complicated by <em>little-endian</em> (LE) support as specified in the OpenPOWER ABI and as implemented in the compilers. Little-endian changes the effective vector element numbering and the location of even and odd elements. This means that the vector built-ins provided by altivec.h may not generate the instructions you would expect. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#mainpage_endian_issues_1_1">General Endian Issues</a> </dd>
<dd>
<a class="el" href="vec__int32__ppc_8h.html#i32_endian_issues_0_0">Endian problems with word operations</a></dd></dl>
<p>The OpenPOWER ABI provides a helpful table of <a href="http://openpowerfoundation.org/wp-content/uploads/resources/leabi/content/dbdoclet.50655244_90667.html">Endian Sensitive Operations</a>. For for vec_mule (vmuleuh, vmulesh): </p><blockquote class="doxtable">
<p>Replace with vmulouh and so on, for LE.</p>
</blockquote>
<p>For for vec_mulo (vmulouh, vmulosh): </p><blockquote class="doxtable">
<p>Replace with vmuleuh and so on, for LE.</p>
</blockquote>
<p>Also for vec_perm (vperm) it specifies: </p><blockquote class="doxtable">
<p>For LE, Swap input arguments and complement the selection vector.</p>
</blockquote>
<p>The above is just a sampling of a larger list of Endian Sensitive Operations.</p>
<p>The obvious coding for Vector Multiply High Halfword would be: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></div><div class="line">test_mulhw (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> vec_mergee ((<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>)vec_mule (vra, vrb),</div><div class="line">                     (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>)vec_mulo (vra, vrb));</div><div class="line">}</div></div><!-- fragment --><p> A couple problems with this:</p><ul>
<li>vec_mergee is only defined for vector int/long and float/double (word/doubleword) types.</li>
<li>vec_mergee is endian sensitive and would produce the wrong results in LE mode.</li>
<li>vec_mule/vec_mulo are endian sensitive and produce the wrong results in LE mode.</li>
</ul>
<p>The first step is to implement Vector Merge Even Halfword operation: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></div><div class="line"><a class="code" href="vec__int16__ppc_8h.html#aabf6f4a95093b3e9ae78c8600e8d9d40">vec_vmrgeh</a> (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</div><div class="line">{</div><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> permute =</div><div class="line">      { 0x0302,0x1312, 0x0706,0x1716, 0x0B0A,0x1B1A, 0x0F0E,0x1F1E };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> vec_perm (vrb, vra, (<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>)permute);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> permute =</div><div class="line">      { 0x0001,0x1011, 0x0405,0x1415, 0x0809,0x1819, 0x0C0D,0x1C1D};</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> vec_perm (vra, vrb, (<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>)permute);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">}</span></div></div><!-- fragment --><p> For big-endian we have a straight forward vec_perm with a permute select vector interleaving even halfwords from vectors vra and vrb.</p>
<p>For little-endian we need to nullify the LE transform applied by the compiler. So the select vector looks like it interleaves odd halfwords from vectors vrb and vra. It also reverses byte numbering within halfwords. The compiler transforms this back into the operation we wanted in the first place. The result is <em>not</em> endian sensitive and is stable across BE/LE implementations. Similarly for the Vector Merge Odd Halfword operation.</p>
<p>As good OpenPOWER ABI citizens we should also provide endian sensitive operations <a class="el" href="vec__int16__ppc_8h.html#a8fd1ea4bcf0c44883d806d42feb50db2" title="Vector Merge Even Halfwords operation. ">vec_mrgeh()</a> <a class="el" href="vec__int16__ppc_8h.html#a2f08727b429f9159f6f189bd49be5617" title="Vector Merge Odd Halfwords operation. ">vec_mrgoh()</a>. For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></div><div class="line"><a class="code" href="vec__int16__ppc_8h.html#a8fd1ea4bcf0c44883d806d42feb50db2">vec_mrgeh</a>  (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</div><div class="line">{</div><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int16__ppc_8h.html#a525c4f6be5284ec528f3df527b07727a">vec_vmrgoh</a> ((<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>) vrb, (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>) vra);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int16__ppc_8h.html#aabf6f4a95093b3e9ae78c8600e8d9d40">vec_vmrgeh</a> ((<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>) vra, (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>) vrb);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">}</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>This is essentially what the compiler would do for vec_mergee.</dd></dl>
<p>Also to follow that pattern established for <a class="el" href="vec__int32__ppc_8h.html" title="Header package containing a collection of 128-bit SIMD operations over 32-bit integer elements...">vec_int32_ppc.h</a> we should provide implementations for Vector Merge Algebraic High/Low Halfword. For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></div><div class="line"><a class="code" href="vec__int16__ppc_8h.html#a1fa4e2cd07718acb38ed3530930103e0">vec_mrgahh</a>  (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int16__ppc_8h.html#aabf6f4a95093b3e9ae78c8600e8d9d40">vec_vmrgeh</a> ((<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>) vra, (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>) vrb);</div><div class="line">}</div></div><!-- fragment --><p> This is simpler as we can use the endian invariant <a class="el" href="vec__int16__ppc_8h.html#aabf6f4a95093b3e9ae78c8600e8d9d40" title="Vector Merge Even Halfwords. ">vec_vmrgeh()</a> operation. Similarly for Vector Merge Algebraic Low Halfword using <a class="el" href="vec__int16__ppc_8h.html#a525c4f6be5284ec528f3df527b07727a" title="Vector Merge Odd Halfwords. ">vec_vmrgoh()</a>. </p><dl class="section note"><dt>Note</dt><dd>The inputs are defined as 32-bit to match the results from multiply even/odd halfword.</dd></dl>
<p>Now we have all the parts we need to implement multiply high/low halfword. For example Multiply High Unsigned Halfword: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></div><div class="line"><a class="code" href="vec__int16__ppc_8h.html#af8f778868c7a8a71b9e901042f24f1c2">vec_mulhuh</a> (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</div><div class="line">{</div><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int16__ppc_8h.html#a1fa4e2cd07718acb38ed3530930103e0">vec_mrgahh</a> (vec_mulo (vra, vrb), vec_mule (vra, vrb));</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int16__ppc_8h.html#a1fa4e2cd07718acb38ed3530930103e0">vec_mrgahh</a> (vec_mule (vra, vrb), vec_mulo (vra, vrb));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">}</span></div></div><!-- fragment --><p>Similarly for Multiply High Signed Halfword. </p><dl class="section note"><dt>Note</dt><dd>For LE we need to nullify the compiler transform by reversing of the order of vec_mulo/vec_mule. This is required to get the algebraically correct (multiply high) result.</dd></dl>
<p>Finally we can implement the Multiply Low Halfword which by PowerISA conventions is called Multiply Unsigned Halfword Modulo: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></div><div class="line"><a class="code" href="vec__int16__ppc_8h.html#abceaf3207f8b6fbb27a3e88409f8357b">vec_muluhm</a> (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vrb)</div><div class="line">{</div><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int16__ppc_8h.html#a152cc7dff6dd572711432962a211a97e">vec_mrgalh</a> (vec_mulo (vra, vrb), vec_mule (vra, vrb));</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int16__ppc_8h.html#a152cc7dff6dd572711432962a211a97e">vec_mrgalh</a> (vec_mule (vra, vrb), vec_mulo (vra, vrb));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">}</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>We use the endian stable <a class="el" href="vec__int16__ppc_8h.html#a152cc7dff6dd572711432962a211a97e" title="Vector Merge Algebraic Low Halfword operation. ">vec_mrgalh()</a> for multiply low. Again for LE we have to nullify the compiler transform by reversing of the order of vec_mulo/vec_mule. This is required to get the algebraically correct (multiply high) result. </dd>
<dd>
<a class="el" href="vec__int16__ppc_8h.html#abceaf3207f8b6fbb27a3e88409f8357b" title="Vector Multiply Unsigned halfword Modulo. ">vec_muluhm()</a> works for signed and unsigned multiply low (modulo).</dd></dl>
<h2><a class="anchor" id="i16_endian_issues_0_1"></a>
Multiply High Unsigned Halfword Example</h2>
<p>So what does the compiler generate after unwinding three levels of inline functions. For this test case: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></div><div class="line">__test_mulhuh (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> a, <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> b)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int16__ppc_8h.html#af8f778868c7a8a71b9e901042f24f1c2">vec_mulhuh</a> (a, b);</div><div class="line">}</div></div><!-- fragment --><p> The GCC 8 compiler targeting powerpc64le and -mcpu=power8 generates: </p><div class="fragment"><div class="line">addis   r9,r2,.rodata.cst16@ha</div><div class="line">vmulouh v1,v2,v3</div><div class="line">vmuleuh v2,v2,v3</div><div class="line">addi    r9,r9,.rodata.cst16@l</div><div class="line">lvx     v0,0,r9</div><div class="line">xxlnor  vs32,vs32,vs32</div><div class="line">vperm   v2,v2,v1,v0</div></div><!-- fragment --><p> The addis, addi, lvx instruction sequence loads the permute selection constant vector. The xxlnor instruction complements the selection vector for LE. These instructions are only needed once per function and can be hoisted out of loops and shared across instances of <a class="el" href="vec__int16__ppc_8h.html#af8f778868c7a8a71b9e901042f24f1c2" title="Vector Multiply High Unsigned halfword. ">vec_mulhuh()</a>. Which might look like this: </p><div class="fragment"><div class="line">      addis   r9,r2,.rodata.cst16@ha</div><div class="line">      addi    r9,r9,.rodata.cst16@l</div><div class="line">      lvx     v0,0,r9</div><div class="line">      xxlnor  vs32,vs32,vs32</div><div class="line">      ...</div><div class="line">Loop:</div><div class="line">      vmulouh v1,v2,v3</div><div class="line">      vmuleuh v2,v2,v3</div><div class="line">      vperm   v2,v2,v1,v0</div><div class="line">      ...</div></div><!-- fragment --><p> The vmulouh, vmuleuh, vperm instruction sequence is the core of the function. They multiply the elements and selects/merges the high order 16-bits of each product into the result vector.</p>
<h1><a class="anchor" id="int16_examples_0_1"></a>
Examples, Divide by integer constant</h1>
<p>Suppose we have a requirement to convert an array of 16-bit unsigned short values to decimal. The classic <em>itoa</em> implementation performs a sequence of divide / modulo by 10 operations that produce one (decimal) value per iteration, until the divide returns 0.</p>
<p>For this example we want to vectorize the operation and the PowerISA (and most other platforms) does not provide a vector integer divide instruction. But we do have vector integer multiply. As we will see the multiply high defined above is very handy for applying the multiplicative inverse. Also, the conversion divide is a constant value applied across the vector which simplifies the coding.</p>
<p>Here we can use the multiplicative inverse which is a scaled fixed point fraction calculated from the original divisor. This works nicely if the fixed radix point is just before the 16-bit fraction and we have a multiply high (<a class="el" href="vec__int16__ppc_8h.html#af8f778868c7a8a71b9e901042f24f1c2" title="Vector Multiply High Unsigned halfword. ">vec_mulhuh()</a>) operation. Multiplying a 16-bit unsigned integer by a 16-bit unsigned fraction generates a 32-bit product with 16-bits above (integer) and below (fraction) the radix point. The high 16-bits of the product is a good approximation of the integer quotient.</p>
<p>It turns out that generating the multiplicative inverse can be tricky. To produce correct results over the full range, requires possible pre-scaling and post-shifting, and sometimes a corrective addition. Fortunately, the mathematics are well understood and are commonly used in optimizing compilers. Even better, Henry Warren's book has a whole chapter on this topic. </p><dl class="section see"><dt>See also</dt><dd>"Hacker's Delight, 2nd Edition," Henry S. Warren, Jr, Addison Wesley, 2013. Chapter 10, Integer Division by Constants.</dd></dl>
<h2><a class="anchor" id="int16_examples_0_1_1"></a>
Divide by constant 10 examples</h2>
<p>In the chapter above; </p><blockquote class="doxtable">
<p>Figure 10-2 Computing the magic number for unsigned division.</p>
</blockquote>
<p>provides a sample C function for generating the magic number (actually a struct containing; the magic multiplicative inverse, "add" indicator, and the shift amount). For the 16-bit unsigned divisor 10, this is { 52429, 0, 3 }:</p><ul>
<li>the multiplier is 52429.</li>
<li>no corrective add of the dividend is required.</li>
<li>the final shift is 3-bits right.</li>
</ul>
<p>Which could look like this: </p><div class="fragment"><div class="line"> <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></div><div class="line">__test_div10 (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> n)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> q;</div><div class="line">  <span class="comment">// M= 52429, a=0, s=3</span></div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> magic = vec_splats ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>) 52429);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> s = 3;</div><div class="line"></div><div class="line">  q = <a class="code" href="vec__int16__ppc_8h.html#af8f778868c7a8a71b9e901042f24f1c2">vec_mulhuh</a> (magic, n);</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int16__ppc_8h.html#a292973c417034f4b8813765b63ca03c2">vec_srhi</a> (q, s);</div><div class="line">}</div></div><!-- fragment --><p>But we also need the modulo to extract each digit. The simplest and oldest technique is to multiply the quotient by the divisor (constant 10) and subtract that from the original dividend. Here we can use the <a class="el" href="vec__int16__ppc_8h.html#abceaf3207f8b6fbb27a3e88409f8357b" title="Vector Multiply Unsigned halfword Modulo. ">vec_muluhm()</a> operation we defined above. Which could look like this: </p><div class="fragment"><div class="line"> <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></div><div class="line">__test_mod10 (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> n)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> q;</div><div class="line">  <span class="comment">// M= 52429, a=0, s=3</span></div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> magic = vec_splats ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>) 52429);</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> c_10 = vec_splats ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>) 10);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> s = 3;</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> tmp, rem, q_10;</div><div class="line"></div><div class="line">  q = <a class="code" href="vec__int16__ppc_8h.html#af8f778868c7a8a71b9e901042f24f1c2">vec_mulhuh</a> (magic, n);</div><div class="line">  q_10 = <a class="code" href="vec__int16__ppc_8h.html#a292973c417034f4b8813765b63ca03c2">vec_srhi</a> (q, s);</div><div class="line">  tmp = <a class="code" href="vec__int16__ppc_8h.html#abceaf3207f8b6fbb27a3e88409f8357b">vec_muluhm</a> (q_10, c_10);</div><div class="line">  rem = vec_sub (n, tmp);</div><div class="line">  <span class="keywordflow">return</span> rem;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>vec_sub() and vec_splats() are an existing altivec.h generic built-ins.</dd></dl>
<h2><a class="anchor" id="int16_examples_0_1_2"></a>
Divide by constant 10000 example</h2>
<p>As we mentioned above, some divisors require an add before the shift as a correction. For the 16-bit unsigned divisor 10000 this is { 41839, 1, 14 }:</p><ul>
<li>the multiplier is 41839.</li>
<li>corrective add of the dividend is required.</li>
<li>the final shift is 14-bits right.</li>
</ul>
<p>In this case the perfect multiplier is too large (&gt;= 2**16). So the magic multiplier is reduced by 2**16 and to correct for this we need to add the dividend to the product. This add may generate a carry that must be included in the shift. Here vec_avg handles the 17-bit sum internally before shifting right 1. But vec_avg adds an extra +1 (for rounding) that we don't want. So we use (n-1) for the product correction then complete the operation with shift right (s-1). Which could look like this: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></div><div class="line">__test_div10000 (<a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> n)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> result, q;</div><div class="line">  <span class="comment">// M= 41839, a=1, s=14</span></div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> magic = vec_splats ((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>) 41839);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> s = 14;</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> tmp, rem;</div><div class="line"></div><div class="line">  q = <a class="code" href="vec__int16__ppc_8h.html#af8f778868c7a8a71b9e901042f24f1c2">vec_mulhuh</a> (magic, n);</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_ones = vec_splat_u16 ( 1 );</div><div class="line">      <a class="code" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> n_1 = vec_sub (n, vec_ones);</div><div class="line">      <span class="comment">// avg = (q + (n-1) + 1) &gt;&gt; 1</span></div><div class="line">      q = vec_avg (q, n_1);</div><div class="line">      result = <a class="code" href="vec__int16__ppc_8h.html#a292973c417034f4b8813765b63ca03c2">vec_srhi</a> (q, (s - 1));</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>vec_avg(), vec_sub(), vec_splats() and vec_splat_u16() are existing altivec.h generic built-ins.</dd></dl>
<p>The modulo computation remains the same as <a class="el" href="vec__int16__ppc_8h.html#int16_examples_0_1_1">Divide by constant 10 examples</a>.</p>
<h1><a class="anchor" id="int16_perf_0_0"></a>
Performance data.</h1>
<p>We can use the example above (see <a class="el" href="vec__int16__ppc_8h.html#i16_endian_issues_0_1">Multiply High Unsigned Halfword Example</a>) to illustrate the performance metrics pveclib provides. For <a class="el" href="vec__int16__ppc_8h.html#af8f778868c7a8a71b9e901042f24f1c2" title="Vector Multiply High Unsigned halfword. ">vec_mulhuh()</a> the core operation is the sequence vmulouh/vmuleuh/vperm. This represents the best case latency, when it is used multiple times in a single larger function.</p>
<p>The compiler notes that vmulouh/vmuleuh are independent instructions that can execute concurrently (in separate vector pipelines). The compiler schedules them to issue in same cycle. The latency for vmulouh/vmuleuh is listed as 7 cycle and the throughput of 2 per cycle (there are 2 vector pipes for multiply). As we assume this function will use both vector pipelines, the throughput for this function is reduced to 1 per cycle.</p>
<p>We still need to select/merge the results. The vperm instruction is dependent on the execution of both vmulouh/vmuleuh and load of the select vector complete. For this case we assume that the load of the permute select vector has already executed. The processor can not issue the vperm until both vmulouh/vmuleuh instructions execute. The latency for vperm is 2 cycles (3 on POWER9). So the best case latency for this operation is is (7 + 2 = 9) cycles (10 on POWER9).</p>
<p>Looking at the first or only execution of <a class="el" href="vec__int16__ppc_8h.html#af8f778868c7a8a71b9e901042f24f1c2" title="Vector Multiply High Unsigned halfword. ">vec_mulhuh()</a> in a function defines the worse case latency. Here we have to include the permute select vector load and (for LE) the select vector complement. However this case provides additional multiple pipe parallelism that needs to be accounted for in the latencies.</p>
<p>The compiler notes that addis/vmulouh/vmuleuh are independent instructions that can execute concurrently in separate pipelines. So the compiler schedules them to issue in same cycle. The latency for vmulouh/vmuleuh is 7 cycles while the addis latency is only 2 cycles. The dependent addi instruction can issue in the 3rd cycle, while vmulouh/vmuleuh are still executing. The addi also has a 2 cycle latency, so the dependent lvx can issue in the 5th cycle, while vmulouh/vmuleuh are still executing. The lvx has a latency of 5 cycles and will not complete execution until 2 cycles after vmulouh/vmuleuh. The dependent xxlnor is waiting of the load (lvx) and has a latency of 2 cycles.</p>
<p>So there are two independent instruction sequences; vmulouh/vmuleuh and addis/addi/lvx/xxlnor. Both must complete execution before the vperm can issue and complete the operation. The later sequence has the longer (2+2+5+2=11) latency and dominates the timing. So the worst latency for the full sequence is (2+2+5+2+2 = 13) cycles (14 on POWER9).</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9-13 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">10-14 </td><td align="left">1/cycle </td></tr>
</table>
<h2><a class="anchor" id="int16_perf_0_1"></a>
More information.</h2>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af876e907b6f1bf6868033be2127d4238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af876e907b6f1bf6868033be2127d4238">&#9670;&nbsp;</a></span>vec_absduh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_absduh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Absolute Difference Unsigned halfword. </p>
<p>Compute the absolute difference for each halfword. For each unsigned halfword, subtract VRB[i] from VRA[i] and return the absolute value of the difference.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>vector of 8 x unsigned halfword </td></tr>
    <tr><td class="paramname">vrb</td><td>vector of 8 x unsigned halfword </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the absolute differences. </dd></dl>

</div>
</div>
<a id="ad4dbe03259aae45b330f18a7c9a62c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dbe03259aae45b330f18a7c9a62c81">&#9670;&nbsp;</a></span>vec_clzh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_clzh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count Leading Zeros for a vector unsigned short (halfword) elements. </p>
<p>Count the number of leading '0' bits (0-16) within each halfword element of a 128-bit vector.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Count Leading Zeros Halfword instruction <b>vclzh</b>. Otherwise use sequence of pre 2.07 VMX instructions.</p>
<dl class="section note"><dt>Note</dt><dd>SIMDized count leading zeros inspired by: Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 5 Counting Bits, Figure 5-12.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 8 x 16-bit integer (halfword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the Leading Zeros count for each halfword element. </dd></dl>

</div>
</div>
<a id="a1fa4e2cd07718acb38ed3530930103e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa4e2cd07718acb38ed3530930103e0">&#9670;&nbsp;</a></span>vec_mrgahh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_mrgahh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Algebraic High Halfword operation. </p>
<p>Merge only the high halfwords from 8 x Algebraic words across vectors vra and vrb. This is effectively the Vector Merge Even Halfword operation that is not modified for endian.</p>
<p>For example merge the high 16-bits from each of 8 x 32-bit products as generated by vec_muleuh/vec_mulouh. This result is effectively a vector multiply high unsigned halfword.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the high halfwords of the 8 x Algebraic words across vra and vrb. </dd></dl>

</div>
</div>
<a id="a152cc7dff6dd572711432962a211a97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152cc7dff6dd572711432962a211a97e">&#9670;&nbsp;</a></span>vec_mrgalh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_mrgalh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Algebraic Low Halfword operation. </p>
<p>Merge only the low halfwords from 8 x Algebraic words across vectors vra and vrb. This is effectively the Vector Merge Odd Halfword operation that is not modified for endian.</p>
<p>For example merge the low 16-bits from each of 8 x 32-bit products as generated by vec_muleuh/vec_mulouh. This result is effectively a vector multiply low unsigned halfword.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the high halfwords of the 8 x Algebraic words across vra and vrb. </dd></dl>

</div>
</div>
<a id="a8fd1ea4bcf0c44883d806d42feb50db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd1ea4bcf0c44883d806d42feb50db2">&#9670;&nbsp;</a></span>vec_mrgeh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_mrgeh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Even Halfwords operation. </p>
<p>Merge the even halfword elements from the concatenation of 2 x vectors (vra and vrb).</p>
<dl class="section note"><dt>Note</dt><dd>The element numbering changes between big and little-endian. So the compiler and this implementation adjusts the generated code to reflect this.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned short. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned short. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the even halfwords of vra and vrb. </dd></dl>

</div>
</div>
<a id="a2f08727b429f9159f6f189bd49be5617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f08727b429f9159f6f189bd49be5617">&#9670;&nbsp;</a></span>vec_mrgoh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_mrgoh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Odd Halfwords operation. </p>
<p>Merge the odd halfword elements from the concatenation of 2 x vectors (vra and vrb).</p>
<dl class="section note"><dt>Note</dt><dd>The element numbering changes between big and little-endian. So the compiler and this implementation adjusts the generated code to reflect this.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned short. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned short. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the odd halfwords of vra and vrb. </dd></dl>

</div>
</div>
<a id="a2e5392538865fa36128b9a2475541022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5392538865fa36128b9a2475541022">&#9670;&nbsp;</a></span>vec_mulhsh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a873846dd078cef3d766814d856760526">vi16_t</a> vec_mulhsh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a873846dd078cef3d766814d856760526">vi16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a873846dd078cef3d766814d856760526">vi16_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Signed halfword. </p>
<p>Multiple the corresponding halfword elements of two vector signed short values and return the high order 16-bits, for each 32-bit product element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9-13 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">10-14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector signed short. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector signed short. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the high order 16-bits of the product of the halfword elements from vra and vrb. </dd></dl>

</div>
</div>
<a id="af8f778868c7a8a71b9e901042f24f1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f778868c7a8a71b9e901042f24f1c2">&#9670;&nbsp;</a></span>vec_mulhuh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_mulhuh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Unsigned halfword. </p>
<p>Multiply the corresponding halfword elements of two vector unsigned short values and return the high order 16-bits, for each 32-bit product element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9-13 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">10-14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned short. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned short. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the high order 16-bits of the product of the halfword elements from vra and vrb. </dd></dl>

</div>
</div>
<a id="abceaf3207f8b6fbb27a3e88409f8357b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abceaf3207f8b6fbb27a3e88409f8357b">&#9670;&nbsp;</a></span>vec_muluhm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_muluhm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Unsigned halfword Modulo. </p>
<p>Multiply the corresponding halfword elements of two vector unsigned short values and return the low order 16-bits of the 32-bit product for each element.</p>
<dl class="section note"><dt>Note</dt><dd>vec_muluhm can be used for unsigned or signed short integers. It is the vector equivalent of Multiply Low Halfword.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9-13 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">10-14 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned short. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned short. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the low order 16-bits of the unsigned product of the halfword elements from vra and vrb. </dd></dl>

</div>
</div>
<a id="a4ffb24b16a416d733b09a53830cd3713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffb24b16a416d733b09a53830cd3713">&#9670;&nbsp;</a></span>vec_popcnth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_popcnth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Population Count halfword. </p>
<p>Count the number of '1' bits (0-16) within each byte element of a 128-bit vector.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Population Count Halfword instruction. Otherwise use simple Vector (VMX) instructions to count bits in bytes in parallel.</p>
<dl class="section note"><dt>Note</dt><dd>SIMDized population count inspired by: Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 5 Counting Bits, Figure 5-2.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 8 x 16-bit integers (halfword) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the population count for each halfword element. </dd></dl>

</div>
</div>
<a id="a235df54b24f644e6cc23018bdfa4e37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235df54b24f644e6cc23018bdfa4e37e">&#9670;&nbsp;</a></span>vec_revbh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_revbh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>byte reverse each halfword of a vector unsigned short. </p>
<p>For each halfword of the input vector, reverse the order of bytes / octets within the halfword.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector unsigned short. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector with the bytes of each halfword reversed. </dd></dl>

</div>
</div>
<a id="a4fc5f291cc0e6a99700760df89f5070b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc5f291cc0e6a99700760df89f5070b">&#9670;&nbsp;</a></span>vec_slhi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_slhi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift left Halfword Immediate. </p>
<p>Shift left each halfword element [0-7], 0-15 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-15. A shift count of 0 returns the original value of vra. Shift counts greater then 15 bits return zero.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-11 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned short. </td></tr>
    <tr><td class="paramname">shb</td><td>Shift amount in the range 0-15. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned short, shifted left shb bits. </dd></dl>

</div>
</div>
<a id="ac9b21dd9f53dd97d3c1f58881f38b5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b21dd9f53dd97d3c1f58881f38b5af">&#9670;&nbsp;</a></span>vec_srahi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a873846dd078cef3d766814d856760526">vi16_t</a> vec_srahi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a873846dd078cef3d766814d856760526">vi16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Algebraic Halfword Immediate. </p>
<p>Shift right algebraic each halfword element [0-7], 0-15 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-15. A shift count of 0 returns the original value of vra. Shift counts greater then 7 bits return the sign bit propagated to each bit of each element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-11 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector signed char. </td></tr>
    <tr><td class="paramname">shb</td><td>Shift amount in the range 0-7. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector signed short, shifted right shb bits. </dd></dl>

</div>
</div>
<a id="a292973c417034f4b8813765b63ca03c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292973c417034f4b8813765b63ca03c2">&#9670;&nbsp;</a></span>vec_srhi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_srhi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Halfword Immediate. </p>
<p>Shift right each halfword element [0-7], 0-15 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-15. A shift count of 0 returns the original value of vra. Shift counts greater then 15 bits return zero.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-11 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned short. </td></tr>
    <tr><td class="paramname">shb</td><td>Shift amount in the range 0-15. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned short, shifted right shb bits. </dd></dl>

</div>
</div>
<a id="ac0b8c37da453c373690760370a8ceb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b8c37da453c373690760370a8ceb39">&#9670;&nbsp;</a></span>vec_vmaddeuh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_vmaddeuh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add Even Unsigned Halfwords. </p>
<p>Multiply the even 16-bit Words of vector unsigned short values (a * b) and return sums of the unsigned 32-bit product and the even 16-bit halfwords of c (a<sub>even</sub> * b<sub>even</sub>) + EXTZ(c<sub>even</sub>).</p>
<dl class="section note"><dt>Note</dt><dd>The advantage of this form (versus Multiply-Sum) is that the final 32 bit sums can not overflow. </dd>
<dd>
This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9-18 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9-16 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned short. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned short. </td></tr>
    <tr><td class="paramname">c</td><td>128-bit vector unsigned short. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned int sum (a<sub>even</sub> * b<sub>even</sub>) + EXTZ(c<sub>even</sub>). </dd></dl>

</div>
</div>
<a id="aa0ddf6a0d591ec6836d1a2b349d16d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ddf6a0d591ec6836d1a2b349d16d4d">&#9670;&nbsp;</a></span>vec_vmaddouh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_vmaddouh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add Odd Unsigned Halfwords. </p>
<p>Multiply the odd 16-bit Halfwords of vector unsigned short values (a * b) and return sums of the unsigned 32-bit product and the odd 16-bit halfwords of c (a<sub>odd</sub> * b<sub>odd</sub>) + EXTZ(c<sub>odd</sub>).</p>
<dl class="section note"><dt>Note</dt><dd>The advantage of this form (versus Multiply-Sum) is that the final 32 bit sums can not overflow. </dd>
<dd>
This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9-18 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9-16 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned short. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned short. </td></tr>
    <tr><td class="paramname">c</td><td>128-bit vector unsigned short. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned int sum (a<sub>odd</sub> * b<sub>odd</sub>) + EXTZ(c<sub>odd</sub>). </dd></dl>

</div>
</div>
<a id="aabf6f4a95093b3e9ae78c8600e8d9d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf6f4a95093b3e9ae78c8600e8d9d40">&#9670;&nbsp;</a></span>vec_vmrgeh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_vmrgeh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Even Halfwords. </p>
<p>Merge the even halfword elements from the concatenation of 2 x vectors (vra and vrb).</p>
<dl class="section note"><dt>Note</dt><dd>This function implements the operation of a Vector Merge Even Halfword instruction, if the PowerISA included such an instruction. This implementation is NOT endian sensitive and the function is stable across BE/LE implementations. Using big-endian element numbering:<ul>
<li>res[0] = vra[0];</li>
<li>res[1] = vrb[0];</li>
<li>res[2] = vra[2];</li>
<li>res[3] = vrb[2];</li>
<li>res[4] = vra[4];</li>
<li>res[5] = vrb[4];</li>
<li>res[6] = vra[6];</li>
<li>res[7] = vrb[6];</li>
</ul>
</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned short. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned short. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the even halfwords of vra and vrb. </dd></dl>

</div>
</div>
<a id="a525c4f6be5284ec528f3df527b07727a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525c4f6be5284ec528f3df527b07727a">&#9670;&nbsp;</a></span>vec_vmrgoh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_vmrgoh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Odd Halfwords. </p>
<p>Merge the odd halfword elements from the concatenation of 2 x vectors (vra and vrb).</p>
<dl class="section note"><dt>Note</dt><dd>This function implements the operation of a Vector Merge Odd Halfword instruction, if the PowerISA included such an instruction. This implementation is NOT endian sensitive and the function is stable across BE/LE implementations. Using big-endian element numbering:<ul>
<li>res[0] = vra[1];</li>
<li>res[1] = vrb[1];</li>
<li>res[2] = vra[3];</li>
<li>res[3] = vrb[3];</li>
<li>res[4] = vra[5];</li>
<li>res[5] = vrb[5];</li>
<li>res[6] = vra[7];</li>
<li>res[7] = vrb[7];</li>
</ul>
</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-13 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-14 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned short. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned short. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the odd halfwords of vra and vrb. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 17 2020 17:13:19 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
