<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>POWER Vector Library Manual: src/pveclib/vec_f128_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3653a864936a87c29f489ec2a5b8be1c.html">pveclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_f128_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over Quad-Precision floating point elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__common__ppc_8h_source.html">pveclib/vec_common_ppc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="vec__int128__ppc_8h_source.html">pveclib/vec_int128_ppc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="vec__f64__ppc_8h_source.html">pveclib/vec_f64_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__f128__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union____VF__128.html">__VF_128</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union used to transfer 128-bit data between vector and __float128 types.  <a href="union____VF__128.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5c0751a2b64a9a560e9a964294f63166"><td class="memItemLeft" align="right" valign="top"><a id="a5c0751a2b64a9a560e9a964294f63166"></a>
typedef <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a></td></tr>
<tr class="memdesc:a5c0751a2b64a9a560e9a964294f63166"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 128-bit binary128 element. Same as __float128 for PPC. <br /></td></tr>
<tr class="separator:a5c0751a2b64a9a560e9a964294f63166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f89d266b82d1a8f300348cf99b9ae3f"><td class="memItemLeft" align="right" valign="top"><a id="a5f89d266b82d1a8f300348cf99b9ae3f"></a>
typedef <a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a5f89d266b82d1a8f300348cf99b9ae3f">__Float128</a></td></tr>
<tr class="memdesc:a5f89d266b82d1a8f300348cf99b9ae3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __Float128 if not defined by the compiler. Same as __float128 for PPC. <br /></td></tr>
<tr class="separator:a5f89d266b82d1a8f300348cf99b9ae3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443a43ae34ab3b78564d2a8277503cac"><td class="memItemLeft" align="right" valign="top"><a id="a443a43ae34ab3b78564d2a8277503cac"></a>
typedef <a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></td></tr>
<tr class="memdesc:a443a43ae34ab3b78564d2a8277503cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __binary128 if not defined by the compiler. Same as __float128 for PPC. <br /></td></tr>
<tr class="separator:a443a43ae34ab3b78564d2a8277503cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af2270bedc312f7d99c0605358cd28c"><td class="memItemLeft" align="right" valign="top"><a id="a4af2270bedc312f7d99c0605358cd28c"></a>
typedef <a class="el" href="vec__f128__ppc_8h.html#a5c0751a2b64a9a560e9a964294f63166">vf128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4af2270bedc312f7d99c0605358cd28c">__float128</a></td></tr>
<tr class="memdesc:a4af2270bedc312f7d99c0605358cd28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __float128 if not defined by the compiler. Same as __float128 for PPC. <br /></td></tr>
<tr class="separator:a4af2270bedc312f7d99c0605358cd28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55019fe6dc8271e91613db7b1ae96721"><td class="memItemLeft" align="right" valign="top"><a id="a55019fe6dc8271e91613db7b1ae96721"></a>
typedef long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a55019fe6dc8271e91613db7b1ae96721">__IBM128</a></td></tr>
<tr class="memdesc:a55019fe6dc8271e91613db7b1ae96721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define __IBM128 if not defined by the compiler. Same as old long double for PPC. <br /></td></tr>
<tr class="separator:a55019fe6dc8271e91613db7b1ae96721"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a57dc5b9171d5ce3d49f0f12795659c1a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a57dc5b9171d5ce3d49f0f12795659c1a">vec_xfer_bin128_2_vui8t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a57dc5b9171d5ce3d49f0f12795659c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector char.  <a href="#a57dc5b9171d5ce3d49f0f12795659c1a">More...</a><br /></td></tr>
<tr class="separator:a57dc5b9171d5ce3d49f0f12795659c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0629194f4f63bb083c271844459072"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aff0629194f4f63bb083c271844459072">vec_xfer_bin128_2_vui16t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aff0629194f4f63bb083c271844459072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector short int.  <a href="#aff0629194f4f63bb083c271844459072">More...</a><br /></td></tr>
<tr class="separator:aff0629194f4f63bb083c271844459072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8043c2c5ac35d2b0a8bd8f33779c91a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a8043c2c5ac35d2b0a8bd8f33779c91a6">vec_xfer_bin128_2_vui32t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a8043c2c5ac35d2b0a8bd8f33779c91a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector int.  <a href="#a8043c2c5ac35d2b0a8bd8f33779c91a6">More...</a><br /></td></tr>
<tr class="separator:a8043c2c5ac35d2b0a8bd8f33779c91a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac5809f5f651e45113de8410664f2c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#acac5809f5f651e45113de8410664f2c7">vec_xfer_bin128_2_vui64t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:acac5809f5f651e45113de8410664f2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector long long int.  <a href="#acac5809f5f651e45113de8410664f2c7">More...</a><br /></td></tr>
<tr class="separator:acac5809f5f651e45113de8410664f2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6e44a75847d3d3e5611b89eed71c0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aec6e44a75847d3d3e5611b89eed71c0a">vec_xfer_bin128_2_vui128t</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aec6e44a75847d3d3e5611b89eed71c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer function from a __binary128 scalar to a vector __int128.  <a href="#aec6e44a75847d3d3e5611b89eed71c0a">More...</a><br /></td></tr>
<tr class="separator:aec6e44a75847d3d3e5611b89eed71c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047b7dc5b55b2d13e2fd826c63872ea9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a047b7dc5b55b2d13e2fd826c63872ea9">vec_xfer_vui8t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> f128)</td></tr>
<tr class="memdesc:a047b7dc5b55b2d13e2fd826c63872ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned char to __binary128 scalar.  <a href="#a047b7dc5b55b2d13e2fd826c63872ea9">More...</a><br /></td></tr>
<tr class="separator:a047b7dc5b55b2d13e2fd826c63872ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dec5c23a659b2fca1c219fe783f88eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a3dec5c23a659b2fca1c219fe783f88eb">vec_xfer_vui16t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> f128)</td></tr>
<tr class="memdesc:a3dec5c23a659b2fca1c219fe783f88eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned short to __binary128 scalar.  <a href="#a3dec5c23a659b2fca1c219fe783f88eb">More...</a><br /></td></tr>
<tr class="separator:a3dec5c23a659b2fca1c219fe783f88eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0596ab318ba6d1ec5e7ed40871255a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af0596ab318ba6d1ec5e7ed40871255a9">vec_xfer_vui32t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> f128)</td></tr>
<tr class="memdesc:af0596ab318ba6d1ec5e7ed40871255a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned int to __binary128 scalar.  <a href="#af0596ab318ba6d1ec5e7ed40871255a9">More...</a><br /></td></tr>
<tr class="separator:af0596ab318ba6d1ec5e7ed40871255a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8002c29875a226d11ec57a42b5b3955"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ae8002c29875a226d11ec57a42b5b3955">vec_xfer_vui64t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> f128)</td></tr>
<tr class="memdesc:ae8002c29875a226d11ec57a42b5b3955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned long long to __binary128 scalar.  <a href="#ae8002c29875a226d11ec57a42b5b3955">More...</a><br /></td></tr>
<tr class="separator:ae8002c29875a226d11ec57a42b5b3955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b99b632646aaca91de6834e2b1da26"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26">vec_xfer_vui128t_2_bin128</a> (<a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> f128)</td></tr>
<tr class="memdesc:a91b99b632646aaca91de6834e2b1da26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a vector unsigned __int128 to __binary128 scalar.  <a href="#a91b99b632646aaca91de6834e2b1da26">More...</a><br /></td></tr>
<tr class="separator:a91b99b632646aaca91de6834e2b1da26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add641f5a217eff45f0e836fa98613584"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#add641f5a217eff45f0e836fa98613584">vec_absf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:add641f5a217eff45f0e836fa98613584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the sign bit of __float128 input and return the resulting positive __float128 value.  <a href="#add641f5a217eff45f0e836fa98613584">More...</a><br /></td></tr>
<tr class="separator:add641f5a217eff45f0e836fa98613584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946ffd501b32f3ec96563ab101afbfad"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">vec_all_isfinitef128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a946ffd501b32f3ec96563ab101afbfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is Finite (Not NaN nor Inf).  <a href="#a946ffd501b32f3ec96563ab101afbfad">More...</a><br /></td></tr>
<tr class="separator:a946ffd501b32f3ec96563ab101afbfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fc4e7c94d0b30bb3515931aaf723da"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a66fc4e7c94d0b30bb3515931aaf723da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is infinity.  <a href="#a66fc4e7c94d0b30bb3515931aaf723da">More...</a><br /></td></tr>
<tr class="separator:a66fc4e7c94d0b30bb3515931aaf723da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06b73ac57985011c558670adc283e89"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af06b73ac57985011c558670adc283e89">vec_all_isnanf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:af06b73ac57985011c558670adc283e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is Not a Number (NaN).  <a href="#af06b73ac57985011c558670adc283e89">More...</a><br /></td></tr>
<tr class="separator:af06b73ac57985011c558670adc283e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc830b382bd45dc0ff815024c1bfb26d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">vec_all_isnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:afc830b382bd45dc0ff815024c1bfb26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).  <a href="#afc830b382bd45dc0ff815024c1bfb26d">More...</a><br /></td></tr>
<tr class="separator:afc830b382bd45dc0ff815024c1bfb26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1a94cccdb3f106a0e6399e2f034718"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#adf1a94cccdb3f106a0e6399e2f034718">vec_all_issubnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:adf1a94cccdb3f106a0e6399e2f034718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is subnormal (denormal).  <a href="#adf1a94cccdb3f106a0e6399e2f034718">More...</a><br /></td></tr>
<tr class="separator:adf1a94cccdb3f106a0e6399e2f034718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac554a9d0d12fca036772aaaee5908414"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">vec_all_iszerof128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:ac554a9d0d12fca036772aaaee5908414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the __float128 value is +-0.0.  <a href="#ac554a9d0d12fca036772aaaee5908414">More...</a><br /></td></tr>
<tr class="separator:ac554a9d0d12fca036772aaaee5908414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb73eac40698921735bad8ac4ce560e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#adfb73eac40698921735bad8ac4ce560e">vec_copysignf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128x, <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128y)</td></tr>
<tr class="memdesc:adfb73eac40698921735bad8ac4ce560e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the sign bit from f128y and merge with the magnitude from f128x. The merged result is returned as a __float128 value.  <a href="#adfb73eac40698921735bad8ac4ce560e">More...</a><br /></td></tr>
<tr class="separator:adfb73eac40698921735bad8ac4ce560e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a30726ccfb216e4d2e1ede3854ab96b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a0a30726ccfb216e4d2e1ede3854ab96b">vec_const_huge_valf128</a> ()</td></tr>
<tr class="memdesc:a0a30726ccfb216e4d2e1ede3854ab96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a positive infinity.  <a href="#a0a30726ccfb216e4d2e1ede3854ab96b">More...</a><br /></td></tr>
<tr class="separator:a0a30726ccfb216e4d2e1ede3854ab96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c68f73f69c4776bb054d42915e7103d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a9c68f73f69c4776bb054d42915e7103d">vec_const_inff128</a> ()</td></tr>
<tr class="memdesc:a9c68f73f69c4776bb054d42915e7103d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a positive infinity.  <a href="#a9c68f73f69c4776bb054d42915e7103d">More...</a><br /></td></tr>
<tr class="separator:a9c68f73f69c4776bb054d42915e7103d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fb1013dfcf633156cd7f855a11fb56"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ()</td></tr>
<tr class="memdesc:af7fb1013dfcf633156cd7f855a11fb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a quiet NaN.  <a href="#af7fb1013dfcf633156cd7f855a11fb56">More...</a><br /></td></tr>
<tr class="separator:af7fb1013dfcf633156cd7f855a11fb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac806c62ebaae6ab8faca87794cb917c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aac806c62ebaae6ab8faca87794cb917c">vec_const_nansf128</a> ()</td></tr>
<tr class="memdesc:aac806c62ebaae6ab8faca87794cb917c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a signaling NaN.  <a href="#aac806c62ebaae6ab8faca87794cb917c">More...</a><br /></td></tr>
<tr class="separator:aac806c62ebaae6ab8faca87794cb917c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1668ff13922ca04059f1844a7a1464f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#ad1668ff13922ca04059f1844a7a1464f">vec_isfinitef128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:ad1668ff13922ca04059f1844a7a1464f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true if the __float128 value is Finite (Not NaN nor Inf).  <a href="#ad1668ff13922ca04059f1844a7a1464f">More...</a><br /></td></tr>
<tr class="separator:ad1668ff13922ca04059f1844a7a1464f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd9706acb775392282cfe4d4e3a03aa"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aebd9706acb775392282cfe4d4e3a03aa">vec_isinf_signf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aebd9706acb775392282cfe4d4e3a03aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true (nonzero) value if the __float128 value is infinity. For infinity indicate the sign as +1 for positive infinity and -1 for negative infinity.  <a href="#aebd9706acb775392282cfe4d4e3a03aa">More...</a><br /></td></tr>
<tr class="separator:aebd9706acb775392282cfe4d4e3a03aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f9c7429c2ebd9b9f32ad6e98689ebb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a94f9c7429c2ebd9b9f32ad6e98689ebb">vec_isinff128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a94f9c7429c2ebd9b9f32ad6e98689ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 128-bit vector boolean true if the __float128 value is infinity.  <a href="#a94f9c7429c2ebd9b9f32ad6e98689ebb">More...</a><br /></td></tr>
<tr class="separator:a94f9c7429c2ebd9b9f32ad6e98689ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c410994f958a6b4ac9583878a55a72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a11c410994f958a6b4ac9583878a55a72">vec_isnanf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a11c410994f958a6b4ac9583878a55a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN).  <a href="#a11c410994f958a6b4ac9583878a55a72">More...</a><br /></td></tr>
<tr class="separator:a11c410994f958a6b4ac9583878a55a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25185c83b69f6af3f3d9399199c8a57"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#aa25185c83b69f6af3f3d9399199c8a57">vec_isnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:aa25185c83b69f6af3f3d9399199c8a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true if the __float128 value is normal (Not NaN, Inf, denormal, or zero).  <a href="#aa25185c83b69f6af3f3d9399199c8a57">More...</a><br /></td></tr>
<tr class="separator:aa25185c83b69f6af3f3d9399199c8a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9670e4655a9c7888c80343780cd7abf9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a9670e4655a9c7888c80343780cd7abf9">vec_issubnormalf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a9670e4655a9c7888c80343780cd7abf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true value, if the __float128 value is subnormal (denormal).  <a href="#a9670e4655a9c7888c80343780cd7abf9">More...</a><br /></td></tr>
<tr class="separator:a9670e4655a9c7888c80343780cd7abf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598a822d22b02ba0d2c2a1095a4e700d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a598a822d22b02ba0d2c2a1095a4e700d">vec_iszerof128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a598a822d22b02ba0d2c2a1095a4e700d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 128-bit vector boolean true value, if the value that is +-0.0.  <a href="#a598a822d22b02ba0d2c2a1095a4e700d">More...</a><br /></td></tr>
<tr class="separator:a598a822d22b02ba0d2c2a1095a4e700d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b388cfc9af26418bdd4ec8e4e6f73"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4d5b388cfc9af26418bdd4ec8e4e6f73">vec_setb_qp</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a4d5b388cfc9af26418bdd4ec8e4e6f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Set Bool from Quadword Floating-point.  <a href="#a4d5b388cfc9af26418bdd4ec8e4e6f73">More...</a><br /></td></tr>
<tr class="separator:a4d5b388cfc9af26418bdd4ec8e4e6f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca7749d334c2a2c17a4d2a98b5bf755"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__f128__ppc_8h.html#a4ca7749d334c2a2c17a4d2a98b5bf755">vec_signbitf128</a> (<a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> f128)</td></tr>
<tr class="memdesc:a4ca7749d334c2a2c17a4d2a98b5bf755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return int boolean true if the __float128 value is negative (sign bit is '1').  <a href="#a4ca7749d334c2a2c17a4d2a98b5bf755">More...</a><br /></td></tr>
<tr class="separator:a4ca7749d334c2a2c17a4d2a98b5bf755"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over Quad-Precision floating point elements. </p>
<p>PowerISA 3.0 added Quad-Precision floating point type and operations to the Vector-Scalar Extension (VSX) facility. The first hardware implementation is available in POWER9.</p>
<p>While all Quad-Precision operations are on 128-bit vector registers, they are defined as scalars in the PowerISA. The OpenPOWER ABI also treats the __float128 type as scalar that just happens to use vector registers for parameter passing and operations. As such no operations using __float128 (_Float128, or __ieee128) as parameter or return value are defined as vector built-ins in the ABI or &lt;altivec.h&gt;.</p>
<dl class="section note"><dt>Note</dt><dd>GCC 8.2 does document some built-ins, using the <em>scalar</em> prefix (scalar_extract_exp, scalar_extract_sig, scalar_test_data_class), that do accept the __ieee128 type. This work seems to be incomplete as scalar_exp_cmp_* for the __ieee128 type are not present. GCC 7.3 defines vector and scalar forms of the extract/insert_exp for float and double but not for __ieee128. These built-ins are not defined in GCC 6.4. See <a href="https://gcc.gnu.org/onlinedocs/">compiler documentation</a>. These are useful operations and can be implement in a few vector logical instruction for earlier machines. So it seems reasonable to add these to pveclib for both vector and scalar forms.</dd></dl>
<p>Quad-Precision is not supported in hardware until POWER9. However the compiler and runtime supports the __float128 type and arithmetic operations via soft-float emulation for earlier processors. The soft-float implementation follows the ABI and passes __float128 parameters and return values in vector registers.</p>
<p>So it is not unreasonable for this header to provide vector forms of the __float128 classification functions (isnormal/subnormal/finite/inf/nan/zero, copysign, and abs). These functions can be implemented directly using (one or more) POWER9 instructions, or a few vector logical and integer compare instructions for POWER7/8. Each is comfortably small enough to be in-lined and inherently faster than the equivalent POSIX or compiler built-in runtime functions. Performing these operations in-line and directly in vector registers (VRs) avoids call/return and VR &lt;-&gt; GPR transfer overhead.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power8</b>, Quad-Precision floating-point operations useful for floating point classification are not defined. This header provides the appropriate substitutions, will generate the minimum code, appropriate for the target, and produce correct results.</dd>
<dd>
Most ppc64le compilers will default to <b>-mcpu=</b><em>power8</em> if <b>-mcpu</b> is not specified.</dd></dl>
<p>This header covers operations that are any of the following:</p>
<ul>
<li>Implemented in hardware instructions in newer processors, but useful to programmers on slightly older processors (even if the equivalent function requires more instructions).</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.h&gt; provided by available compilers in common use. Examples include scalar_test_neg, scalar_test_data_class, etc.</li>
<li>Providing special vector float tests for special conditions without generating extraneous floating-point exceptions. This is important for implementing __float128 forms of ISO C99 Math functions. Examples include vector isnan, isinf, etc.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious.</li>
</ul>
<h1><a class="anchor" id="f128_examples_0_0"></a>
Examples</h1>
<p>For example: using the the classification functions for implementing the math library function sine and cosine. The Posix specification requires that special input values are processed without raising extraneous floating point exceptions and return specific floating point values in response. For example the sin() function.</p><ul>
<li>If the input <em>value</em> is NaN then return a NaN.</li>
<li>If the input <em>value</em> is +-0.0 then return <em>value</em>.</li>
<li>If the input <em>value</em> is subnormal then return <em>value</em>.</li>
<li>If the input <em>value</em> is +-Inf then return a NaN.</li>
<li>Otherwise compute and return sin(value).</li>
</ul>
<p>The following code example uses functions from this header to address the POSIX requirements for special values input to sinf128(): </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div><div class="line">test_sinf128 (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> value)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#afc830b382bd45dc0ff815024c1bfb26d">vec_all_isnormalf128</a> (value))</div><div class="line">    {</div><div class="line">      <span class="comment">// body of taylor series.</span></div><div class="line">      ...</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a> (value))</div><div class="line">        result = <a class="code" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ();</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        result = value;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p>For another example the cos() function.</p><ul>
<li>If the input <em>value</em> is NaN then return a NaN.</li>
<li>If the input <em>value</em> is +-0.0 then return <em>1.0</em>.</li>
<li>If the input <em>value</em> is +-Inf then return a NaN.</li>
<li>Otherwise compute and return cos(value).</li>
</ul>
<p>The following code example uses functions from this header to address the Posix requirements for special values input to cosf128(): </p><div class="fragment"><div class="line"><a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a></div><div class="line">test_cosf128 (<a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> value)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> result;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#a946ffd501b32f3ec96563ab101afbfad">vec_all_isfinitef128</a> (value))</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#ac554a9d0d12fca036772aaaee5908414">vec_all_iszerof128</a> (value))</div><div class="line">        result = 1.0Q;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="comment">// body of taylor series ...</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="vec__f128__ppc_8h.html#a66fc4e7c94d0b30bb3515931aaf723da">vec_all_isinff128</a> (value))</div><div class="line">        result = <a class="code" href="vec__f128__ppc_8h.html#af7fb1013dfcf633156cd7f855a11fb56">vec_const_nanf128</a> ();</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        result = value;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p>Neither example raises floating point exceptions or sets <b>errno</b>, as appropriate for a vector math library.</p>
<h1><a class="anchor" id="f128_perf_0_0"></a>
Performance data</h1>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="add641f5a217eff45f0e836fa98613584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add641f5a217eff45f0e836fa98613584">&#9670;&nbsp;</a></span>vec_absf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_absf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the sign bit of __float128 input and return the resulting positive __float128 value. </p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">4/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value containing a signed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __float128 value with magnitude from f128 and a positive sign of f128. </dd></dl>

</div>
</div>
<a id="a946ffd501b32f3ec96563ab101afbfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946ffd501b32f3ec96563ab101afbfad">&#9670;&nbsp;</a></span>vec_all_isfinitef128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isfinitef128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary128 finite value has an exponent between 0x0000 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value. Using the !vec_all_eq compare conditional verify this condition and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07. The sign bit is ignored.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-20 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="a66fc4e7c94d0b30bb3515931aaf723da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fc4e7c94d0b30bb3515931aaf723da">&#9670;&nbsp;</a></span>vec_all_isinff128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isinff128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is infinity. </p>
<p>A IEEE Binary128 infinity has a exponent of 0x7fff and significand of all zeros. Using the vec_all_eq compare conditional verifies both conditions and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-20 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="af06b73ac57985011c558670adc283e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06b73ac57985011c558670adc283e89">&#9670;&nbsp;</a></span>vec_all_isnanf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnanf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is Not a Number (NaN). </p>
<p>A IEEE Binary128 NaN has a exponent of 0x7fff and nonzero significand. Using the combined vec_all_eq / vec_any_gt compare conditional verify both conditions and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07. The sign bit is ignored.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">6-29 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="afc830b382bd45dc0ff815024c1bfb26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc830b382bd45dc0ff815024c1bfb26d">&#9670;&nbsp;</a></span>vec_all_isnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_isnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary128 normal value has an exponent between 0x0001 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). Using the combined vec_all_ne compares conditional verify both conditions and avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07. The sign bit is ignored.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-29 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 or 1. </dd></dl>

</div>
</div>
<a id="adf1a94cccdb3f106a0e6399e2f034718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1a94cccdb3f106a0e6399e2f034718">&#9670;&nbsp;</a></span>vec_all_issubnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_issubnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is subnormal (denormal). </p>
<p>A IEEE Binary128 subnormal has an exponent of 0x0000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-29 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary128 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if the __float128 value is subnormal. </dd></dl>

</div>
</div>
<a id="ac554a9d0d12fca036772aaaee5908414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac554a9d0d12fca036772aaaee5908414">&#9670;&nbsp;</a></span>vec_all_iszerof128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_all_iszerof128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the __float128 value is +-0.0. </p>
<p>A IEEE Binary128 zero has an exponent of 0x0000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-20 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean int, true if the __float128 value is +/- zero. </dd></dl>

</div>
</div>
<a id="a0a30726ccfb216e4d2e1ede3854ab96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a30726ccfb216e4d2e1ede3854ab96b">&#9670;&nbsp;</a></span>vec_const_huge_valf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_huge_valf128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a positive infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>const __float128 positive infinity. </dd></dl>

</div>
</div>
<a id="a9c68f73f69c4776bb054d42915e7103d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c68f73f69c4776bb054d42915e7103d">&#9670;&nbsp;</a></span>vec_const_inff128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_inff128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a positive infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>a const __float128 positive infinity. </dd></dl>

</div>
</div>
<a id="af7fb1013dfcf633156cd7f855a11fb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fb1013dfcf633156cd7f855a11fb56">&#9670;&nbsp;</a></span>vec_const_nanf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_nanf128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a quiet NaN. </p>
<dl class="section return"><dt>Returns</dt><dd>a const __float128 quiet NaN. </dd></dl>

</div>
</div>
<a id="aac806c62ebaae6ab8faca87794cb917c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac806c62ebaae6ab8faca87794cb917c">&#9670;&nbsp;</a></span>vec_const_nansf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_const_nansf128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a signaling NaN. </p>
<dl class="section return"><dt>Returns</dt><dd>a const __float128 signaling NaN. </dd></dl>

</div>
</div>
<a id="adfb73eac40698921735bad8ac4ce560e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb73eac40698921735bad8ac4ce560e">&#9670;&nbsp;</a></span>vec_copysignf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_copysignf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the sign bit from f128y and merge with the magnitude from f128x. The merged result is returned as a __float128 value. </p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">4/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128x</td><td>a __float128 value containing the magnitude. </td></tr>
    <tr><td class="paramname">f128y</td><td>a __float128 value containing the sign bit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a __float128 value with magnitude from f128x and the sign of f128y. </dd></dl>

</div>
</div>
<a id="ad1668ff13922ca04059f1844a7a1464f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1668ff13922ca04059f1844a7a1464f">&#9670;&nbsp;</a></span>vec_isfinitef128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isfinitef128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true if the __float128 value is Finite (Not NaN nor Inf). </p>
<p>A IEEE Binary128 finite value has an exponent between 0x0000 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value. Using the vec_cmpeq conditional to generate the predicate mask for NaN / Inf and then invert this for the finite condition. The sign bit is ignored.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-17 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s. </dd></dl>

</div>
</div>
<a id="aebd9706acb775392282cfe4d4e3a03aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd9706acb775392282cfe4d4e3a03aa">&#9670;&nbsp;</a></span>vec_isinf_signf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_isinf_signf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true (nonzero) value if the __float128 value is infinity. For infinity indicate the sign as +1 for positive infinity and -1 for negative infinity. </p>
<p>A IEEE Binary128 infinity has a exponent of 0x7fff and significand of all zeros. Using the vec_all_eq compare conditional verifies both conditions. A subsequent vec_any_gt checks the sign bit and set the result appropriately. The sign bit is ignored.</p>
<p>This sequence avoids a vector -&gt; GPR transfer for platforms before PowerISA-2.07.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">12-32 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3-12 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an int containing 0 if not infinity and +1/-1 otherwise. </dd></dl>

</div>
</div>
<a id="a94f9c7429c2ebd9b9f32ad6e98689ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f9c7429c2ebd9b9f32ad6e98689ebb">&#9670;&nbsp;</a></span>vec_isinff128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isinff128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a 128-bit vector boolean true if the __float128 value is infinity. </p>
<p>A IEEE Binary128 infinity has a exponent of 0x7fff and significand of all zeros. The sign bit is ignored.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-17 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s.. </dd></dl>

</div>
</div>
<a id="a11c410994f958a6b4ac9583878a55a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c410994f958a6b4ac9583878a55a72">&#9670;&nbsp;</a></span>vec_isnanf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isnanf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true if the __float128 value is Not a Number (NaN). </p>
<p>A IEEE Binary128 NaN has a exponent of 0x7fff and nonzero significand. This requires a combination of verifying the exponent and that any bit of the significand is nonzero. Using the combined vec_all_eq / vec_any_gt compare conditional verify both conditions before negating the result from zero to all ones.. The sign bit is ignored.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-19 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s. </dd></dl>

</div>
</div>
<a id="aa25185c83b69f6af3f3d9399199c8a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25185c83b69f6af3f3d9399199c8a57">&#9670;&nbsp;</a></span>vec_isnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_isnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true if the __float128 value is normal (Not NaN, Inf, denormal, or zero). </p>
<p>A IEEE Binary128 normal value has an exponent between 0x0001 and 0x7ffe (a 0x7fff indicates NaN or Inf). The significand can be any value (expect 0 if the exponent is zero). The sign bit is ignored.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">10-19 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean containing all 0s or 1s. </dd></dl>

</div>
</div>
<a id="a9670e4655a9c7888c80343780cd7abf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9670e4655a9c7888c80343780cd7abf9">&#9670;&nbsp;</a></span>vec_issubnormalf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_issubnormalf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true value, if the __float128 value is subnormal (denormal). </p>
<p>A IEEE Binary128 subnormal has an exponent of 0x0000 and a nonzero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">16-25 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary64 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean long long, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a598a822d22b02ba0d2c2a1095a4e700d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598a822d22b02ba0d2c2a1095a4e700d">&#9670;&nbsp;</a></span>vec_iszerof128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_iszerof128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 128-bit vector boolean true value, if the value that is +-0.0. </p>
<p>A IEEE Binary64 zero has an exponent of 0x000 and a zero significand. The sign bit is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not raise VXSNAN or VXVC (FE_INVALID) exceptions. A normal __float128 compare can.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">8-17 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector of __binary32 values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector boolean int, each containing all 0s(false) or 1s(true). </dd></dl>

</div>
</div>
<a id="a4d5b388cfc9af26418bdd4ec8e4e6f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5b388cfc9af26418bdd4ec8e4e6f73">&#9670;&nbsp;</a></span>vec_setb_qp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a> vec_setb_qp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Set Bool from Quadword Floating-point. </p>
<p>If the quadword's sign bit is '1' then return a vector bool __int128 that is all '1's. Otherwise return all '0's.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 - 6 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">6 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a 128-bit vector treated a signed __int128. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector bool of all '1's if the sign bit is '1'. Otherwise all '0's. </dd></dl>

</div>
</div>
<a id="a4ca7749d334c2a2c17a4d2a98b5bf755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca7749d334c2a2c17a4d2a98b5bf755">&#9670;&nbsp;</a></span>vec_signbitf128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vec_signbitf128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return int boolean true if the __float128 value is negative (sign bit is '1'). </p>
<p>Anding with a signmask and then vec_all_eq compare with that mask generates the boolean of the sign bit.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-20 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __float128 value in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a int boolean indicating the sign bit. </dd></dl>

</div>
</div>
<a id="aec6e44a75847d3d3e5611b89eed71c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6e44a75847d3d3e5611b89eed71c0a">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui128t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> vec_xfer_bin128_2_vui128t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector __int128. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector __int128. </dd></dl>

</div>
</div>
<a id="aff0629194f4f63bb083c271844459072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0629194f4f63bb083c271844459072">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui16t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a> vec_xfer_bin128_2_vui16t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector short int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector short int. </dd></dl>

</div>
</div>
<a id="a8043c2c5ac35d2b0a8bd8f33779c91a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8043c2c5ac35d2b0a8bd8f33779c91a6">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui32t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_xfer_bin128_2_vui32t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector int. </dd></dl>

</div>
</div>
<a id="acac5809f5f651e45113de8410664f2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac5809f5f651e45113de8410664f2c7">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui64t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_xfer_bin128_2_vui64t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector long long int. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector long long int. </dd></dl>

</div>
</div>
<a id="a57dc5b9171d5ce3d49f0f12795659c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57dc5b9171d5ce3d49f0f12795659c1a">&#9670;&nbsp;</a></span>vec_xfer_bin128_2_vui8t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a> vec_xfer_bin128_2_vui8t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer function from a __binary128 scalar to a vector char. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a __binary128 floating point scalar value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value as a 128-bit vector char. </dd></dl>

</div>
</div>
<a id="a91b99b632646aaca91de6834e2b1da26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b99b632646aaca91de6834e2b1da26">&#9670;&nbsp;</a></span>vec_xfer_vui128t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui128t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned __int128 to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned __int128 value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="a3dec5c23a659b2fca1c219fe783f88eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dec5c23a659b2fca1c219fe783f88eb">&#9670;&nbsp;</a></span>vec_xfer_vui16t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui16t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned short to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned short value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="af0596ab318ba6d1ec5e7ed40871255a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0596ab318ba6d1ec5e7ed40871255a9">&#9670;&nbsp;</a></span>vec_xfer_vui32t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui32t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned int to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="ae8002c29875a226d11ec57a42b5b3955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8002c29875a226d11ec57a42b5b3955">&#9670;&nbsp;</a></span>vec_xfer_vui64t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui64t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned long long to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned long long value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
<a id="a047b7dc5b55b2d13e2fd826c63872ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047b7dc5b55b2d13e2fd826c63872ea9">&#9670;&nbsp;</a></span>vec_xfer_vui8t_2_bin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__f128__ppc_8h.html#a443a43ae34ab3b78564d2a8277503cac">__binary128</a> vec_xfer_vui8t_2_bin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>&#160;</td>
          <td class="paramname"><em>f128</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a vector unsigned char to __binary128 scalar. </p>
<p>The compiler does not allow direct transfer (assignment or type cast) between __binary128 (__float128) scalars and vector types. This despite the fact the the ABI and ISA require __binary128 in vector registers (VRs).</p>
<dl class="section note"><dt>Note</dt><dd>this function uses a union to effect the (logical) transfer. The compiler should not generate any code for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f128</td><td>a vector unsigned char value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value returned as a __binary128 scalar. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 17 2020 17:13:18 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
