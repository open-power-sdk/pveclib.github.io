<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>POWER Vector Library Manual: src/pveclib/vec_common_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3653a864936a87c29f489ec2a5b8be1c.html">pveclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vec_common_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Common definitions and typedef used by the collection of Power Vector Library (pveclib) headers.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;altivec.h&gt;</code><br />
</div>
<p><a href="vec__common__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union____VEC__U__128.html">__VEC_U_128</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union used to transfer 128-bit data between vector and non-vector types.  <a href="union____VEC__U__128.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af4ffb9244d1aa4482b683d35c3544194"><td class="memItemLeft" align="right" valign="top"><a id="af4ffb9244d1aa4482b683d35c3544194"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#af4ffb9244d1aa4482b683d35c3544194">CONST_VINT64_DW</a>(__dw0,  __dw1)&#160;&#160;&#160;{__dw1, __dw0}</td></tr>
<tr class="memdesc:af4ffb9244d1aa4482b683d35c3544194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arrange elements of dword initializer in high-&gt;low order. <br /></td></tr>
<tr class="separator:af4ffb9244d1aa4482b683d35c3544194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed8c282b57705c960542ed869de3325"><td class="memItemLeft" align="right" valign="top"><a id="a9ed8c282b57705c960542ed869de3325"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a9ed8c282b57705c960542ed869de3325">CONST_VINT128_DW</a>(__dw0,  __dw1)&#160;&#160;&#160;(<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>){__dw1, __dw0}</td></tr>
<tr class="memdesc:a9ed8c282b57705c960542ed869de3325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for 128-bits vector, as two unsigned long long elements in high-&gt;low order. May require an explicit cast. <br /></td></tr>
<tr class="separator:a9ed8c282b57705c960542ed869de3325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562dba1b4daf1f8ecb38841ec38c9b4d"><td class="memItemLeft" align="right" valign="top"><a id="a562dba1b4daf1f8ecb38841ec38c9b4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a562dba1b4daf1f8ecb38841ec38c9b4d">CONST_VINT128_DW128</a>(__dw0,  __dw1)&#160;&#160;&#160;(<a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>)((<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>){__dw1, __dw0})</td></tr>
<tr class="memdesc:a562dba1b4daf1f8ecb38841ec38c9b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector unsigned __int128 initializer, as two unsigned long long elements in high-&gt;low order. <br /></td></tr>
<tr class="separator:a562dba1b4daf1f8ecb38841ec38c9b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4520a89b9b5a292a3e647a6d5b712ad"><td class="memItemLeft" align="right" valign="top"><a id="ae4520a89b9b5a292a3e647a6d5b712ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a>(__w0,  __w1,  __w2,  __w3)&#160;&#160;&#160;(<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>){__w3, __w2, __w1, __w0}</td></tr>
<tr class="memdesc:ae4520a89b9b5a292a3e647a6d5b712ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arrange word elements of a unsigned int initializer in high-&gt;low order. May require an explicit cast. <br /></td></tr>
<tr class="separator:ae4520a89b9b5a292a3e647a6d5b712ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e03d3eaeafea2c6613233fd58f98ec1"><td class="memItemLeft" align="right" valign="top"><a id="a7e03d3eaeafea2c6613233fd58f98ec1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a7e03d3eaeafea2c6613233fd58f98ec1">CONST_VINT32_W</a>(__w0,  __w1,  __w2,  __w3)&#160;&#160;&#160;{__w3, __w2, __w1, __w0}</td></tr>
<tr class="memdesc:a7e03d3eaeafea2c6613233fd58f98ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arrange elements of word initializer in high-&gt;low order. <br /></td></tr>
<tr class="separator:a7e03d3eaeafea2c6613233fd58f98ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce8985f81cfb37c2bc3f9900dddd51"><td class="memItemLeft" align="right" valign="top"><a id="a63ce8985f81cfb37c2bc3f9900dddd51"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a63ce8985f81cfb37c2bc3f9900dddd51">CONST_VINT128_H</a>(__hw0,  __hw1,  __hw2,  __hw3,  __hw4,  __hw5,  __hw6,  __hw7)&#160;&#160;&#160;(<a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a>){__hw7, __hw6, __hw5, __hw4, __hw3, __hw2, __hw1, __hw0}</td></tr>
<tr class="memdesc:a63ce8985f81cfb37c2bc3f9900dddd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arrange halfword elements of a unsigned int initializer in high-&gt;low order. May require an explicit cast. <br /></td></tr>
<tr class="separator:a63ce8985f81cfb37c2bc3f9900dddd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b39d3ef7e2d5321449f6f2ab2a51b2"><td class="memItemLeft" align="right" valign="top"><a id="a31b39d3ef7e2d5321449f6f2ab2a51b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a31b39d3ef7e2d5321449f6f2ab2a51b2">CONST_VINT16_H</a>(__hw0,  __hw1,  __hw2,  __hw3,  __hw4,  __hw5,  __hw6,  __hw7)&#160;&#160;&#160;{__hw7, __hw6, __hw5, __hw4, __hw3, __hw2, __hw1, __hw0}</td></tr>
<tr class="memdesc:a31b39d3ef7e2d5321449f6f2ab2a51b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arrange elements of halfword initializer in high-&gt;low order. <br /></td></tr>
<tr class="separator:a31b39d3ef7e2d5321449f6f2ab2a51b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47803d5079cc714a1524f4cd2a05ef72"><td class="memItemLeft" align="right" valign="top"><a id="a47803d5079cc714a1524f4cd2a05ef72"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a47803d5079cc714a1524f4cd2a05ef72">CONST_VINT128_B</a>(_b0,  _b1,  _b2,  _b3,  _b4,  _b5,  _b6,  _b7,  _b8,  _b9,  _b10,  _b11,  _b12,  _b13,  _b14,  _b15)&#160;&#160;&#160;(<a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>){_b15, _b14, _b13, _b12, _b11, _b10, _b9, _b8, _b7, _b6, _b5, _b4, _b3, _b2, _b1, _b0}</td></tr>
<tr class="memdesc:a47803d5079cc714a1524f4cd2a05ef72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arrange byte elements of a unsigned int initializer in high-&gt;low order. May require an explicit cast. <br /></td></tr>
<tr class="separator:a47803d5079cc714a1524f4cd2a05ef72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ff90cc45d590754b2403af4d014d7c"><td class="memItemLeft" align="right" valign="top"><a id="af5ff90cc45d590754b2403af4d014d7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#af5ff90cc45d590754b2403af4d014d7c">CONST_VINT8_B</a>(_b0,  _b1,  _b2,  _b3,  _b4,  _b5,  _b6,  _b7,  _b8,  _b9,  _b10,  _b11,  _b12,  _b13,  _b14,  _b15)&#160;&#160;&#160;{_b15, _b14, _b13, _b12, _b11, _b10, _b9, _b8, _b7, _b6, _b5, _b4, _b3, _b2, _b1, _b0}</td></tr>
<tr class="memdesc:af5ff90cc45d590754b2403af4d014d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arrange elements of byte initializer in high-&gt;low order. <br /></td></tr>
<tr class="separator:af5ff90cc45d590754b2403af4d014d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2bc7bad8fc5c335244ac6f877f3c8f"><td class="memItemLeft" align="right" valign="top"><a id="adb2bc7bad8fc5c335244ac6f877f3c8f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#adb2bc7bad8fc5c335244ac6f877f3c8f">VEC_DW_H</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:adb2bc7bad8fc5c335244ac6f877f3c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for high order dword. <br /></td></tr>
<tr class="separator:adb2bc7bad8fc5c335244ac6f877f3c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8b8de825b673b53cd50458dfc6efa8"><td class="memItemLeft" align="right" valign="top"><a id="a9d8b8de825b673b53cd50458dfc6efa8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a9d8b8de825b673b53cd50458dfc6efa8">VEC_DW_L</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a9d8b8de825b673b53cd50458dfc6efa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for low order dword. <br /></td></tr>
<tr class="separator:a9d8b8de825b673b53cd50458dfc6efa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47854cd0a31b62fe1ebf0d77ccb7c854"><td class="memItemLeft" align="right" valign="top"><a id="a47854cd0a31b62fe1ebf0d77ccb7c854"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a47854cd0a31b62fe1ebf0d77ccb7c854">VEC_W_H</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a47854cd0a31b62fe1ebf0d77ccb7c854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for highest order word. <br /></td></tr>
<tr class="separator:a47854cd0a31b62fe1ebf0d77ccb7c854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb30510341c41500fc4fab3268cfec7"><td class="memItemLeft" align="right" valign="top"><a id="aafb30510341c41500fc4fab3268cfec7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#aafb30510341c41500fc4fab3268cfec7">VEC_W_L</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aafb30510341c41500fc4fab3268cfec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for lowest order word. <br /></td></tr>
<tr class="separator:aafb30510341c41500fc4fab3268cfec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c9ef3ba2f2c2a8b33f4f4459bbd2aa"><td class="memItemLeft" align="right" valign="top"><a id="aa4c9ef3ba2f2c2a8b33f4f4459bbd2aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#aa4c9ef3ba2f2c2a8b33f4f4459bbd2aa">VEC_WE_0</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:aa4c9ef3ba2f2c2a8b33f4f4459bbd2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for vector splat word 0. <br /></td></tr>
<tr class="separator:aa4c9ef3ba2f2c2a8b33f4f4459bbd2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbf2bc0426544f7d64ce84da322a919"><td class="memItemLeft" align="right" valign="top"><a id="a0cbf2bc0426544f7d64ce84da322a919"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a0cbf2bc0426544f7d64ce84da322a919">VEC_WE_1</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a0cbf2bc0426544f7d64ce84da322a919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for vector splat word 1. <br /></td></tr>
<tr class="separator:a0cbf2bc0426544f7d64ce84da322a919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad739666851dfec6cc520c2ee06fd5d41"><td class="memItemLeft" align="right" valign="top"><a id="ad739666851dfec6cc520c2ee06fd5d41"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#ad739666851dfec6cc520c2ee06fd5d41">VEC_WE_2</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ad739666851dfec6cc520c2ee06fd5d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for vector splat word 2. <br /></td></tr>
<tr class="separator:ad739666851dfec6cc520c2ee06fd5d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3504d2f86f03f90239a3196da3b3de"><td class="memItemLeft" align="right" valign="top"><a id="abf3504d2f86f03f90239a3196da3b3de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#abf3504d2f86f03f90239a3196da3b3de">VEC_WE_3</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:abf3504d2f86f03f90239a3196da3b3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for vector splat word 3. <br /></td></tr>
<tr class="separator:abf3504d2f86f03f90239a3196da3b3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a067a69e501014d68d003ac4e11d9fd"><td class="memItemLeft" align="right" valign="top"><a id="a7a067a69e501014d68d003ac4e11d9fd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a7a067a69e501014d68d003ac4e11d9fd">VEC_HW_H</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:a7a067a69e501014d68d003ac4e11d9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for highest order hword. <br /></td></tr>
<tr class="separator:a7a067a69e501014d68d003ac4e11d9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552c48e130cb4f52febd337c6b7a3bc0"><td class="memItemLeft" align="right" valign="top"><a id="a552c48e130cb4f52febd337c6b7a3bc0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a552c48e130cb4f52febd337c6b7a3bc0">VEC_HW_L_DWH</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a552c48e130cb4f52febd337c6b7a3bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for lowest order hword of the high dword. <br /></td></tr>
<tr class="separator:a552c48e130cb4f52febd337c6b7a3bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8084f0958a53a6de32969cf234c8ceae"><td class="memItemLeft" align="right" valign="top"><a id="a8084f0958a53a6de32969cf234c8ceae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a8084f0958a53a6de32969cf234c8ceae">VEC_HW_L</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a8084f0958a53a6de32969cf234c8ceae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for lowest order hword. <br /></td></tr>
<tr class="separator:a8084f0958a53a6de32969cf234c8ceae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1a7749d270995baf9eaae078578961"><td class="memItemLeft" align="right" valign="top"><a id="a9d1a7749d270995baf9eaae078578961"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a9d1a7749d270995baf9eaae078578961">VEC_BYTE_L</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a9d1a7749d270995baf9eaae078578961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for lowest order byte. <br /></td></tr>
<tr class="separator:a9d1a7749d270995baf9eaae078578961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d03d7703dc659a4364011b4d00ce22"><td class="memItemLeft" align="right" valign="top"><a id="ab4d03d7703dc659a4364011b4d00ce22"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#ab4d03d7703dc659a4364011b4d00ce22">VEC_BYTE_L_DWH</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ab4d03d7703dc659a4364011b4d00ce22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for lowest order byte of the high dword. <br /></td></tr>
<tr class="separator:ab4d03d7703dc659a4364011b4d00ce22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e778d7d25175af10ba540baa1592ced"><td class="memItemLeft" align="right" valign="top"><a id="a6e778d7d25175af10ba540baa1592ced"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a6e778d7d25175af10ba540baa1592ced">VEC_BYTE_L_DWL</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a6e778d7d25175af10ba540baa1592ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for lowest order byte of the low dword. <br /></td></tr>
<tr class="separator:a6e778d7d25175af10ba540baa1592ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3975205947785b1745a791ef12256e9a"><td class="memItemLeft" align="right" valign="top"><a id="a3975205947785b1745a791ef12256e9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a3975205947785b1745a791ef12256e9a">VEC_BYTE_H</a>&#160;&#160;&#160;15</td></tr>
<tr class="memdesc:a3975205947785b1745a791ef12256e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for highest order byte. <br /></td></tr>
<tr class="separator:a3975205947785b1745a791ef12256e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b36d047166859c0f7fabe4b7c131ad"><td class="memItemLeft" align="right" valign="top"><a id="aa2b36d047166859c0f7fabe4b7c131ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#aa2b36d047166859c0f7fabe4b7c131ad">VEC_BYTE_HHW</a>&#160;&#160;&#160;14</td></tr>
<tr class="memdesc:aa2b36d047166859c0f7fabe4b7c131ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element index for second lowest order byte. <br /></td></tr>
<tr class="separator:aa2b36d047166859c0f7fabe4b7c131ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aed458e4755a6589049b936cf9f24f6f8"><td class="memItemLeft" align="right" valign="top"><a id="aed458e4755a6589049b936cf9f24f6f8"></a>
typedef __vector unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a></td></tr>
<tr class="memdesc:aed458e4755a6589049b936cf9f24f6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 8-bit unsigned char elements. <br /></td></tr>
<tr class="separator:aed458e4755a6589049b936cf9f24f6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb47075b07673afbf78f8c60298f3712"><td class="memItemLeft" align="right" valign="top"><a id="afb47075b07673afbf78f8c60298f3712"></a>
typedef __vector unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#afb47075b07673afbf78f8c60298f3712">vui16_t</a></td></tr>
<tr class="memdesc:afb47075b07673afbf78f8c60298f3712"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 16-bit unsigned short elements. <br /></td></tr>
<tr class="separator:afb47075b07673afbf78f8c60298f3712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff4a776536870e01b7c9e454586544b"><td class="memItemLeft" align="right" valign="top"><a id="a2ff4a776536870e01b7c9e454586544b"></a>
typedef __vector unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></td></tr>
<tr class="memdesc:a2ff4a776536870e01b7c9e454586544b"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 32-bit unsigned int elements. <br /></td></tr>
<tr class="separator:a2ff4a776536870e01b7c9e454586544b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a773b6353c69a546bdc2e8686a50ec"><td class="memItemLeft" align="right" valign="top"><a id="a52a773b6353c69a546bdc2e8686a50ec"></a>
typedef __vector unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a></td></tr>
<tr class="memdesc:a52a773b6353c69a546bdc2e8686a50ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 64-bit unsigned long long elements. <br /></td></tr>
<tr class="separator:a52a773b6353c69a546bdc2e8686a50ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748bbf6563e6ab1ddcb694c86e2aaef4"><td class="memItemLeft" align="right" valign="top"><a id="a748bbf6563e6ab1ddcb694c86e2aaef4"></a>
typedef __vector signed char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a748bbf6563e6ab1ddcb694c86e2aaef4">vi8_t</a></td></tr>
<tr class="memdesc:a748bbf6563e6ab1ddcb694c86e2aaef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 8-bit signed char elements. <br /></td></tr>
<tr class="separator:a748bbf6563e6ab1ddcb694c86e2aaef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873846dd078cef3d766814d856760526"><td class="memItemLeft" align="right" valign="top"><a id="a873846dd078cef3d766814d856760526"></a>
typedef __vector short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a873846dd078cef3d766814d856760526">vi16_t</a></td></tr>
<tr class="memdesc:a873846dd078cef3d766814d856760526"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 16-bit signed short elements. <br /></td></tr>
<tr class="separator:a873846dd078cef3d766814d856760526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5717f56a3dac6980206dbd37614ca2"><td class="memItemLeft" align="right" valign="top"><a id="adf5717f56a3dac6980206dbd37614ca2"></a>
typedef __vector int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a></td></tr>
<tr class="memdesc:adf5717f56a3dac6980206dbd37614ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 32-bit signed int elements. <br /></td></tr>
<tr class="separator:adf5717f56a3dac6980206dbd37614ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3abdfe41178c152e0a2130c20476ff"><td class="memItemLeft" align="right" valign="top"><a id="a0c3abdfe41178c152e0a2130c20476ff"></a>
typedef __vector long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a></td></tr>
<tr class="memdesc:a0c3abdfe41178c152e0a2130c20476ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 64-bit signed long long elements. <br /></td></tr>
<tr class="separator:a0c3abdfe41178c152e0a2130c20476ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f1382a0cb269770bbb8387dfcbbe1c"><td class="memItemLeft" align="right" valign="top"><a id="a18f1382a0cb269770bbb8387dfcbbe1c"></a>
typedef __vector float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a></td></tr>
<tr class="memdesc:a18f1382a0cb269770bbb8387dfcbbe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 32-bit float elements. <br /></td></tr>
<tr class="separator:a18f1382a0cb269770bbb8387dfcbbe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cccc22e004bddbb80a51117c448675"><td class="memItemLeft" align="right" valign="top"><a id="ae5cccc22e004bddbb80a51117c448675"></a>
typedef __vector double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#ae5cccc22e004bddbb80a51117c448675">vf64_t</a></td></tr>
<tr class="memdesc:ae5cccc22e004bddbb80a51117c448675"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 64-bit double elements. <br /></td></tr>
<tr class="separator:ae5cccc22e004bddbb80a51117c448675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d921b672d847662016cb3cbbe58f17"><td class="memItemLeft" align="right" valign="top"><a id="ab6d921b672d847662016cb3cbbe58f17"></a>
typedef __vector __bool char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#ab6d921b672d847662016cb3cbbe58f17">vb8_t</a></td></tr>
<tr class="memdesc:ab6d921b672d847662016cb3cbbe58f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 8-bit bool char elements. <br /></td></tr>
<tr class="separator:ab6d921b672d847662016cb3cbbe58f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49894941283fbeab49715155872a55d1"><td class="memItemLeft" align="right" valign="top"><a id="a49894941283fbeab49715155872a55d1"></a>
typedef __vector __bool short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a49894941283fbeab49715155872a55d1">vb16_t</a></td></tr>
<tr class="memdesc:a49894941283fbeab49715155872a55d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 16-bit bool short elements. <br /></td></tr>
<tr class="separator:a49894941283fbeab49715155872a55d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafeddf1e79ef817440ff01fafb0e00ca"><td class="memItemLeft" align="right" valign="top"><a id="aafeddf1e79ef817440ff01fafb0e00ca"></a>
typedef __vector __bool int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a></td></tr>
<tr class="memdesc:aafeddf1e79ef817440ff01fafb0e00ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 32-bit bool int elements. <br /></td></tr>
<tr class="separator:aafeddf1e79ef817440ff01fafb0e00ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee93592cb008b78c17e85d1eaa3419e1"><td class="memItemLeft" align="right" valign="top"><a id="aee93592cb008b78c17e85d1eaa3419e1"></a>
typedef __vector __bool long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#aee93592cb008b78c17e85d1eaa3419e1">vb64_t</a></td></tr>
<tr class="memdesc:aee93592cb008b78c17e85d1eaa3419e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of 64-bit bool long long elements. <br /></td></tr>
<tr class="separator:aee93592cb008b78c17e85d1eaa3419e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2bbf9f23490ccca3bdc08bc1dc7831"><td class="memItemLeft" align="right" valign="top"><a id="a3b2bbf9f23490ccca3bdc08bc1dc7831"></a>
typedef __vector __int128&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a3b2bbf9f23490ccca3bdc08bc1dc7831">vi128_t</a></td></tr>
<tr class="memdesc:a3b2bbf9f23490ccca3bdc08bc1dc7831"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of one 128-bit signed __int128 element. <br /></td></tr>
<tr class="separator:a3b2bbf9f23490ccca3bdc08bc1dc7831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7a8e92d8ba681dac3d2ec3259c0820"><td class="memItemLeft" align="right" valign="top"><a id="aaf7a8e92d8ba681dac3d2ec3259c0820"></a>
typedef __vector unsigned __int128&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a></td></tr>
<tr class="memdesc:aaf7a8e92d8ba681dac3d2ec3259c0820"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of one 128-bit unsigned __int128 element. <br /></td></tr>
<tr class="separator:aaf7a8e92d8ba681dac3d2ec3259c0820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cdf519bbbf190c311bd27d3e254208"><td class="memItemLeft" align="right" valign="top"><a id="a16cdf519bbbf190c311bd27d3e254208"></a>
typedef __vector __bool __int128&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a16cdf519bbbf190c311bd27d3e254208">vb128_t</a></td></tr>
<tr class="memdesc:a16cdf519bbbf190c311bd27d3e254208"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of one 128-bit bool __int128 element. <br /></td></tr>
<tr class="separator:a16cdf519bbbf190c311bd27d3e254208"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9edd75ea323ebad73771ecd346a3cf5a"><td class="memItemLeft" align="right" valign="top"><a id="a9edd75ea323ebad73771ecd346a3cf5a"></a>
const <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a9edd75ea323ebad73771ecd346a3cf5a">vtipowof10</a> []</td></tr>
<tr class="memdesc:a9edd75ea323ebad73771ecd346a3cf5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">table powers of 10 [0-38] in vector __int128 format. <br /></td></tr>
<tr class="separator:a9edd75ea323ebad73771ecd346a3cf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa482a8c2f715f1c39f755c86066a7b27"><td class="memItemLeft" align="right" valign="top"><a id="aa482a8c2f715f1c39f755c86066a7b27"></a>
const <a class="el" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#aa482a8c2f715f1c39f755c86066a7b27">vtifrexpof10</a> []</td></tr>
<tr class="memdesc:aa482a8c2f715f1c39f755c86066a7b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">table used to verify 128-bit frexp operations for powers of 10. <br /></td></tr>
<tr class="separator:aa482a8c2f715f1c39f755c86066a7b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0ffb619c4d9904c405e792347b1553"><td class="memItemLeft" align="right" valign="top"><a id="a7b0ffb619c4d9904c405e792347b1553"></a>
const _Decimal128&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__common__ppc_8h.html#a7b0ffb619c4d9904c405e792347b1553">decpowof2</a> []</td></tr>
<tr class="memdesc:a7b0ffb619c4d9904c405e792347b1553"><td class="mdescLeft">&#160;</td><td class="mdescRight">table powers of 2 [0-1077] in _Decimal128 format. <br /></td></tr>
<tr class="separator:a7b0ffb619c4d9904c405e792347b1553"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common definitions and typedef used by the collection of Power Vector Library (pveclib) headers. </p>
<p>This includes:</p><ul>
<li>Typedefs as short names of common vector types.</li>
<li>Union used to transfer 128-bit data between vector and non-vector types.</li>
<li>Helper macros that make declaring constants and accessing elements a little easier.</li>
</ul>
<h1><a class="anchor" id="common_type_naming_0_0"></a>
Consistent vector type naming</h1>
<p>Type names should be short, concise, and consistent. The ABI defines the vector types as extensions of the existing C Language types. So while <em>vector unsigned long long</em> is consistent it is neither short or concise. Pveclib uses the following naming convention for typedefs used in its operations, function prototypes, and internal variables.</p><ul>
<li>Starting with the <b>v</b> prefix for vector.</li>
<li>followed by one of the element classes:<ul>
<li><b>i</b> for signed integer.</li>
<li><b>ui</b> for unsigned integer.</li>
<li><b>f</b> for floating-point.</li>
<li><b>b</b> for bool.</li>
</ul>
</li>
<li>followed by the element size in bits:<ul>
<li>8, 16, 32, 64, 128</li>
</ul>
</li>
<li>Ending with the <b>_t</b> suffix signifying a typedef.</li>
</ul>
<p>For example: <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> is a vector int, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> is a vector unsigned int, <a class="el" href="vec__common__ppc_8h.html#aafeddf1e79ef817440ff01fafb0e00ca">vb32_t</a> is a vector bool int, and <a class="el" href="vec__common__ppc_8h.html#a18f1382a0cb269770bbb8387dfcbbe1c">vf32_t</a> is vector float.</p>
<h1><a class="anchor" id="common_type_xfer_0_0"></a>
Transferring 128-bit types</h1>
<p>The OpenPOWER ABI and the GCC compiler define a number of 128-bit scalar types that are not vector types:</p><ul>
<li>__int128 (a general purpose register pair)</li>
<li>_Decimal128 (a floating-point even/odd register pair)</li>
<li>__ibm128 (a floating-point register pair)</li>
<li>__float128 (a vector register)</li>
</ul>
<p>These are not cast nor assignment compatible with any vector type. However it may be useful to transfer to/from vector types for conversion or manipulation within an operation. For example:</p><ul>
<li>Conversions between __float128 and __int128, __ibm128, and _Decimal128 types.</li>
<li>Conversions between vector BCD integers and __int128 and _Decimal128 types.</li>
<li>Conversions between vector __int128 and __float128, __ibm128, and _Decimal128 types.</li>
</ul>
<p>Here we use the <a class="el" href="union____VEC__U__128.html" title="Union used to transfer 128-bit data between vector and non-vector types. ">__VEC_U_128</a> union to affect the transfer between the various types. We assume (fervently hope) that the compiler will recognize and optimize these as registers to registers transfers using the hardware instructions provided.</p>
<p>The vector to/from __float128 transfer should be the simplest as __float128 operations are defined over the vector register set. However __float128 types are defined in the PowerISA and OpenPOWER ABI, as scalars that just happens to use vector registers for parameter passing and operations. This distinction between scalars and vector prevents a direct cast between types. The <a class="el" href="union____VEC__U__128.html" title="Union used to transfer 128-bit data between vector and non-vector types. ">__VEC_U_128</a> union is the simplest work around but in most cases no code should generated for this transfer. For example: <a class="el" href="vec__f128__ppc_8h.html#aec6e44a75847d3d3e5611b89eed71c0a" title="Transfer function from a __binary128 scalar to a vector __int128. ">vec_xfer_bin128_2_vui128t()</a> and <a class="el" href="vec__f128__ppc_8h.html#a91b99b632646aaca91de6834e2b1da26" title="Transfer a vector unsigned __int128 to __binary128 scalar. ">vec_xfer_vui128t_2_bin128()</a>.</p>
<p>Any vector to/from __int128 transfer requires a transfer between vector and general purpose registers. POWER8 (PowerISA 2.07B) added Move to/from Vector Scalar Register (mfvsr, mtvsr) instructions. Again the <a class="el" href="union____VEC__U__128.html" title="Union used to transfer 128-bit data between vector and non-vector types. ">__VEC_U_128</a> union is used to effect the transfer and the compiler should leverage the move instructions in the generated code.</p>
<p>Any vector to/from __ibm128 or _Decimal128 requires a transfer between a pair of FPRs and a Vector Scalar Register (VSR). Technically this is transfer between the upper doubleword of two VSRs in the lower bank (VSR0-31) and another VSR. POWER7 (PowerISA 2.06B) provides the Permute Doubleword Immediate (xxpermdi) instruction. Again the <a class="el" href="union____VEC__U__128.html" title="Union used to transfer 128-bit data between vector and non-vector types. ">__VEC_U_128</a> union is used to effect the transfer and the compiler should leverage the Permute Doubleword Immediate instructions in the generate code. For example: <a class="el" href="vec__bcd__ppc_8h.html#aa924d03e2f88506e323c4b70f4b7df8b" title="Convert a Vector Signed BCD value to __Decimal128. ">vec_BCD2DFP()</a> and <a class="el" href="vec__bcd__ppc_8h.html#ad8123fa00f666a0d439a049eb4f7c7eb" title="Convert a __Decimal128 value to Vector BCD. ">vec_DFP2BCD()</a>.</p>
<h1><a class="anchor" id="common_endian_issues_0_0"></a>
Endian and vector constants</h1>
<p>Vector constants are often needed for: masking operations, range checks, permute selection, and radix conversion. Also compiler support for large integer and floating-point constants may be limited by the compiler. For example the GCC compilers support the (vector) __int128 type but do not directly support __int128 (39 digit) decimal constants. Another example is __float128 where the type and Q suffix constants are recent additions. In both cases we need to construct: large numeric constants, special values (infinity and NaN), masks for manipulating the sign bit and exponent bits. Often these values will be constructed from vectors of word or doubleword constants.</p>
<dl class="section note"><dt>Note</dt><dd>GCC does not support expressing an integer constant of type __int128 for targets where long long integer is less than 128 bits wide. This applies to the PowerPC target as the long long type is reserved for 64-bit integers. This was verified in GCC 8.2,</dd>
<dd>
GCC __float128 support for the PowerPC target began with GCC 6. In GCC 6 __float128 support is off by default and has to be explicitly enabled via the '-mfloat128' option. Starting with GCC 7, __float128 is enabled by default with VSX support.</dd></dl>
<p>Defining large constants for vectors is complicated by <em>little-endian</em> (LE) support as specified in the OpenPOWER ABI and as implemented in the compilers. Little-endian changes the effective vector element numbering and the order of constant elements in initializers. But the __int128 numerical order of magnitude or floating-point format does not change in registers. The high order bits are on the left and the low order bits are on the right.</p>
<p>So for example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = { 0x80000000, 0, 0, 0 };</div><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask = { 0x7fff0000, 0, 0, 0 };</div></div><!-- fragment --><p> are correct sign and exponent masks for __float128 in big endian (BE) but would be incorrect for little endian (LE). To get correct results for both endians, one could code something like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = { 0, 0, 0, 0x80000000 };</div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask = { 0, 0, 0, 0x7fff0000 };</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = { 0x80000000, 0, 0, 0 };</div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask = { 0x7fff0000, 0, 0, 0 };</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p> But this gets tedious after the first dozen times. Also this can be confusing because it does not appear to the match the floating-point format diagrams in the PowerISA. The sign-bit and the exponent are always on the left.</p>
<p>So this header provides endian sensitive macros that maintain consistent "magnitude" order. For example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> signmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x80000000, 0, 0, 0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> expmask = <a class="code" href="vec__common__ppc_8h.html#ae4520a89b9b5a292a3e647a6d5b712ad">CONST_VINT128_W</a> (0x7fff0000, 0, 0, 0);</div></div><!-- fragment --><p> This is always correct in either endian.</p>
<p>Another example; the multiplicative inverse for __int128 10**32 is 211857340822306639531405861550393824741. The GCC compiler will not accept this constant in a vector __int128 initializer. The next best thing would be </p><div class="fragment"><div class="line"><span class="comment">// The multiplicative inverse for 1 / 10**32 is</span></div><div class="line"><span class="comment">// 211857340822306639531405861550393824741</span></div><div class="line"><span class="comment">// or 0x9f623d5a8a732974cfbc31db4b0295e5</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a> mulinv_10to32 =</div><div class="line">         (<a class="code" href="vec__common__ppc_8h.html#aaf7a8e92d8ba681dac3d2ec3259c0820">vui128_t</a>) <a class="code" href="vec__common__ppc_8h.html#a562dba1b4daf1f8ecb38841ec38c9b4d">CONST_VINT128_DW128</a> ( 0x9f623d5a8a732974UL,</div><div class="line">                                          0xcfbc31db4b0295e5UL );</div></div><!-- fragment --><p> Here we use the CONST_VINT128_DW128 macro to maintain magnitude order across endian. Again the high order bits are on the left and the low order bits are on the right.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vec__int32__ppc_8h.html#i32_endian_issues_0_0">Endian problems with word operations</a> </dd>
<dd>
<a class="el" href="index.html#mainpage_endian_issues_1_1">General Endian Issues</a> </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 17 2020 17:13:18 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
