<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>POWER Vector Library Manual: src/pveclib/vec_int32_ppc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">POWER Vector Library Manual
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3653a864936a87c29f489ec2a5b8be1c.html">pveclib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec_int32_ppc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header package containing a collection of 128-bit SIMD operations over 32-bit integer elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="vec__int16__ppc_8h_source.html">pveclib/vec_int16_ppc.h</a>&gt;</code><br />
</div>
<p><a href="vec__int32__ppc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a85ec15f292163e0e40e6faa5f4797367"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a85ec15f292163e0e40e6faa5f4797367">vec_absduw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:a85ec15f292163e0e40e6faa5f4797367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Absolute Difference Unsigned Word.  <a href="#a85ec15f292163e0e40e6faa5f4797367">More...</a><br /></td></tr>
<tr class="separator:a85ec15f292163e0e40e6faa5f4797367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe65a777f2b75022ae584f76d0a2777"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#afbe65a777f2b75022ae584f76d0a2777">vec_clzw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra)</td></tr>
<tr class="memdesc:afbe65a777f2b75022ae584f76d0a2777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Count Leading Zeros word.  <a href="#afbe65a777f2b75022ae584f76d0a2777">More...</a><br /></td></tr>
<tr class="separator:afbe65a777f2b75022ae584f76d0a2777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d39dc4278a5e0711e9109746b23f2c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a0d39dc4278a5e0711e9109746b23f2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Algebraic High Words.  <a href="#a0d39dc4278a5e0711e9109746b23f2c7">More...</a><br /></td></tr>
<tr class="separator:a0d39dc4278a5e0711e9109746b23f2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4107474cdf1907051de84ea063417911"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a4107474cdf1907051de84ea063417911">vec_mrgalw</a> (<a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</td></tr>
<tr class="memdesc:a4107474cdf1907051de84ea063417911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector merge Algebraic low words.  <a href="#a4107474cdf1907051de84ea063417911">More...</a><br /></td></tr>
<tr class="separator:a4107474cdf1907051de84ea063417911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67359d6f4003fcb7cca8ed1b64b7cf4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ab67359d6f4003fcb7cca8ed1b64b7cf4">vec_mrgew</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:ab67359d6f4003fcb7cca8ed1b64b7cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Even Words.  <a href="#ab67359d6f4003fcb7cca8ed1b64b7cf4">More...</a><br /></td></tr>
<tr class="separator:ab67359d6f4003fcb7cca8ed1b64b7cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10a13aa644282aa60dcbfbd8b02f0bc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#af10a13aa644282aa60dcbfbd8b02f0bc">vec_mrgow</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:af10a13aa644282aa60dcbfbd8b02f0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Merge Odd Words.  <a href="#af10a13aa644282aa60dcbfbd8b02f0bc">More...</a><br /></td></tr>
<tr class="separator:af10a13aa644282aa60dcbfbd8b02f0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7b91bf6138d029d9d8cc57b0905f1f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#add7b91bf6138d029d9d8cc57b0905f1f">vec_mulesw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> b)</td></tr>
<tr class="memdesc:add7b91bf6138d029d9d8cc57b0905f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiply even signed words.  <a href="#add7b91bf6138d029d9d8cc57b0905f1f">More...</a><br /></td></tr>
<tr class="separator:add7b91bf6138d029d9d8cc57b0905f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415942bd7b8183634e44e56b6a40101b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a415942bd7b8183634e44e56b6a40101b">vec_mulosw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> b)</td></tr>
<tr class="memdesc:a415942bd7b8183634e44e56b6a40101b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiply odd signed words.  <a href="#a415942bd7b8183634e44e56b6a40101b">More...</a><br /></td></tr>
<tr class="separator:a415942bd7b8183634e44e56b6a40101b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93f07d5ad73243db2771da83b50d6d8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b)</td></tr>
<tr class="memdesc:ac93f07d5ad73243db2771da83b50d6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiply even unsigned words.  <a href="#ac93f07d5ad73243db2771da83b50d6d8">More...</a><br /></td></tr>
<tr class="separator:ac93f07d5ad73243db2771da83b50d6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca45c65b9627abfc493d4ad500a961d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b)</td></tr>
<tr class="memdesc:a3ca45c65b9627abfc493d4ad500a961d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiply odd unsigned words.  <a href="#a3ca45c65b9627abfc493d4ad500a961d">More...</a><br /></td></tr>
<tr class="separator:a3ca45c65b9627abfc493d4ad500a961d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316e9909abc24eb4f9b5d6d29fe64185"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a316e9909abc24eb4f9b5d6d29fe64185">vec_mulhsw</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vrb)</td></tr>
<tr class="memdesc:a316e9909abc24eb4f9b5d6d29fe64185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Signed Word.  <a href="#a316e9909abc24eb4f9b5d6d29fe64185">More...</a><br /></td></tr>
<tr class="separator:a316e9909abc24eb4f9b5d6d29fe64185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094c6adb04c1515361426ad58b0fdbb3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3">vec_mulhuw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:a094c6adb04c1515361426ad58b0fdbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply High Unsigned Word.  <a href="#a094c6adb04c1515361426ad58b0fdbb3">More...</a><br /></td></tr>
<tr class="separator:a094c6adb04c1515361426ad58b0fdbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ea7653d4e60454b91d669e2b1bcfdf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ab3ea7653d4e60454b91d669e2b1bcfdf">vec_muluwm</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b)</td></tr>
<tr class="memdesc:ab3ea7653d4e60454b91d669e2b1bcfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Unsigned Word Modulo.  <a href="#ab3ea7653d4e60454b91d669e2b1bcfdf">More...</a><br /></td></tr>
<tr class="separator:ab3ea7653d4e60454b91d669e2b1bcfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5b81dc628ca80e079a86515e391023"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#acb5b81dc628ca80e079a86515e391023">vec_popcntw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra)</td></tr>
<tr class="memdesc:acb5b81dc628ca80e079a86515e391023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Population Count word.  <a href="#acb5b81dc628ca80e079a86515e391023">More...</a><br /></td></tr>
<tr class="separator:acb5b81dc628ca80e079a86515e391023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d2c7192202e70f52997ab743418a77"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ae4d2c7192202e70f52997ab743418a77">vec_revbw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra)</td></tr>
<tr class="memdesc:ae4d2c7192202e70f52997ab743418a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte reverse each word of a vector unsigned int.  <a href="#ae4d2c7192202e70f52997ab743418a77">More...</a><br /></td></tr>
<tr class="separator:ae4d2c7192202e70f52997ab743418a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500924c8925b336d49b6a5d4307fe14c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a500924c8925b336d49b6a5d4307fe14c">vec_slwi</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:a500924c8925b336d49b6a5d4307fe14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift left Word Immediate.  <a href="#a500924c8925b336d49b6a5d4307fe14c">More...</a><br /></td></tr>
<tr class="separator:a500924c8925b336d49b6a5d4307fe14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb4872afdd52b5ba965856c7e1a58ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#aefb4872afdd52b5ba965856c7e1a58ad">vec_srawi</a> (<a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:aefb4872afdd52b5ba965856c7e1a58ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Algebraic Word Immediate.  <a href="#aefb4872afdd52b5ba965856c7e1a58ad">More...</a><br /></td></tr>
<tr class="separator:aefb4872afdd52b5ba965856c7e1a58ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73a97260ce07b46031e2c8560a5320b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, const unsigned int shb)</td></tr>
<tr class="memdesc:af73a97260ce07b46031e2c8560a5320b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Shift Right Word Immediate.  <a href="#af73a97260ce07b46031e2c8560a5320b">More...</a><br /></td></tr>
<tr class="separator:af73a97260ce07b46031e2c8560a5320b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b046a56d566ec2ea351042fd9dd11de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a1b046a56d566ec2ea351042fd9dd11de">vec_vmadd2euw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> c, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> d)</td></tr>
<tr class="memdesc:a1b046a56d566ec2ea351042fd9dd11de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add2 Even Unsigned Words.  <a href="#a1b046a56d566ec2ea351042fd9dd11de">More...</a><br /></td></tr>
<tr class="separator:a1b046a56d566ec2ea351042fd9dd11de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ab00ed413c1aa1a8148cd9981235bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a40ab00ed413c1aa1a8148cd9981235bf">vec_vmadd2ouw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> c, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> d)</td></tr>
<tr class="memdesc:a40ab00ed413c1aa1a8148cd9981235bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add2 Odd Unsigned Words.  <a href="#a40ab00ed413c1aa1a8148cd9981235bf">More...</a><br /></td></tr>
<tr class="separator:a40ab00ed413c1aa1a8148cd9981235bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e20bdd1df7e3e49dca06d5512ada84b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a1e20bdd1df7e3e49dca06d5512ada84b">vec_vmaddeuw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> c)</td></tr>
<tr class="memdesc:a1e20bdd1df7e3e49dca06d5512ada84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add Even Unsigned Words.  <a href="#a1e20bdd1df7e3e49dca06d5512ada84b">More...</a><br /></td></tr>
<tr class="separator:a1e20bdd1df7e3e49dca06d5512ada84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32acead723b7867ff4c9f8be9bb708ca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a32acead723b7867ff4c9f8be9bb708ca">vec_vmaddouw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> c)</td></tr>
<tr class="memdesc:a32acead723b7867ff4c9f8be9bb708ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Add Odd Unsigned Words.  <a href="#a32acead723b7867ff4c9f8be9bb708ca">More...</a><br /></td></tr>
<tr class="separator:a32acead723b7867ff4c9f8be9bb708ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb37f8c3bb75090db08ab0981249ae7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#a0bb37f8c3bb75090db08ab0981249ae7">vec_vmsumuwm</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> a, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> b, <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> c)</td></tr>
<tr class="memdesc:a0bb37f8c3bb75090db08ab0981249ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply-Sum Unsigned Word Modulo.  <a href="#a0bb37f8c3bb75090db08ab0981249ae7">More...</a><br /></td></tr>
<tr class="separator:a0bb37f8c3bb75090db08ab0981249ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30f226bd27241513f0611b50967a080"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ae30f226bd27241513f0611b50967a080">vec_vmuleuw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:ae30f226bd27241513f0611b50967a080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Even Unsigned words.  <a href="#ae30f226bd27241513f0611b50967a080">More...</a><br /></td></tr>
<tr class="separator:ae30f226bd27241513f0611b50967a080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52349ced57857d20fb5e06b1b09cc05"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec__int32__ppc_8h.html#ae52349ced57857d20fb5e06b1b09cc05">vec_vmulouw</a> (<a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</td></tr>
<tr class="memdesc:ae52349ced57857d20fb5e06b1b09cc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Multiply Odd Unsigned Words.  <a href="#ae52349ced57857d20fb5e06b1b09cc05">More...</a><br /></td></tr>
<tr class="separator:ae52349ced57857d20fb5e06b1b09cc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header package containing a collection of 128-bit SIMD operations over 32-bit integer elements. </p>
<p>Most of these operations are implemented in a single instruction on newer (POWER8/POWER9) processors. This header serves to fill in functional gaps for older (POWER7, POWER8) processors and provides a in-line assembler implementation for older compilers that do not provide the build-ins.</p>
<p>Most vector int (32-bit integer word) operations are implemented with PowerISA VMX instructions either defined by the original VMX (AKA Altivec) or added to later versions of the PowerISA. Vector word-wise merge, shift, and splat operations were added with VSX in PowerISA 2.06B (POWER7). PowerISA 2.07B (POWER8) added several useful word wise operations (multiply, merge even/odd, count leading zeros, population count) not included in the original VMX. PowerISA 3.0B (POWER9) adds several more (compare not equal, count trailing zeros, extend sign, extract/insert, and parity). Most of these intrinsic (compiler built-ins) operations are defined in &lt;altivec.h&gt; and described in the compiler documentation.</p>
<dl class="section note"><dt>Note</dt><dd>The compiler disables associated &lt;altivec.h&gt; built-ins if the <b>mcpu</b> target does not enable the specific instruction. For example if you compile with <b>-mcpu=power7</b>, vec_vclz and vec_vclzw will not be defined. Another example if you compile with <b>-mcpu=power8</b>, vec_revb will not be defined. This header provides the appropriate substitutions, will generate the minimum code, appropriate for the target, and produce correct results.</dd>
<dd>
Most ppc64le compilers will default to -mcpu=power8 if not specified.</dd></dl>
<p>The newly introduced vector operations imply some useful composite operations. For example, we can make the vector multiply even/odd/modulo word operations available for older compilers. And provide implementations for older (POWER7 and earlier) processors using the original VMX operations.</p>
<p>This header covers operations that are either:</p>
<ul>
<li>Implemented in hardware instructions for later processors and useful to programmers, on slightly older processors, even if the equivalent function requires more instructions. Examples include the multiply even/odd/modulo word operations.</li>
<li>Defined in the OpenPOWER ABI but <em>not</em> yet defined in &lt;altivec.h&gt; provided by available compilers in common use. Examples include Count Leading Zeros, Population Count and Byte Reverse.</li>
<li>Commonly used operations, not covered by the ABI or &lt;altivec.h&gt;, and require multiple instructions or are not obvious. Examples include the shift immediate, merge algebraic high/low, and multiply high operations.</li>
</ul>
<h1><a class="anchor" id="i32_recent_additions"></a>
Recent Additions</h1>
<p>Added <a class="el" href="vec__int32__ppc_8h.html#a1e20bdd1df7e3e49dca06d5512ada84b" title="Vector Multiply-Add Even Unsigned Words. ">vec_vmaddeuw()</a>, <a class="el" href="vec__int32__ppc_8h.html#a32acead723b7867ff4c9f8be9bb708ca" title="Vector Multiply-Add Odd Unsigned Words. ">vec_vmaddouw()</a>, <a class="el" href="vec__int32__ppc_8h.html#a1b046a56d566ec2ea351042fd9dd11de" title="Vector Multiply-Add2 Even Unsigned Words. ">vec_vmadd2euw()</a>, and <a class="el" href="vec__int32__ppc_8h.html#a40ab00ed413c1aa1a8148cd9981235bf" title="Vector Multiply-Add2 Odd Unsigned Words. ">vec_vmadd2ouw()</a> as an optimization for the vector multiply quadword implementations on POWER8.</p>
<h1><a class="anchor" id="i32_endian_issues_0_0"></a>
Endian problems with word operations</h1>
<p>It would be useful to provide a vector multiply high word (return the high order 32-bits of the 64-bit product) operation. This can be used for multiplicative inverse (effectively integer divide) operations. Neither integer multiply high nor divide are available as vector instructions. However the multiply high word operation can be composed from the existing multiply even/odd word operations followed by the vector merge even word instruction.</p>
<p>As a prerequisite we need to provide the merge even/odd word operations for older compilers and an implementation for older (POWER7) processors. Fortunately vector merge operations are just a special case of vector permute. So the POWER7 (and earlier) implementation can use vec_perm and appropriate selection vectors to provide these merge operations.</p>
<p>But this is complicated by <em>little-endian</em> (LE) support as specified in the OpenPOWER ABI and as implemented in the compilers. Little-endian changes the effective vector element numbering and the location of even and odd elements. This means that the vector built-ins provided by altivec.h may not generate the instructions you would expect. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#mainpage_endian_issues_1_1">General Endian Issues</a></dd></dl>
<p>The OpenPOWER ABI provides a helpful table of <a href="http://openpowerfoundation.org/wp-content/uploads/resources/leabi/content/dbdoclet.50655244_90667.html">Endian Sensitive Operations</a>. For vec_mergee (vmrgew) it specifies: </p><blockquote class="doxtable">
<p>Swap inputs and use vmrgow, for LE.</p>
</blockquote>
<p>Also for vec_mule (vmuleuw, vmulesw): </p><blockquote class="doxtable">
<p>Replace with vmulouw and so on, for LE.</p>
</blockquote>
<p>Also for vec_perm (vperm) it specifies: </p><blockquote class="doxtable">
<p>For LE, Swap input arguments and complement the selection vector.</p>
</blockquote>
<p>The above is just a sampling of a larger list of Endian Sensitive Operations.</p>
<p>So the obvious coding for Vector Multiply High Word: </p><div class="fragment"><div class="line"><a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div><div class="line">test_mulhw (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> vec_mergee ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vec_mule (vra, vrb),</div><div class="line">                     (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vec_mulo (vra, vrb));</div><div class="line">}</div></div><!-- fragment --><p> Would produce the expected code and correct results when compiled for BE: </p><div class="fragment"><div class="line">&lt;test_mulhw&gt;:</div><div class="line">        vmuleuw v0,v2,v3</div><div class="line">        vmuluuw v2,v2,v3</div><div class="line">        vmrgew  v2,v0,v2</div><div class="line">        blr</div></div><!-- fragment --><p> But the following and wrong code for LE: </p><div class="fragment"><div class="line">&lt;test_mulhw&gt;:</div><div class="line">        vmulouw v0,v2,v3</div><div class="line">        vmuleuw v2,v2,v3</div><div class="line">        vmrgow  v2,v2,v0</div><div class="line">        blr</div></div><!-- fragment --><p> The compiler swapped the multiplies even for odd and odd of even. That is somewhat mitigated by swapping the input arguments in the merge. But changing the merge from even to odd actually returns the low order 32-bits of the product. This is not the correct result for multiply high.</p>
<p>This header provides implementations of vector merge even/odd word (<a class="el" href="vec__int32__ppc_8h.html#ab67359d6f4003fcb7cca8ed1b64b7cf4" title="Vector Merge Even Words. ">vec_mrgew()</a> and <a class="el" href="vec__int32__ppc_8h.html#af10a13aa644282aa60dcbfbd8b02f0bc" title="Vector Merge Odd Words. ">vec_mrgow()</a>) that support older compilers and older (POWER7) processor. Similarly for the multiply Even/odd unsigned/signed word instructions (<a class="el" href="vec__int32__ppc_8h.html#add7b91bf6138d029d9d8cc57b0905f1f" title="Vector multiply even signed words. ">vec_mulesw()</a>, <a class="el" href="vec__int32__ppc_8h.html#a415942bd7b8183634e44e56b6a40101b" title="Vector multiply odd signed words. ">vec_mulosw()</a>, <a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8" title="Vector multiply even unsigned words. ">vec_muleuw()</a> and <a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d" title="Vector multiply odd unsigned words. ">vec_mulouw()</a>). These implementations include the mandated LE transforms.</p>
<h2><a class="anchor" id="i32_example_0_0_0"></a>
Vector Merge Algebraic High Word example</h2>
<p>This header also provides the higher level operations Vector Merge Algebraic High/low Word (<a class="el" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7" title="Vector Merge Algebraic High Words. ">vec_mrgahw()</a> and <a class="el" href="vec__int32__ppc_8h.html#a4107474cdf1907051de84ea063417911" title="Vector merge Algebraic low words. ">vec_mrgalw()</a>). These implementations generate the correct merge even/odd word instruction for the operation independent of endian. </p><dl class="section note"><dt>Note</dt><dd>The parameters are vector unsigned long (vui64_t) to match results from <a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8" title="Vector multiply even unsigned words. ">vec_muleuw()</a> and <a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d" title="Vector multiply odd unsigned words. ">vec_mulouw()</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div><div class="line"><a class="code" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a> (<a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vrb)</div><div class="line">{</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> res;</div><div class="line"><span class="preprocessor">#ifdef _ARCH_PWR8</span></div><div class="line"><span class="preprocessor">#ifdef vec_vmrgew // Use altivec.h builtins</span></div><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <span class="comment">// really want vmrgew here! So do the opposite.</span></div><div class="line">  res = vec_vmrgow ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrb, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vra);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  res = vec_vmrgew ((<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vra, (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>)vrb);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#else // Generate vmrgew directly in assembler</span></div><div class="line">  __asm__(</div><div class="line">      <span class="stringliteral">&quot;vmrgew %0,%1,%2;\n&quot;</span></div><div class="line">      : <span class="stringliteral">&quot;=v&quot;</span> (res)</div><div class="line">      : <span class="stringliteral">&quot;v&quot;</span> (vra),</div><div class="line">      <span class="stringliteral">&quot;v&quot;</span> (vrb)</div><div class="line">      : );</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#else // POWER7 and earlier, Assume BE only</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vconstp =</div><div class="line">      <a class="code" href="vec__common__ppc_8h.html#a7e03d3eaeafea2c6613233fd58f98ec1">CONST_VINT32_W</a>(0x00010203,  0x10111213, 0x08090a0b,  0x18191a1b);</div><div class="line">  res = (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>) vec_perm ((<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vra, (<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vrb, (<a class="code" href="vec__common__ppc_8h.html#aed458e4755a6589049b936cf9f24f6f8">vui8_t</a>) vconstp);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  <span class="keywordflow">return</span> (res);</div><div class="line">}</div></div><!-- fragment --><p> The implementation is a bit complicated so that is can nullify the unwanted LE transformation of vec_vmrgew(), in addition to handling older and compilers and processors.</p>
<h2><a class="anchor" id="i32_example_0_0_1"></a>
Vector Multiply High Unsigned Word example</h2>
<p>Now we can implement Vector Multiply High Unsigned Word (<a class="el" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3" title="Vector Multiply High Unsigned Word. ">vec_mulhuw()</a>): </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a></div><div class="line"><a class="code" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3">vec_mulhuw</a> (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vra, <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vrb)</div><div class="line">{</div><div class="line"><span class="preprocessor">#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a> (<a class="code" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> (vra, vrb), <a class="code" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> (vra, vrb));</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vec__int32__ppc_8h.html#a0d39dc4278a5e0711e9109746b23f2c7">vec_mrgahw</a> (<a class="code" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8">vec_muleuw</a> (vra, vrb), <a class="code" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d">vec_mulouw</a> (vra, vrb));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">}</span></div></div><!-- fragment --><p> Again the implementation is more complicated than expected as we still have to nullify the LE transformation associated with multiply even/odd.</p>
<p>The good news is all this complexity is contained within pveclib and the generated code is still just 3 instructions. </p><div class="fragment"><div class="line">vmulouw v0,v2,v3</div><div class="line">vmuleuw v2,v2,v3</div><div class="line">vmrgew  v2,v2,v0</div></div><!-- fragment --><h1><a class="anchor" id="int32_examples_0_1"></a>
Vector Word Examples</h1>
<p>Suppose we have a requirement to convert an array of 32-bit time-interval values that need to convert to timespec format. For simplicity we will also assume that the array is nicely (Quadword) aligned and an integer multiple of 4 words.</p>
<p>The PowerISA provides a 64-bit TimeBase register that clocks at a constant 512MHz. The TimeBase can be read directly as either the full 64-bit value or as 32-bit upper and lower halves. For this example we assume that the lower 32-bits of the TimeBase is sufficient to compute intervals (~8.38 seconds). TimeBase values of adjacent events are subtracted to generate the intervals stored in the array.</p>
<p>The timespec format it a struct of unsigned int fields for seconds and microseconds. So the task is to convert the 512MHz TimeBase intervals to microseconds and then split the integer seconds and microseconds for the timespec.</p>
<p>First the TimeBase to microseconds conversion is simply (1000000 / 512000000) which reduces to (1 / 512) or divide by 512. The vector unit does not provide integer divide but luckily, 512 is a power of 2 and we can shift right. If we don't care for the niceties of rounding we can simply shift right 9 bits: </p><div class="fragment"><div class="line">tb_usec = <a class="code" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (*tb++, 9);</div></div><!-- fragment --><p> But if we decide that rounding is important we can leverage the Vector Average Unsigned Word (vavguw) instruction. Here we need to add 256 (512 / 2 = 256) to the timeBase interval before we shift right.</p>
<p>But we need to reverse engineer the vavguw operation to get the results we want. For each word, vavguw computes the sum of A and B plus 1, then shifts the 33-bit sum right 1 bit. We can effectively round by passing the rounding factor as the B operand to the vec_avg() built-in. But we get a +1 and 1 bit right shift for free. So in this case the rounding constant is 256-1 = 255. And we only need to shift an additional 8 bits to complete the conversion: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> rnd_512 =</div><div class="line">  { (256-1), (256-1), (256-1), (256-1) };</div><div class="line"><span class="comment">// Convert 512MHz timebase to microseconds with rounding.</span></div><div class="line">tmp = vec_avg (*tb++, rnd_512);</div><div class="line">tb_usec = <a class="code" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (tmp, 8);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>vec_avg() is an existing altivec.h generic built-in.</dd></dl>
<p>Next we need to separate TimeBase microseconds into the integer seconds and microseconds. Normally scalar codes would use integer divide/modulo by 1000000. Did I mention that the PowerISA vector unit does not have a integer divide operation?</p>
<p>Instead we can use the multiplicative inverse which is a scaled fixed point fraction calculated from the original divisor. This works nicely if the fixed radix point is just before the 32-bit fraction and we have a multiply high (<a class="el" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3" title="Vector Multiply High Unsigned Word. ">vec_mulhuw()</a>) operation. Multiplying a 32-bit unsigned integer by a 32-bit unsigned fraction generates a 64-bit product with 32-bits above (integer) and below (fraction) the radix point. The high 32-bits of the product is the integer quotient.</p>
<p>It turns out that generating the multiplicative inverse can be tricky. To produce correct results over the full analysis, possible pre-scaling and post-shifting, and sometimes a corrective addition is necessary. Fortunately the mathematics are well understood and are commonly used in optimizing compilers. Even better, Henry Warren's book has a whole chapter on this topic. </p><dl class="section see"><dt>See also</dt><dd>"Hacker's Delight, 2nd Edition," Henry S. Warren, Jr, Addison Wesley, 2013. Chapter 10, Integer Division by Constants.</dd></dl>
<p>In the chapter above; </p><blockquote class="doxtable">
<p>Figure 10-2 Computing the magic number for unsigned division.</p>
</blockquote>
<p>provides a sample C function for generating the magic number (actually a struct containing; the magic multiplicative inverse, "add" indicator, and the shift amount.). For the divisor 1000000 this is { 1125899907, 0 , 18 }:</p><ul>
<li>the multiplier is 1125899907.</li>
<li>no corrective add of the dividend is required.</li>
<li>the final shift is 18-bits right.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mul_invs_1m =</div><div class="line">  { 1125899907, 1125899907, 1125899907, 1125899907 };</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> shift_1m = 18;</div><div class="line"></div><div class="line">tmp = <a class="code" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3">vec_mulhuw</a> (tb_usec, mul_invs_1m);</div><div class="line">seconds = <a class="code" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (tmp, shift_1m);</div></div><!-- fragment --><p> Now we need to compute the remainder to get microseconds. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> usec_sec =</div><div class="line">  { 1000000, 1000000, 1000000, 1000000 };</div><div class="line"></div><div class="line">tmp = <a class="code" href="vec__int32__ppc_8h.html#ab3ea7653d4e60454b91d669e2b1bcfdf">vec_muluwm</a> (seconds, usec_sec);</div><div class="line">useconds = vec_sub (tb_usec, tmp);</div></div><!-- fragment --><p>Finally we need to merge the vectors of seconds and useconds into vectors of timespec. </p><div class="fragment"><div class="line">timespec1 = vec_mergeh (seconds, useconds);</div><div class="line">timespec2 = vec_mergel (seconds, useconds);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>vec_sub(), vec_mergeh(), and vec_mergel() are an existing altivec.h generic built-ins.</dd></dl>
<h2><a class="anchor" id="i32_example_0_1_0"></a>
Vectorized TimeBase conversion example</h2>
<p>Here is the complete vectorized TimeBase to timespec conversion example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">example_convert_timebase (<a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> *tb, <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> *timespec, <span class="keywordtype">int</span> n)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> rnd_512 =</div><div class="line">    { (256-1), (256-1), (256-1), (256-1) };</div><div class="line">  <span class="comment">// Magic numbers for multiplicative inverse to divide by 1,000,000</span></div><div class="line">  <span class="comment">// are 1125899907 and shift right 18 bits.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> mul_invs_1m =</div><div class="line">    { 1125899907, 1125899907, 1125899907, 1125899907 };</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> shift_1m = 18;</div><div class="line">  <span class="comment">// Need const for microseconds/second to extract remainder.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> usec_sec =</div><div class="line">    { 1000000, 1000000, 1000000, 1000000 };</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> tmp, tb_usec, seconds, useconds;</div><div class="line">  <a class="code" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> timespec1, timespec2;</div><div class="line">  <span class="keywordtype">int</span> i;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)</div><div class="line">    {</div><div class="line">      <span class="comment">// Convert 512MHz timebase to microseconds with rounding.</span></div><div class="line">      tmp = vec_avg (*tb++, rnd_512);</div><div class="line">      tb_usec = <a class="code" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (tmp, 8);</div><div class="line">      <span class="comment">// extract integer seconds from tb_usec.</span></div><div class="line">      tmp = <a class="code" href="vec__int32__ppc_8h.html#a094c6adb04c1515361426ad58b0fdbb3">vec_mulhuw</a> (tb_usec, mul_invs_1m);</div><div class="line">      seconds = <a class="code" href="vec__int32__ppc_8h.html#af73a97260ce07b46031e2c8560a5320b">vec_srwi</a> (tmp, shift_1m);</div><div class="line">      <span class="comment">// Extract remainder microseconds.</span></div><div class="line">      tmp = <a class="code" href="vec__int32__ppc_8h.html#ab3ea7653d4e60454b91d669e2b1bcfdf">vec_muluwm</a> (seconds, usec_sec);</div><div class="line">      useconds = vec_sub (tb_usec, tmp);</div><div class="line">      <span class="comment">// Use merge high/low to interleave seconds and useconds in timespec.</span></div><div class="line">      timespec1 = vec_mergeh (seconds, useconds);</div><div class="line">      timespec2 = vec_mergel (seconds, useconds);</div><div class="line">      <span class="comment">// Store timespec.</span></div><div class="line">      *timespec++ = timespec1;</div><div class="line">      *timespec++ = timespec2;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="int32_perf_0_0"></a>
Performance data.</h1>
<p>High level performance estimates are provided as an aid to function selection when evaluating algorithms. For background on how <em>Latency</em> and <em>Throughput</em> are derived see: <a class="el" href="index.html#perf_data">Performance data.</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a85ec15f292163e0e40e6faa5f4797367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ec15f292163e0e40e6faa5f4797367">&#9670;&nbsp;</a></span>vec_absduw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_absduw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Absolute Difference Unsigned Word. </p>
<p>Compute the absolute difference for each word. For each unsigned word, subtract VRB[i] from VRA[i] and return the absolute value of the difference.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>vector of 4 x unsigned words </td></tr>
    <tr><td class="paramname">vrb</td><td>vector of 4 x unsigned words </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the absolute differences. </dd></dl>

</div>
</div>
<a id="afbe65a777f2b75022ae584f76d0a2777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe65a777f2b75022ae584f76d0a2777">&#9670;&nbsp;</a></span>vec_clzw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_clzw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Count Leading Zeros word. </p>
<p>Count the number of leading '0' bits (0-32) within each word element of a 128-bit vector.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Count Leading Zeros Word instruction <b>vclzw</b>. Otherwise use sequence of pre 2.07 VMX instructions. SIMDized count leading zeros inspired by:</p>
<p>Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 5 Counting Bits, Figure 5-12.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 4 x 32-bit integer (words) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the Leading Zeros count for each word element. </dd></dl>

</div>
</div>
<a id="a0d39dc4278a5e0711e9109746b23f2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d39dc4278a5e0711e9109746b23f2c7">&#9670;&nbsp;</a></span>vec_mrgahw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mrgahw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Algebraic High Words. </p>
<p>Merge only the high words from 4 x Algebraic doublewords across vectors vra and vrb. This effectively the Vector Merge Even Word operation that is not modified for endian.</p>
<p>For example merge the high 32-bits from 4 x 64-bit products as generated by vec_muleuw/vec_mulouw. This result is effectively a vector multiply high unsigned word.</p>
<dl class="section note"><dt>Note</dt><dd>This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned long. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the high words of the 4 x Algebraic doublewords across vra and vrb. </dd></dl>

</div>
</div>
<a id="a4107474cdf1907051de84ea063417911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4107474cdf1907051de84ea063417911">&#9670;&nbsp;</a></span>vec_mrgalw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mrgalw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector merge Algebraic low words. </p>
<p>Merge the arithmetic low words 4 x Algebraic doublewords across vectors vra and vrb. This is effectively the Vector Merge Odd Word operation that is not modified for endian.</p>
<p>For example merge the low 32-bits from 4 x 64-bit products as generated by vec_muleuw/vec_mulouw. This result is effectively a vector multiply low unsigned word (multiply unsigned word modulo).</p>
<dl class="section note"><dt>Note</dt><dd>This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned long. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the low words of the 4 x Algebraic doublewords across vra and vrb. </dd></dl>

</div>
</div>
<a id="ab67359d6f4003fcb7cca8ed1b64b7cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67359d6f4003fcb7cca8ed1b64b7cf4">&#9670;&nbsp;</a></span>vec_mrgew()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mrgew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Even Words. </p>
<p>Merge the even word elements from the concatenation of 2 x vectors (vra and vrb).</p><ul>
<li>res[0] = vra[0];</li>
<li>res[1] = vrb[0];</li>
<li>res[2] = vra[2];</li>
<li>res[3] = vrb[2];</li>
</ul>
<p>The element numbering changes between big and little-endian environements. So the compiler and this implementation adjusts the generated code to reflect this.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the even words of vra and vrb. </dd></dl>

</div>
</div>
<a id="af10a13aa644282aa60dcbfbd8b02f0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10a13aa644282aa60dcbfbd8b02f0bc">&#9670;&nbsp;</a></span>vec_mrgow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mrgow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Merge Odd Words. </p>
<p>Merge the odd word elements from the concatenation of 2 x vectors (vra and vrb).</p><ul>
<li>res[0] = vra[1];</li>
<li>res[1] = vrb[1];</li>
<li>res[2] = vra[3];</li>
<li>res[3] = vrb[3];</li>
</ul>
<p>The element numbering changes between big and little-endian environements. So the compiler and this implementation adjusts the generated code to reflect this.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector merge from only the even words of vra and vrb. </dd></dl>

</div>
</div>
<a id="add7b91bf6138d029d9d8cc57b0905f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7b91bf6138d029d9d8cc57b0905f1f">&#9670;&nbsp;</a></span>vec_mulesw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_mulesw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector multiply even signed words. </p>
<p>Multiple the even words of two vector signed int values and return the signed long product of the even words.</p>
<p>For POWER8 and later we can use the vmulesw instruction. But for POWER7 and earlier we have to construct word multiplies from halfword multiplies. See <a class="el" href="vec__int32__ppc_8h.html#ac93f07d5ad73243db2771da83b50d6d8" title="Vector multiply even unsigned words. ">vec_muleuw()</a>.</p>
<p>Here we start with a unsigned vec_muleuw product, then correct the high 32-bits of the product to signed. Based on: Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 8 Multiplication, Section 8-3 High-Order Product Signed from/to Unsigned.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector signed int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector signed long product of the even words of a and b. </dd></dl>

</div>
</div>
<a id="ac93f07d5ad73243db2771da83b50d6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93f07d5ad73243db2771da83b50d6d8">&#9670;&nbsp;</a></span>vec_muleuw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_muleuw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector multiply even unsigned words. </p>
<p>Multiple the even words of two vector unsigned int values and return the unsigned long product of the even words.</p>
<p>For POWER8 and later we can use the vmuleuw instruction. But for POWER7 and earlier we have to construct word multiplies from two halfword multiplies (vmuleuh and vmulouh). Then sum the partial products for the final doubleword results. This is complicated by the fact that vector add doubleword is not available for POWER7. So we need to construct the doubleword add from Vector Add Unsigned Word Modulo (vadduwm) and Vector Add and Write Carry-Out Unsigned Word (vaddcuw) with shift double quadword to reposition the low word carry and a final vadduwm to complete the carry propagation for the doubleword add.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long product of the even words of a and b. </dd></dl>

</div>
</div>
<a id="a316e9909abc24eb4f9b5d6d29fe64185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316e9909abc24eb4f9b5d6d29fe64185">&#9670;&nbsp;</a></span>vec_mulhsw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vec_mulhsw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Signed Word. </p>
<p>Multiple the corresponding word elements of two vector signed int values and return the high order 32-bits, for each 64-bit product element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector signed int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the high order 32-bits of the product of the word elements from vra and vrb. </dd></dl>

</div>
</div>
<a id="a094c6adb04c1515361426ad58b0fdbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094c6adb04c1515361426ad58b0fdbb3">&#9670;&nbsp;</a></span>vec_mulhuw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_mulhuw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply High Unsigned Word. </p>
<p>Multiple the corresponding word elements of two vector unsigned int values and return the high order 32-bits, from each 64-bit product.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">9 </td><td align="left">1/cycle </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This operation can be used to effectively perform a divide by multiplying by the scaled multiplicative inverse (reciprocal).</dd></dl>
<p>Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 10, Integer Division by Constants.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the high order 32-bits of the signed product of the word elements from vra and vrb. </dd></dl>

</div>
</div>
<a id="a415942bd7b8183634e44e56b6a40101b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415942bd7b8183634e44e56b6a40101b">&#9670;&nbsp;</a></span>vec_mulosw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a0c3abdfe41178c152e0a2130c20476ff">vi64_t</a> vec_mulosw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector multiply odd signed words. </p>
<p>Multiple the odd words of two vector signed int values and return the signed long product of the odd words.</p>
<p>For POWER8 and later we can use the vmulosw instruction. But for POWER7 and earlier we have to construct word multiplies from halfword multiplies. See <a class="el" href="vec__int32__ppc_8h.html#a3ca45c65b9627abfc493d4ad500a961d" title="Vector multiply odd unsigned words. ">vec_mulouw()</a>.</p>
<p>Here we start with a unsigned vec_mulouw product, then correct the high-order 32-bits of the product to signed. Based on: Warren, Henry S. Jr and <em>Hacker's Delight</em>, 2nd Edition, Addison Wesley, 2013. Chapter 8 Multiplication, Section 8-3 High-Order Product Signed from/to Unsigned.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector signed int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector signed long product of the odd words of a and b. </dd></dl>

</div>
</div>
<a id="a3ca45c65b9627abfc493d4ad500a961d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca45c65b9627abfc493d4ad500a961d">&#9670;&nbsp;</a></span>vec_mulouw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_mulouw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector multiply odd unsigned words. </p>
<p>Multiple the odd words of two vector unsigned int values and return the unsigned long product of the odd words.</p>
<p>For POWER8 and later we can use the vmulouw instruction. But for POWER7 and earlier we have to construct word multiplies from two halfword multiplies (vmuleuh and vmulouh). Then sum the partial products for the final doubleword results. This is complicated by the fact that vector add doubleword is not available for POWER7. So we need to construct the doubleword add from Vector Add Unsigned Word Modulo (vadduwm) and Vector Add and Write Carry-Out Unsigned Word (vaddcuw) with shift double quadword to reposition the low word carry and a final vadduwm to complete the carry propagation for the doubleword add.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long product of the odd words of a and b. </dd></dl>

</div>
</div>
<a id="ab3ea7653d4e60454b91d669e2b1bcfdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ea7653d4e60454b91d669e2b1bcfdf">&#9670;&nbsp;</a></span>vec_muluwm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_muluwm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Unsigned Word Modulo. </p>
<p>Multiple the corresponding word elements of two vector unsigned int values and return the low order 32-bits of the 64-bit product for each element.</p>
<dl class="section note"><dt>Note</dt><dd>vec_muluwm can be used for unsigned or signed integers. It is the vector equivalent of Multiply Low Word.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-bit vector signed int. </td></tr>
    <tr><td class="paramname">b</td><td>128-bit vector signed int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of the low order 32-bits of the unsigned product of the word elements from vra and vrb. </dd></dl>

</div>
</div>
<a id="acb5b81dc628ca80e079a86515e391023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5b81dc628ca80e079a86515e391023">&#9670;&nbsp;</a></span>vec_popcntw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_popcntw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Population Count word. </p>
<p>Count the number of '1' bits (0-32) within each word element of a 128-bit vector.</p>
<p>For POWER8 (PowerISA 2.07B) or later use the Vector Population Count Word instruction. Otherwise use the pveclib vec_popcntb to count each byte then sum across with Vector Sum across Quarter Unsigned Byte Saturate.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector treated as 4 x 32-bit integer (words) elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector with the population count for each word element. </dd></dl>

</div>
</div>
<a id="ae4d2c7192202e70f52997ab743418a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d2c7192202e70f52997ab743418a77">&#9670;&nbsp;</a></span>vec_revbw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_revbw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>byte reverse each word of a vector unsigned int. </p>
<p>For each word of the input vector, reverse the order of bytes / octets within the word.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">2-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">3 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 128-bit vector with the bytes of each word reversed. </dd></dl>

</div>
</div>
<a id="a500924c8925b336d49b6a5d4307fe14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500924c8925b336d49b6a5d4307fe14c">&#9670;&nbsp;</a></span>vec_slwi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_slwi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift left Word Immediate. </p>
<p>Shift left each word element [0-3], 0-31 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-31. A shift count of 0 returns the original value of vra. Shift counts greater then 31 bits return zero.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-11 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned int. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-31. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned int, shifted left shb bits. </dd></dl>

</div>
</div>
<a id="aefb4872afdd52b5ba965856c7e1a58ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb4872afdd52b5ba965856c7e1a58ad">&#9670;&nbsp;</a></span>vec_srawi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a> vec_srawi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#adf5717f56a3dac6980206dbd37614ca2">vi32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Algebraic Word Immediate. </p>
<p>Shift Right Algebraic each word element [0-3], 0-31 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-31. A shift count of 0 returns the original value of vra. Shift counts greater then 31 bits return the sign bit propagated to each bit of each element.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-11 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector signed int. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-31. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector signed int, shifted right shb bits. </dd></dl>

</div>
</div>
<a id="af73a97260ce07b46031e2c8560a5320b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73a97260ce07b46031e2c8560a5320b">&#9670;&nbsp;</a></span>vec_srwi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a> vec_srwi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Shift Right Word Immediate. </p>
<p>Shift right each word element [0-3], 0-31 bits, as specified by an immediate value. The shift amount is a const unsigned int in the range 0-31. A shift count of 0 returns the original value of vra. Shift counts greater then 31 bits return zero.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">4-11 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">5-11 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>a 128-bit vector treated as a vector unsigned char. </td></tr>
    <tr><td class="paramname">shb</td><td>shift amount in the range 0-31. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>128-bit vector unsigned int, shifted right shb bits. </dd></dl>

</div>
</div>
<a id="a1b046a56d566ec2ea351042fd9dd11de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b046a56d566ec2ea351042fd9dd11de">&#9670;&nbsp;</a></span>vec_vmadd2euw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmadd2euw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add2 Even Unsigned Words. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int64__ppc_8h.html#a1b046a56d566ec2ea351042fd9dd11de">vec_int64_ppc::h::vec_vmadd2euw()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546" title="Vector Add Unsigned Doubleword Modulo. ">vec_addudm()</a>. </dd></dl>

</div>
</div>
<a id="a40ab00ed413c1aa1a8148cd9981235bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ab00ed413c1aa1a8148cd9981235bf">&#9670;&nbsp;</a></span>vec_vmadd2ouw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmadd2ouw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add2 Odd Unsigned Words. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int64__ppc_8h.html#a40ab00ed413c1aa1a8148cd9981235bf">vec_int64_ppc::h::vec_vmadd2ouw()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546" title="Vector Add Unsigned Doubleword Modulo. ">vec_addudm()</a>. </dd></dl>

</div>
</div>
<a id="a1e20bdd1df7e3e49dca06d5512ada84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e20bdd1df7e3e49dca06d5512ada84b">&#9670;&nbsp;</a></span>vec_vmaddeuw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmaddeuw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add Even Unsigned Words. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int64__ppc_8h.html#a1e20bdd1df7e3e49dca06d5512ada84b">vec_int64_ppc::h::vec_vmaddeuw()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546" title="Vector Add Unsigned Doubleword Modulo. ">vec_addudm()</a>. </dd></dl>

</div>
</div>
<a id="a32acead723b7867ff4c9f8be9bb708ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32acead723b7867ff4c9f8be9bb708ca">&#9670;&nbsp;</a></span>vec_vmaddouw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmaddouw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Add Odd Unsigned Words. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int64__ppc_8h.html#a32acead723b7867ff4c9f8be9bb708ca">vec_int64_ppc::h::vec_vmaddouw()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546" title="Vector Add Unsigned Doubleword Modulo. ">vec_addudm()</a>. </dd></dl>

</div>
</div>
<a id="a0bb37f8c3bb75090db08ab0981249ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb37f8c3bb75090db08ab0981249ae7">&#9670;&nbsp;</a></span>vec_vmsumuwm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmsumuwm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply-Sum Unsigned Word Modulo. </p>
<dl class="section note"><dt>Note</dt><dd>this implementation exists in <a class="el" href="vec__int64__ppc_8h.html#a431720fd713485fcb13963cdcb89ac76">vec_int64_ppc::h::vec_vmsumuwm()</a> as it requires <a class="el" href="vec__int64__ppc_8h.html#a28052c1907d1f733c9dda8a48039e546" title="Vector Add Unsigned Doubleword Modulo. ">vec_addudm()</a>. </dd></dl>

</div>
</div>
<a id="ae30f226bd27241513f0611b50967a080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30f226bd27241513f0611b50967a080">&#9670;&nbsp;</a></span>vec_vmuleuw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmuleuw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Even Unsigned words. </p>
<p>Multiply the even words of two vector unsigned int values and return the unsigned long product of the even words.</p>
<p>For POWER8 and later we can use the vmuleuw instruction. But for POWER7 and earlier we have to construct word multiplies from two halfword multiplies (vmuleuh and vmulouh). Then sum the partial products for the final doubleword results. This is complicated by the fact that vector add doubleword is not available for POWER7. So we need to construct the doubleword add from Vector Add Unsigned Word Modulo (vadduwm) and Vector Add and Write Carry-Out Unsigned Word (vaddcuw) with shift double quadword to reposition the low word carry and a final vadduwm to complete the carry propagation for the doubleword add.</p>
<dl class="section note"><dt>Note</dt><dd>This implementation is NOT endian sensitive and the function is stable across BE/LE implementations.</dd></dl>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long product of the even words of a and b. </dd></dl>

</div>
</div>
<a id="ae52349ced57857d20fb5e06b1b09cc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52349ced57857d20fb5e06b1b09cc05">&#9670;&nbsp;</a></span>vec_vmulouw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="vec__common__ppc_8h.html#a52a773b6353c69a546bdc2e8686a50ec">vui64_t</a> vec_vmulouw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec__common__ppc_8h.html#a2ff4a776536870e01b7c9e454586544b">vui32_t</a>&#160;</td>
          <td class="paramname"><em>vrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector Multiply Odd Unsigned Words. </p>
<p>Multiply the odd words of two vector unsigned int values and return the unsigned long product of the odd words.</p>
<p>For POWER8 and later we can use the vmulouw instruction. But for POWER7 and earlier we have to construct word multiplies from two halfword multiplies (vmuleuh and vmulouh). Then sum the partial products for the final doubleword results. This is complicated by the fact that vector add doubleword is not available for POWER7. So we need to construct the doubleword add from Vector Add Unsigned Word Modulo (vadduwm) and Vector Add and Write Carry-Out Unsigned Word (vaddcuw) with shift double quadword to reposition the low word carry and a final vadduwm to complete the carry propagation for the doubleword add.</p>
<table class="doxtable">
<tr>
<th align="right">processor</th><th align="center">Latency</th><th align="left">Throughput  </th></tr>
<tr>
<td align="right">power8 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
<tr>
<td align="right">power9 </td><td align="center">7 </td><td align="left">2/cycle </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vra</td><td>128-bit vector unsigned int. </td></tr>
    <tr><td class="paramname">vrb</td><td>128-bit vector unsigned int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector unsigned long product of the odd words of a and b. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 17 2020 17:13:19 for POWER Vector Library Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
